-- Required files, generated by compiler
_REQ = {}
_REQ['YFS:version_out.lua']=(function()
local version =
{
    APP_NAME = "Yoarii's Flight System",
    APP_VERSION = "850e7fe / 20231223 22:22"
}

return version

end)()
_REQ['YFS:screen/offline_layout.lua']=(function()
local ver = _REQ['YFS:version_out.lua']
local layout = {
    fonts = {
        version = {
            font = "Play",
            size = 18
        },
        offline = {
            font = "Play",
            size = 36
        }
    },
    styles = {
        version = {
            fill = "#ffffffff",
            align = "h2,v4"
        },
        bkgDark = {
            fill = "#2F3637ff"
        },
        offline = {
            fill = "#ffffffff",
            align = "h1,v2"
        }
    },
    pages = {
        offline = {
            components = {
                {
                    comment = "background",
                    type = "box",
                    layer = 1,
                    style = "bkgDark",
                    pos1 = "(0,0)",
                    pos2 = "(1024,613)"
                },
                {
                    type = "text",
                    layer = 1,
                    pos1 = "(512,500)",
                    text = "YFS - Offline",
                    font = "offline",
                    style = "offline"
                },
                {
                    type = "image",
                    layer = 2,
                    pos1 = "(260,180)",
                    dimensions = "(180,210)",
                    url = "assets.prod.novaquark.com/94617/dcf01ca2-4e9d-410c-ac90-f806634671d9.png",
                    style = "bkgDark"
                },
                {
                    type = "image",
                    layer = 2,
                    pos1 = "(640,180)",
                    dimensions = "(180,180)",
                    url = "assets.prod.novaquark.com/70604/92eeafe5-527f-49f5-af7a-cb0c4a771f5b.png",
                    style = "bkgDark"
                },
                {
                    type = "text",
                    pos1 = "(1004,593)",
                    text = ver.APP_VERSION,
                    layer = 1,
                    font = "version",
                    style = "version"
                }
            }
        }
    }
}

return layout

end)()
_REQ['YFS:../e/render/src/native/Color.lua']=(function()
local max = math.max
local min = math.min
local format = string.format

local clamp = function(v, lower, upper)
    return min(max(v, lower), upper)
end

---@param hex string #00...FF
---@return number
local function hexToDec(hex)
    return tonumber("0x" .. hex) / 255
end

---@class Color
---@field ToString fun():string
---@field FromString fun(s:string|nil):Color
---@field Unpack fun():number, number, number, number Unpacks the color into its components
---@field Red number
---@field Green number
---@field Blue number
---@field Alpha number
---@field Clone fun():Color

local Color = {}
Color.__index = Color


---Create a new color. Numbers above 1 results in HDR rendering
---@param red number
---@param green number
---@param blue number
---@param alpha? number
function Color.New(red, green, blue, alpha)
    local s = {
        Red = clamp(red, 0, 5),
        Green = clamp(green, 0, 5),
        Blue = clamp(blue, 0, 5),
        Alpha = clamp(alpha or 1, 0, 1)
    }

    ---Unpacks the color
    ---@return number, number, number, number
    function s.Unpack()
        return s.Red, s.Green, s.Blue, s.Alpha
    end

    ---Clones the color
    ---@return Color
    function s.Clone()
        return Color.New(s.Red, s.Green, s.Blue, s.Alpha)
    end

    ---Prints the color
    ---@return string
    function s.ToString()
        return string.format(Color.FormatString, s.Red, s.Green, s.Blue, s.Alpha)
    end

    return setmetatable(s, Color)
end

---ToString meta function
---@param c Color
---@return string
function Color.__tostring(c)
    return c.ToString()
end

---@param a Color
---@param b Color
---@return boolean
function Color.__eq(a, b)
    return a.Red == b.Red
        and a.Green == b.Green
        and a.Blue == b.Blue
        and a.Alpha == b.Alpha
end

---Creates a transparent color
---@return Color
function Color.Transparent()
    return Color.New(0, 0, 0, 0)
end

---Creates a Color from a string
---@param s string|nil
---@return Color
function Color.FromString(s)
    if not s then return Color.Transparent() end

    local r, g, b, a = s:match("^r(%d*%.?%d+),g(%d*%.?%d+),b(%d*%.?%d+),a(%d*%.?%d+)$")
    r = tonumber(r)
    g = tonumber(g)
    b = tonumber(b)
    a = tonumber(a)
    if r and g and b and a then
        return Color.New(r, g, b, a)
    end

    -- check hex values
    r, g, b, a = s:match("^%s*#%s*(%x%x)(%x%x)(%x%x)(%x%x)%s*$")
    if r and g and b and a then
        return Color.New(hexToDec(r), hexToDec(g), hexToDec(b), hexToDec(a))
    end

    return Color.Transparent()
end

Color.FormatString = "r%0.3f,g%0.3f,b%0.3f,a%0.3f"

return Color

end)()
_REQ['YFS:../e/render/src/native/Vec2.lua']=(function()
--- A 2 component vector based on cpml/Vec2
--- https://github.com/excessive/cpml/blob/master/modules/Vec2.lua

local atan2 = math.atan
local sqrt  = math.sqrt
local cos   = math.cos
local sin   = math.sin
local abs   = math.abs

---@class Vec2
---@field x number
---@field y number
---@field New fun(x:number|{x:number,y:number}|number[], y:number|nil):Vec2
---@field unit_x Vec2 X axis of rotation
---@field unit_y Vec2 Y axis of rotation
---@field zero Vec2 Empty vector
---@field FromCartesian fun(radius:number, theta:number):Vec2
---@field Clone fun(v:Vec2):Vec2
---@field Add fun(a:Vec2, b:Vec2):Vec2 Add two vectors.
---@field Sub fun(a:Vec2, b:Vec2):Vec2 Subtract two vectors.
---@field Mul fun(a:Vec2, b:Vec2):Vec2 Multiply two vectors.
---@field Div fun(a:Vec2, b:Vec2):Vec2 Divide two vectors.
---@field Normalize fun(a:Vec2):Vec2
---@field Trim fun(a:Vec2, len:number):Vec2
---@field Cross fun(a:Vec2, b:Vec2):number
---@field Dot fun(a:Vec2, b:Vec2):number
---@field Len fun(a:Vec2):number
---@field Len2 fun(a:Vec2):number
---@field Dist fun(a:Vec2, b:Vec2):number
---@field Dist2 fun(a:Vec2, b:Vec2):number
---@field Scale fun(a:Vec2, b:number):Vec2
---@field Rotate fun(a:Vec2, phi:number)
---@field Perpendicular fun(a:Vec2):Vec2
---@field AngleTo fun(a:Vec2, b:Vec2):number
---@field Lerp fun(a:Vec2, b:Vec2, s:number):Vec2
---@field Unpack fun(a:Vec2):number, number
---@field ComponentMin fun(a:Vec2, b:Vec2):Vec2
---@field ComponentMax fun(a:Vec2, b:Vec2):Vec2
---@field IsVec2 fun(a:Vec2):boolean
---@field IsZero fun(a:Vec2):boolean
---@field ToPolar fun(a:Vec2):number, number
---@field FlipX fun(a:Vec2):Vec2
---@field FlipY fun(a:Vec2):Vec2
---@field Abs fun(a:Vec2):Vec2
---@field ToString fun(a:Vec2):string
---@operator add(Vec2):Vec2
---@operator sub(Vec2):Vec2
---@operator div(Vec2):Vec2
---@operator div(number):Vec2
---@operator mul(Vec2):Vec2
---@operator mul(number):Vec2
---@operator unm:Vec2

local Vec2 = {}
Vec2.__index = Vec2

---Create a new Vec2
---@param x number|{x:number,y:number}|number[]|nil
---@param y number|nil
---@return Vec2
function Vec2.New(x, y)
    local s = {}

    if x and y then
        s.x = x
        s.y = y
        -- {x, y} or {x=x, y=y}
    elseif type(x) == "table" then
        s.x, s.y = x.x or x[1], x.y or x[2]
    elseif type(x) == "number" then
        s.x = x
        s.y = x
    else
        s.x = 0
        s.y = 0
    end

    return setmetatable(s, Vec2)
end

Vec2.unit_x = Vec2.New(1, 0)
Vec2.unit_y = Vec2.New(0, 1)
Vec2.zero   = Vec2.New(0, 0)

---Convert point from polar to cartesian.
---@param radius number Radius of the point
---@param theta number Angle of the point (in radians)
---@return Vec2
function Vec2.FromCartesian(radius, theta)
    return Vec2.New(radius * cos(theta), radius * sin(theta))
end

---Clone a vector.
---@param a Vec2 Vector to be cloned
---@return Vec2
function Vec2.Clone(a)
    return Vec2.New(a.x, a.y)
end

---Add two vectors.
---@param a Vec2 Left hand operand
---@param b Vec2 Right hand operand
---@return Vec2 out
function Vec2.Add(a, b)
    return Vec2.New(
        a.x + b.x,
        a.y + b.y
    )
end

---Subtract one vector from another.
---Order: If a and b are positions, computes the direction and distance from b
---to a.
---@param a Vec2 Left hand operand
---@param b Vec2 Right hand operand
---@return Vec2 out
function Vec2.Sub(a, b)
    return Vec2.New(
        a.x - b.x,
        a.y - b.y
    )
end

--- Multiply a vector by another vector.
-- Component-size multiplication not matrix multiplication.
---@param a Vec2  Left hand operand
---@param b Vec2  Right hand operand
---@return Vec2 out
function Vec2.Mul(a, b)
    return Vec2.New(
        a.x * b.x,
        a.y * b.y
    )
end

--- Divide a vector by another vector.
-- Component-size inv multiplication. Like a non-uniform scale().
---@param a Vec2  Left hand operand
---@param b Vec2  Right hand operand
---@return Vec2 out
function Vec2.Div(a, b)
    return Vec2.New(
        a.x / b.x,
        a.y / b.y
    )
end

--- Get the normal of a vector.
---@param a Vec2  Vector to normalize
---@return Vec2 out
function Vec2.Normalize(a)
    if a:IsZero() then
        return Vec2.New()
    end
    return a:Scale(1 / a:Len())
end

--- Trim a vector to a given length.
---@param a Vec2  Vector to be trimmed
---@param len number Length to trim the vector to
---@return Vec2
function Vec2.Trim(a, len)
    return a:Normalize():Scale(math.min(a:Len(), len))
end

--- Get the cross product of two vectors.
-- Order: Positive if a is clockwise from b. Magnitude is the area spanned by
-- the parallelograms that a and b span.
---@param a Vec2  Left hand operand
---@param b Vec2  Right hand operand
---@return number
function Vec2.Cross(a, b)
    return a.x * b.y - a.y * b.x
end

--- Get the dot product of two vectors.
---@param a Vec2  Left hand operand
---@param b Vec2  Right hand operand
---@return number
function Vec2.Dot(a, b)
    return a.x * b.x + a.y * b.y
end

--- Get the length of a vector.
---@param a Vec2  Vector to get the length of
---@return number
function Vec2.Len(a)
    return sqrt(a.x * a.x + a.y * a.y)
end

--- Get the squared length of a vector.
---@param a Vec2  Vector to get the squared length of
---@return number
function Vec2.Len2(a)
    return a.x * a.x + a.y * a.y
end

--- Get the distance between two vectors.
---@param a Vec2  Left hand operand
---@param b Vec2  Right hand operand
---@return number
function Vec2.Dist(a, b)
    local dx = a.x - b.x
    local dy = a.y - b.y
    return sqrt(dx * dx + dy * dy)
end

--- Get the squared distance between two vectors.
---@param a Vec2  Left hand operand
---@param b Vec2  Right hand operand
---@return number
function Vec2.Dist2(a, b)
    local dx = a.x - b.x
    local dy = a.y - b.y
    return dx * dx + dy * dy
end

--- Scale a vector by a scalar.
---@param a Vec2  Left hand operand
---@param b number Right hand operand
---@return Vec2 out
function Vec2.Scale(a, b)
    return Vec2.New(
        a.x * b,
        a.y * b
    )
end

--- Rotate a vector.
---@param a Vec2  Vector to rotate
---@param phi number Angle to rotate vector by (in radians)
---@return Vec2 out
function Vec2.Rotate(a, phi)
    local c = cos(phi)
    local s = sin(phi)
    return Vec2.New(
        c * a.x - s * a.y,
        s * a.x + c * a.y
    )
end

--- Get the perpendicular vector of a vector.
---@param a Vec2  Vector to get perpendicular axes from
---@return Vec2 out
function Vec2.Perpendicular(a)
    return Vec2.New(-a.y, a.x)
end

--- Signed angle from one vector to another.
-- Rotations from +x to +y are positive.
---@param a Vec2  Vector
---@param b Vec2  Vector
---@return number angle in [-pi, pi]
function Vec2.AngleTo(a, b)
    if b then
        local angle = atan2(b.y, b.x) - atan2(a.y, a.x)
        -- convert to (-pi, pi]
        if angle > math.pi then
            angle = angle - 2 * math.pi
        elseif angle <= -math.pi then
            angle = angle + 2 * math.pi
        end
        return angle
    end

    return atan2(a.y, a.x)
end

--- Lerp between two vectors.
---@param a Vec2  Left hand operand
---@param b Vec2  Right hand operand
---@param s number Step value
---@return Vec2
function Vec2.Lerp(a, b, s)
    return a + (b - a) * s
end

--- Unpack a vector into individual components.
---@param a Vec2  Vector to unpack
---@return number x
---@return number y
function Vec2.Unpack(a)
    return a.x, a.y
end

--- Return the component-wise minimum of two vectors.
---@param a Vec2  Left hand operand
---@param b Vec2  Right hand operand
---@return Vec2 A vector where each component is the lesser value for that component between the two given vectors.
function Vec2.ComponentMin(a, b)
    return Vec2.New(math.min(a.x, b.x), math.min(a.y, b.y))
end

--- Return the component-wise maximum of two vectors.
---@param a Vec2  Left hand operand
---@param b Vec2  Right hand operand
---@return Vec2 A vector where each component is the lesser value for that component between the two given vectors.
function Vec2.ComponentMax(a, b)
    return Vec2.New(math.max(a.x, b.x), math.max(a.y, b.y))
end

--- Return a boolean showing if a table is or is not a Vec2.
---@param a any  Vector to be tested
---@return boolean is_Vec2
function Vec2.IsVec2(a)
    return type(a) == "table" and
        type(a.x) == "number" and
        type(a.y) == "number"
end

--- Return a boolean showing if a table is or is not a zero Vec2.
---@param a Vec2  Vector to be tested
---@return boolean is_zero
function Vec2.IsZero(a)
    return a.x == 0 and a.y == 0
end

--- Convert point from cartesian to polar.
---@param a Vec2  Vector to convert
---@return number radius
---@return number theta
function Vec2.ToPolar(a)
    local radius = sqrt(a.x ^ 2 + a.y ^ 2)
    local theta  = atan2(a.y, a.x)
    theta        = theta > 0 and theta or theta + 2 * math.pi
    return radius, theta
end

-- Negate x axis only of vector.
---@param a Vec2  Vector to x-flip.
---@return Vec2 x-flipped vector
function Vec2.FlipX(a)
    return Vec2.New(-a.x, a.y)
end

-- Negate y axis only of vector.
---@param a Vec2  Vector to y-flip.
---@return Vec2 y-flipped vector
function Vec2.FlipY(a)
    return Vec2.New(a.x, -a.y)
end

-- Returns the absolute value
---@param a Vec2  Vector to abs
---@return Vec2
function Vec2.Abs(a)
    return Vec2.New(abs(a.x), abs(a.y))
end

--- Return a formatted string.
---@param a Vec2  Vector to be turned into a string
---@return string formatted
function Vec2.ToString(a)
    return string.format("(%+0.3f,%+0.3f)", a.x, a.y)
end

function Vec2.__tostring(a)
    return a:ToString()
end

---Negation operator
---@param a Vec2
---@return Vec2
function Vec2.__unm(a)
    return Vec2.New(-a.x, -a.y)
end

---Equality operator
---@param a Vec2|any
---@param b Vec2|any
---@return boolean
function Vec2.__eq(a, b)
    if not Vec2.IsVec2(a) or not Vec2.IsVec2(b) then
        return false
    end
    return a.x == b.x and a.y == b.y
end

---Addition operator
---@param a Vec2
---@param b Vec2
---@return Vec2
function Vec2.__add(a, b)
    return a:Add(b)
end

---Subtraction operator
---@param a Vec2
---@param b Vec2
---@return Vec2
function Vec2.__sub(a, b)
    return a:Sub(b)
end

---Multiplication operator
---@param a Vec2
---@param b Vec2|number
---@return Vec2
function Vec2.__mul(a, b)
    if Vec2.IsVec2(b) then
        ---@cast b Vec2
        return a:Mul(b)
    end

    ---@cast b number
    return a:Scale(b)
end

---Division operator
---@param a Vec2
---@param b Vec2|number
---@return Vec2
function Vec2.__div(a, b)
    if Vec2.IsVec2(b) then
        ---@cast b Vec2
        return a:Div(b)
    end

    return a:Scale(1 / b)
end

---Creates a Vec2 from a string
---@param s string
---@return Vec2|nil
function Vec2.FromString(s)
    if s then
        local x, y = s:match("^%(%s?([+-]*%d*%.?%d+)%s?,%s?([+-]*%d*%.?%d+)%s?%)$")
        x = tonumber(x)
        y = tonumber(y)
        if x and y then
            return Vec2.New(x, y)
        end
    end
    return nil
end

return Vec2

end)()
_REQ['YFS:../e/render/src/native/RenderScript.lua']=(function()
local Vec2 = _REQ['YFS:../e/render/src/native/Vec2.lua']

---@enum RSShape
RSShape = {
    Bezier = 0,
    Box = 1,
    BoxRounded = 2,
    Circle = 3,
    Image = 4,
    Line = 5,
    Polygon = 6,
    Text = 7,
}

---@class Render
---@field AddBezier fun(layer:integer, x1:number, y1:number, x2:number, y2:number, x3:number, y3:number)
---@field AddBox fun(layer:integer, x:number, y:number, width:number, height:number)
---@field AddBoxRounded fun(layer:integer, x:number, y:number, width:number, height:number, radius:number)
---@field AddCircle fun(layer:integer, x:number, y:number, radius:number)
---@field AddImage fun(layer:integer, image:integer, x:number, y:number, width:number, height:number)
---@field AddImageSub fun(layer:integer, image:integer, x:number, y:number, width:number, height:number, subX:number, subY:number, subWidth:number, subHeight:number)
---@field AddLine fun(layer:integer, x1:number, y1:number, x2:number, y2:number)
---@field AddQuad fun(layer:integer, x1:number, y1:number, x2:number, y2:number, x3:number, y3:number, x4:number, y4:number)
---@field AddText fun(layer:integer, font:FontHandle, text:string, x:number, y:number)
---@field AddTriangle fun(layer:integer, x1:number, y1:number, x2:number, y2:number, x3:number, y3:number)
---@field CreateLayer fun():integer
---@field GetAvailableFontCount fun():integer
---@field GetAvailableFontName fun(index):string
---@field GetCursor fun():number,number Returns a tuple containing the (x, y) coordinates of the cursor, or (-1, -1) if the screen is not currently raycasted
---@field GetCursorDown fun():boolean True if the mouse cursor is currently pressed down on the screen, false otherwise
---@field GetCursorPressed fun():boolean True if the mouse cursor has been pressed down on the screen at any time since the last script execution, false otherwise
---@field GetCursorReleased fun():boolean True if the mouse cursor has been released on the screen at any time since the last script execution, false otherwise
---@field GetDeltaTime fun():number Return the time, in seconds, since the screen was last updated.
---@field GetFontMetrics fun(font:integer):number,number A tuple containing the maximal ascender and descender, respectively, of the given font
---@field GetFontSize fun(font:integer):number The font size in vertical pixels
---@field GetImageSize fun(image:integer):number,number A tuple containing the width and height, respectively, of the image, or (0, 0) if the image is not yet loaded
---@field GetInput fun():string The input string, as set by the screen unit API function setScriptInput, or an empty string if there is no current input
---@field GetLocale fun():string The locale, currently one of "en-US", "fr-FR", or "de-DE"
---@field GetRenderCost fun():number The cost of all rendering operations performed by the render script so far (at the time of the call to this function)
---@field GetRenderCostMax fun():number The render cost limit. A script that exceeds this limit (in one execution) will not render correctly and will instead throw an error. Note that this value may change between version releases
---@field GetResolution fun():number,number A tuple containing the (width, height) of the screen's render surface, in pixels
---@field GetTextBounds fun(font:LoadedFont, text:string):Vec2 A tuple containing the width and height, respectively, of the bounding box
---@field GetTime fun():number Time, in seconds, since the render script started running
---@field IsImageLoaded fun(image:integer):boolean True if the image is fully loaded and ready to use, false otherwise
---@field LoadImage fun(url:string):integer Load an image to be used with addImage from the given URL
---@field LoadFont fun(name:string, size:integer):integer Load a font to be used with addText
---@field Log fun(message:string) Log a message for debugging purposes. If the "enable output in Lua channel" box is checked on the editor panel for the given screen, the message will be displayed in the Lua channel.
---@field RequestAnimationFrame fun(frames:integer) Request that this screen should be redrawn in a certain number of frames. A screen that requires highly-fluid animations should call requestAnimationFrame(1) before it returns.
---@field SetBackgroundColor fun(red:number, green:number, blue:number) Set the background color of the screen
---@field SetDefaultFillColor fun(layer:integer, shape:RSShape, red:number, green:number, blue:number, alpha:number) Set the default fill color for all subsequent shapes of the given type added to the given layer
---@field SetDefaultRotation fun(layer:integer, shape:RSShape, rotationRad:number) Set the default rotation for all subsequent shapes of the given type added to the given layer in radians; positive is counter-clockwise, negative is clockwise
---@field SetDefaultShadow fun(layer:integer, shape:RSShape, radius:number, red:number, green:number, blue:number, alpha:number) Set the default shadow for all subsequent shapes of the given type added to the given layer
---@field SetDefaultStrokeColor fun(layer:integer, shape:RSShape, red:number, green:number, blue:number, alpha:number) Set the default stroke color for all subsequent shapes of the given type added to the given layer
---@field SetDefaultStrokeWidth fun(layer:integer, shape:RSShape, strokeWidth:number)  Set the default stroke width for all subsequent shapes of the given type added to the given layer
---@field SetDefaultTextAlign fun(layer:integer, hor:RSAlignHor, ver:RSAlignVer) Set the default text alignment of all subsequent text strings on the given layer
---@field SetFontSize fun(font:integer, size:integer) Set the size at which a font will render.
---@field SetLayerClipRect fun(layer:integer, x:number, y:number, width:number, height:number) Set a clipping rectangle applied to the layer as a whole.
---@field SetLayerOrigin fun(layer:integer, x:number, y:number) Set the transform origin of a layer; layer scaling and rotation are applied relative to this origin
---@field SetLayerRotation fun(layer:integer, rotationRad:number) Set a rotation applied to the layer as a whole, relative to the layer's transform origin
---@field SetLayerScale fun(layer:integer, widthScale:number, hightScale:number) Set a scale factor applied to the layer as a whole, relative to the layer's transform origin.
---@field SetLayerTranslation fun(layer:integer, tx:number, ty:number) Set a translation applied to the layer as a whole
---@field SetNextFillColor fun(layer:integer, red:number, green:number, blue:number, alpha:number) Set the fill color of the next rendered shape on the given layer; has no effect on shapes that do not support a fill color
---@field SetNextRotation fun(layer:integer, rotationRad:number) Set the rotation of the next rendered shape on the given layer; has no effect on shapes that do not support rotation, in radians; positive is counter-clockwise, negative is clockwise
---@field SetNextRotationDegrees fun(layer:integer, rotationDeg:number) Set the rotation of the next rendered shape on the given layer; has no effect on shapes that do not support rotation, in degrees; positive is counter-clockwise, negative is clockwise
---@field SetNextShadow fun(layer:integer, radius, red:number, green:number, blue:number, alpha:number) Set the shadow of the next rendered shape on the given layer; has no effect on shapes that do not support a shadow
---@field SetNextStrokeColor fun(layer:integer, red:number, green:number, blue:number, alpha:number) Set the stroke color of the next rendered shape on the given layer; has no effect on shapes that do not support a stroke color
---@field SetNextStrokeWidth fun(layer:integer, strokeWidth:integer) Set the stroke width of the next rendered shape on the given layer; has no effect on shapes that do not support a stroke width
---@field SetNextTextAlign fun(layer:integer, hor:RSAlignHor, ver:RSAlignVer) Set the text alignment of the next rendered text string on the given layer. By default, text is anchored horizontally on the left, and vertically on the baseline.
---@field SetOutput fun(output:string) Set the script's output string, which can be retrieved via a programming board with the screen unit API function getScriptOutput
local RenderScript = {}
RenderScript.__index = _ENV

---@type Render
local singelton


---Gets the RenderScript instance
---@return Render
function RenderScript.Instance()
    if singelton then
        return singelton
    end

    local loadedImages = {} ---@type table<string, integer>

    --- RenderScript functions are all in the global namespace so bind to them.
    singelton = {
        AddBezier = _ENV.addBezier,
        AddBox = _ENV.addBox,
        AddBoxRounded = _ENV.addBoxRounded,
        AddCircle = _ENV.addCircle,
        AddImage = _ENV.addImage,
        AddImageSub = _ENV.addImageSub,
        AddLine = _ENV.addLine,
        AddQuad = _ENV.addQuad,
        AddText = _ENV.addText,
        AddTriangle = _ENV.addTriangle,
        CreateLayer = _ENV.createLayer,
        GetAvailableFontCount = _ENV.getAvailableFontCount,
        GetAvailableFontName = _ENV.getAvailableFontName,
        GetCursor = _ENV.getCursor,
        GetCursorDown = _ENV.getCursorDown,
        GetCursorPressed = _ENV.getCursorPressed,
        GetCursorReleased = _ENV.getCursorReleased,
        GetDeltaTime = _ENV.getDeltaTime,
        GetFontMetrics = _ENV.getFontMetrics,
        GetFontSize = _ENV.getFontSize,
        GetImageSize = _ENV.getImageSize,
        GetInput = _ENV.getInput,
        GetLocale = _ENV.getLocale,
        GetRenderCost = _ENV.getRenderCost,
        GetRenderCostMax = _ENV.getRenderCostMax,
        GetResolution = _ENV.getResolution,
        ---@param font LoadedFont
        ---@param text string
        ---@return Vec2
        GetTextBounds = function(font, text)
            return Vec2.New(_ENV.getTextBounds(font.GetID(), text or ""))
        end,
        GetTime = _ENV.getTime,
        IsImageLoaded = _ENV.isImageLoaded,
        ---@param url string
        LoadImage = function(url)
            local existing = loadedImages[url]
            if existing then
                return existing
            else
                local id = _ENV.loadImage(url)
                loadedImages[url] = id
                return id
            end
        end,
        LoadFont = _ENV.loadFont,
        Log = _ENV.logMessage,
        ---@param frames integer
        RequestAnimationFrame = function(frames)
            _ENV.requestAnimationFrame(frames)
            loadedImages = {} -- images needs to be reloaded each frame
        end,
        SetBackgroundColor = _ENV.setBackgroundColor,
        SetDefaultFillColor = _ENV.setDefaultFillColor,
        SetDefaultRotation = _ENV.setDefaultRotation,
        SetDefaultShadow = _ENV.setDefaultShadow,
        SetDefaultStrokeColor = _ENV.setDefaultStrokeColor,
        SetDefaultStrokeWidth = _ENV.setDefaultStrokeWidth,
        SetDefaultTextAlign = _ENV.setDefaultTextAlign,
        SetFontSize = _ENV.setFontSize,
        SetLayerClipRect = _ENV.setLayerClipRect,
        SetLayerOrigin = _ENV.setLayerOrigin,
        SetLayerRotation = _ENV.setLayerRotation,
        SetLayerScale = _ENV.setLayerScale,
        SetLayerTranslation = _ENV.setLayerTranslation,
        SetNextFillColor = _ENV.setNextFillColor,
        SetNextRotation = _ENV.setNextRotation,
        SetNextRotationDegrees = _ENV.setNextRotationDegrees,
        SetNextShadow = _ENV.setNextShadow,
        SetNextStrokeColor = _ENV.setNextStrokeColor,
        SetNextStrokeWidth = _ENV.setNextStrokeWidth,
        SetNextTextAlign = _ENV.setNextTextAlign,
        SetOutput = _ENV.setOutput
    }

    setmetatable(singelton, RenderScript)
    return singelton
end

return RenderScript

end)()
_REQ['YFS:../e/render/src/BindPath.lua']=(function()
local Color      = _REQ['YFS:../e/render/src/native/Color.lua']
local Vec2       = _REQ['YFS:../e/render/src/native/Vec2.lua']
local getTime    = _REQ['YFS:../e/render/src/native/RenderScript.lua'].Instance().GetTime
---@module "BinderModifier"

---@class BindPath
---@field New fun(parts:string[]):BindPath
---@field Boolean fun(o:table, propertyName:string, valueName:string, interval?:number)
---@field Text fun(o:table, propertyName:string, valueName:string, format?:string, interval?:number, modifier?:fun(t:string):string)
---@field Number fun(o:table, propertyName:string, valueName:string, format?:string, interval?:number, modifier?:BinderModifier|SimpleModifier)
---@field Color fun(o:table, propertyName:string, valueName:string, interval?:number, modifier?:fun(c:Color):Color)
---@field Vec2 fun(o:table, propertyName:string, valueName:string, interval?:number, modifier?:BinderModifier|SimpleModifier)
---@field ProcessNumber fun(propertyName:string, value:number)
---@field ProcessVec2 fun(propertyName:string, value:Vec2)
---@field ProcessText fun(propertyName:string, value:string)
---@field ProcessColor fun(propertyName:string, value:string)
---@field ProcessBoolean fun(valueName:string, value:boolean)

---@alias genericModifier fun(any):any
---@alias BoundText {obj:table, propertyName:string, valueName:string, updateInterval:number, format:string, modifier:genericModifier, lastUpdate:number}
---@alias BoundNumber {obj:table, propertyName:string, valueName:string, updateInterval:number, format:string, modifier:BinderModifier, lastUpdate:number}
---@alias BoundBoolean {obj:table, propertyName:string, valueName:string, updateInterval:number, lastUpdate:number}

local BindPath   = {}
BindPath.__index = BindPath

local function noop(v)
    return v
end

---Creates a new BindPath
---@param updateInterval number
---@return BindPath
function BindPath.New(updateInterval)
    local s = {}
    local boundText = {} ---@type BoundText[]
    local boundNumber = {} ---@type BoundNumber[]
    local boundColor = {} ---@type BoundText[]
    local boundVec2 = {} ---@type BoundText[]
    local boundBoolean = {} ---@type BoundBoolean[]

    ---Binds a boolean property
    ---@param obj table
    ---@param propertyName string
    ---@param valueName string
    ---@param interval? number
    function s.Boolean(obj, propertyName, valueName, interval)
        table.insert(boundBoolean, {
            obj = obj,
            propertyName = propertyName,
            valueName = valueName,
            lastUpdate = 0,
            updateInterval = interval or updateInterval
        })
    end

    ---Binds a text property
    ---@param obj table
    ---@param propertyName string
    ---@param valueName string
    ---@param format? string
    ---@param interval? number
    ---@param modifier? fun(t:string):string
    function s.Text(obj, propertyName, valueName, format, interval, modifier)
        table.insert(boundText, {
            obj = obj,
            propertyName = propertyName,
            valueName = valueName,
            format = format or "%s",
            lastUpdate = 0,
            updateInterval = interval or updateInterval,
            modifier = modifier or noop
        })
    end

    ---Binds a number property
    ---@param obj table
    ---@param propertyName string
    ---@param valueName string
    ---@param format string|nil If provided, this is used to format the resulting value into a string instead of a number.
    ---@param interval? number
    ---@param modifier? BinderModifier
    function s.Number(obj, propertyName, valueName, format, interval, modifier)
        table.insert(boundNumber, {
            obj = obj,
            propertyName = propertyName,
            valueName = valueName,
            format = format,
            lastUpdate = 0,
            updateInterval = interval or updateInterval,
            modifier = modifier or noop
        })
    end

    ---Binds a number property
    ---@param obj table
    ---@param propertyName string
    ---@param valueName string
    ---@param interval? number
    ---@param modifier? fun(t:string):string
    function s.Color(obj, propertyName, valueName, interval, modifier)
        table.insert(boundColor, {
            obj = obj,
            propertyName = propertyName,
            valueName = valueName,
            lastUpdate = 0,
            updateInterval = interval or updateInterval,
            modifier = modifier or noop
        })
    end

    ---Binds a Vec2 property
    ---@param obj table
    ---@param propertyName string
    ---@param valueName string
    ---@param interval? number
    ---@param modifier? BinderModifier
    function s.Vec2(obj, propertyName, valueName, interval, modifier)
        table.insert(boundVec2, {
            obj = obj,
            propertyName = propertyName,
            valueName = valueName,
            lastUpdate = 0,
            updateInterval = interval or updateInterval,
            modifier = modifier or noop
        })
    end

    function s.ProcessNumber(valueName, value)
        local now = getTime()
        for _, bind in ipairs(boundNumber) do
            if bind.valueName == valueName and now - bind.lastUpdate >= bind.updateInterval then
                local modified = bind.modifier(value)
                if bind.format then
                    -- When providing a format it turns the resulting value into a string instead of a number.
                    modified = string.format(bind.format, modified)
                end
                bind.obj[bind.propertyName] = modified
            end
        end
    end

    ---@param valueName string
    ---@param value Vec2
    function s.ProcessVec2(valueName, value)
        local now = getTime()

        for _, bind in ipairs(boundVec2) do
            if bind.valueName == valueName and now - bind.lastUpdate >= bind.updateInterval then
                bind.obj[bind.propertyName] = bind.modifier(value)
                bind.lastUpdate = now
            end
        end
    end

    ---@param valueName string
    ---@param value boolean
    function s.ProcessBoolean(valueName, value)
        local now = getTime()
        for _, bind in ipairs(boundBoolean) do
            if bind.valueName == valueName and now - bind.lastUpdate >= bind.updateInterval then
                bind.obj[bind.propertyName] = value
                bind.lastUpdate = now
            end
        end
    end

    ---@param valueName string
    ---@param value string
    function s.ProcessText(valueName, value)
        local now = getTime()
        for _, bind in ipairs(boundText) do
            if bind.valueName == valueName and now - bind.lastUpdate >= bind.updateInterval then
                bind.obj[bind.propertyName] = string.format(bind.format, tostring(bind.modifier(value)))
                bind.lastUpdate = now
            end
        end

        local c = Color.FromString(value)
        if c then
            for _, bind in ipairs(boundColor) do
                if bind.valueName == valueName and now - bind.lastUpdate >= bind.updateInterval then
                    bind.obj[bind.propertyName] = bind.modifier(c)
                    bind.lastUpdate = now
                end
            end
        end

        local v = Vec2.FromString(value)
        if v then
            s.ProcessVec2(valueName, v)
        end
    end

    return setmetatable(s, BindPath)
end

return BindPath

end)()
_REQ['YFS:../e/render/src/BindPathTree.lua']=(function()
---@module "BindPath"

---@class BindPathTree
---@field New fun(name:string):BindPathTree
---@field Sub table<string,BindPathTree>
---@field Bind BindPath[]

local BindPathTree = {}
BindPathTree.__index = BindPathTree

---@return BindPathTree
function BindPathTree.New()
    local s = {
        Sub = {}, ---@type table<string,BindPathTree>
        Bind = {} ---@type BindPath[]
    }

    return setmetatable(s, BindPathTree)
end

return BindPathTree

end)()
_REQ['YFS:../e/render/src/BinderModifier.lua']=(function()
---@alias SimpleModifier fun(any):any

---@class BinderModifier
---@field isMul boolean
---@field isDiv boolean
---@field percentVal number|Vec2
---@field initVal number|Vec2

local BinderModifier = {}
BinderModifier.__index = {}

---@param isMul boolean
---@param isDiv boolean
---@param percentVal number|Vec2
---@param initVal number|Vec2
function BinderModifier.New(isMul, isDiv, percentVal, initVal)
    local s = {
        isMul = isMul,
        isDiv = isDiv,
        percentVal = percentVal,
        initVal = initVal
    }

    return setmetatable(s, BinderModifier)
end

---@param self BinderModifier
---@param mod number|Vec2
---@return number|Vec2
function BinderModifier.__call(self, mod)
    local s = self
    if s.isMul then
        return s.initVal * mod
    elseif s.isDiv then
        return s.initVal / mod
    elseif s.percentVal then
        -- When v is 1, return shall be percentVal
        return s.initVal + (s.percentVal - s.initVal) * mod
    end

    return mod
end

return BinderModifier

end)()
_REQ['YFS:../e/render/src/Binder.lua']=(function()
local BindPath = _REQ['YFS:../e/render/src/BindPath.lua']
local BindPathTree = _REQ['YFS:../e/render/src/BindPathTree.lua']
local BinderModifier = _REQ['YFS:../e/render/src/BinderModifier.lua']
local rs = _REQ['YFS:../e/render/src/native/RenderScript.lua'].Instance()
local Vec2 = _REQ['YFS:../e/render/src/native/Vec2.lua']

---@class Binder
---@field New fun():Binder
---@field Path fun(path:string, updateInterval?:number):BindPath
---@field MergeData fun(data:table)
---@field Render fun()
---@field Clear fun()
---@field CreateBinding fun(bindExpression:string, targetObject:table, targetProperty:string):boolean
---@field private getByPath fun(sourceObject:table, path:string):any|nil
---@field InitPat string
---@field PercentPat string

local Binder = {}
Binder.__index = {}
local DEFAULT_UPDATE_INTERVAL = 0.5

Binder.InitPat = "init{(.-)}"
Binder.PercentPat = "percent{(.-)}"

---Creates a new Binder
---@return Binder
function Binder.New()
    local s = {}
    local tree = BindPathTree.New()
    local binderData = {}

    ---Creates a BindPath
    ---@param path string The json-path in the data to the object holding the data to bind to, such as "a/b" or just "" for the root object, Only a-z, A-Z, 0-9 and _ are allowed.
    ---@return BindPath
    function s.Path(path)
        -- Build a tree for the paths
        local curr = tree
        for nodeName in string.gmatch(path, "[a-zA-Z0-9_]+") do
            if not curr.Sub[nodeName] then
                curr.Sub[nodeName] = BindPathTree.New()
            end
            curr = curr.Sub[nodeName]
        end

        local p = BindPath.New(DEFAULT_UPDATE_INTERVAL)
        curr.Bind[#curr.Bind + 1] = p
        return p
    end

    ---@param data table
    ---@param branch BindPathTree
    local function apply(data, branch)
        -- Iterate each key in the data
        for key, value in pairs(data) do
            local t = type(value)
            if Vec2.IsVec2(value) then
                for _, bind in ipairs(branch.Bind) do
                    bind.ProcessVec2(key, Vec2.New(value))
                end
            elseif t == "table" then
                -- If there is a matching entry in the BindPath tree, go into that
                local p = branch.Sub[key]
                if p then
                    apply(value, p)
                end
            elseif t == "number" then
                for _, bind in ipairs(branch.Bind) do
                    bind.ProcessNumber(key, value)
                end
            elseif t == "string" then
                -- Multi-values, such as Vec2 are handled by this too.
                for _, bind in ipairs(branch.Bind) do
                    bind.ProcessText(key, value)
                end
            elseif t == "boolean" then
                for _, bind in ipairs(branch.Bind) do
                    bind.ProcessBoolean(key, value)
                end
            end
        end
    end

    local function merge(target, source)
        for sourceKey, sourceValue in pairs(source) do
            local t = type(sourceValue)
            if t ~= "function" then
                if t == "table" then
                    if not target[sourceKey] then
                        target[sourceKey] = {}
                    end

                    merge(target[sourceKey], sourceValue)
                else
                    target[sourceKey] = sourceValue
                end
            end
        end
    end

    ---Merges the given data with the data previously provided
    ---@param data table
    function s.MergeData(data)
        if not data then return end
        merge(binderData, data)
    end

    ---Sets the data, discarding any previously merged data.
    ---@param data table
    function s.SetData(data)
        binderData = data or {}
    end

    ---Renders the data
    function s.Render()
        apply(binderData, tree)
    end

    function s.Clear()
        tree = BindPathTree.New()
        binderData = {}
    end

    local stringPat = "$str%((.-)%)"
    local numPat = "$num%((.-)%)"
    local vec2Pat = "$vec2%((.-)%)"
    local boolPat = "$bool%((.-)%)"
    local pathPat = "path{([^%s:{}]-):([^%s:{}]-)}"
    local formatPat = "format{([%s%S]-)}"
    local intervalPat = "interval{(%d*%.?%d+)}"
    local opMul = "op{mul}"
    local opDiv = "op{div}"

    ---@param targetObject table
    ---@param targetProperty string
    ---@param format string|nil
    ---@param initVal any
    local function applyInitValue(targetObject, targetProperty, format, initVal)
        if format then
            targetObject[targetProperty] = string.format(format, initVal)
        else
            targetObject[targetProperty] = initVal
        end
    end

    ---@param str string
    ---@return string
    local function trim(str)
        return str and str:match('^%s*(.*%S)') or ""
    end

    ---@param str string
    local function toBoolean(str)
        str = trim(str)
        return str == "true" or str == "1"
    end

    ---Attempts to create bindings from the expression(s) into the target object
    ---@param bindExpression string The binding expression(s), separated by "|"
    ---@param targetObject table Object to set properties on
    ---@param targetProperty string Name of property of target object
    ---@return boolean
    function s.CreateBinding(bindExpression, targetObject, targetProperty)
        if not (bindExpression and targetObject and targetProperty) then return false end

        local isString = bindExpression:match(stringPat) ~= nil
        local isNum = not isString and bindExpression:match(numPat) ~= nil
        local isVec2 = not isNum and bindExpression:match(vec2Pat) ~= nil
        local isBool = not isVec2 and bindExpression:match(boolPat) ~= nil

        if not (isString or isNum or isVec2 or isBool) then
            return false
        end

        local format = bindExpression:match(formatPat)
        local interval = tonumber(bindExpression:match(intervalPat)) or DEFAULT_UPDATE_INTERVAL
        local init = bindExpression:match(Binder.InitPat)

        if not init then
            rs.Log("'init' missing in expression " .. bindExpression)
            return false
        end

        local path, key = bindExpression:match(pathPat)
        path = path or "" -- If left out, binds to the root path
        if not (path and key) then
            rs.Log("'path' or 'key' missing in expression " .. bindExpression)
            return false
        end

        local isMul = bindExpression:match(opMul) ~= nil
        local isDiv = bindExpression:match(opDiv) ~= nil
        local precent = bindExpression:match(Binder.PercentPat)

        if isVec2 then
            local initVal = Vec2.FromString(init)
            if not initVal then
                rs.Log("Invalid init value '" .. init .. "' for Vec2 in expression" .. bindExpression)
                return false
            end

            local precentVal
            if precent then
                precentVal = Vec2.FromString(precent)
                if not precentVal then
                    rs.Log("Invalid percent value '" .. precent .. "' for Vec2 in expression " .. bindExpression)
                    return false
                end
            end

            -- Vec2 doesn't support format strings
            targetObject[targetProperty] = initVal

            local p = s.Path(path)
            p.Vec2(targetObject, targetProperty, key, interval, BinderModifier.New(isMul, isDiv, precentVal, initVal))
        elseif isString then
            local p = s.Path(path)
            applyInitValue(targetObject, targetProperty, format, init)
            p.Text(targetObject, targetProperty, key, format or "%s", interval)
        elseif isBool then
            local p = s.Path(path)
            applyInitValue(targetObject, targetProperty, nil, toBoolean(init))
            p.Boolean(targetObject, targetProperty, key, interval)
        elseif isNum then
            local initVal = tonumber(init)
            if not initVal then
                rs.Log("Initial value '" .. init .. "' not a number in expression " .. bindExpression)
                return false
            end

            local precentVal
            if precent then
                precentVal = tonumber(precent)
                if not precentVal then
                    rs.Log("Percent value '" .. precent .. "' not a number in expression " .. bindExpression)
                    return false
                end
            end

            applyInitValue(targetObject, targetProperty, format, initVal)

            local p = s.Path(path)
            p.Number(targetObject, targetProperty, key, format, interval,
                BinderModifier.New(isMul, isDiv, precentVal, initVal))
        end

        return true
    end

    return setmetatable(s, Binder)
end

---Gets a value at the given path, if the entire path exists, or nil.
---The last part of the path is returned
---@param sourceObject table
---@param path string
---@param desiredType type
---@return number|table|string|nil
function Binder.getByPath(sourceObject, path, desiredType)
    local parts = {}

    for nodeName in string.gmatch(path, "[a-zA-Z_]+") do
        parts[#parts + 1] = nodeName
    end

    if #parts == 0 or not sourceObject then return nil end

    local curr = sourceObject

    while #parts > 0 do
        local p = table.remove(parts, 1)
        if type(curr) == "table" and curr[p] then
            curr = curr[p]
        else
            return nil
        end
    end

    if type(curr) ~= desiredType then return nil end

    return curr
end

---Gets a number by path
---@param sourceObject table
---@param path string Path to get value from in the form a/b/c, where c would be the value to get
---@return number|nil
function Binder.GetNumByPath(sourceObject, path)
    local r = Binder.getByPath(sourceObject, path, "number")
    ---@cast r number|nil
    return r
end

---Gets a string by path
---@param sourceObject table
---@param path string Path to get value from in the form a/b/c, where c would be the value to get
---@return string|nil
function Binder.GetStrByPath(sourceObject, path)
    local r = Binder.getByPath(sourceObject, path, "string")
    ---@cast r string|nil
    return r
end

---Gets a table by path
---@param sourceObject table
---@param path string Path to get value from in the form a/b/c, where c would be the value to get
---@return table|nil
function Binder.GetTblByPath(sourceObject, path)
    local r = Binder.getByPath(sourceObject, path, "table")
    ---@cast r table|nil
    return r
end

---Splits a string based on a pattern
---@param str string String to split
---@param separator string Pattern
---@return string[]
function Binder.Split(str, separator)
    local sep, fields = separator or ":", {}
    local pattern = string.format("([^%s]+)", sep)
    _ = str:gsub(pattern, function(c) fields[#fields + 1] = c end)
    return fields
end

return Binder

end)()
_REQ['YFS:../e/render/src/native/LoadedFont.lua']=(function()
local rs = _REQ['YFS:../e/render/src/native/RenderScript.lua'].Instance()
---@alias FontHandle integer

---@class LoadedFont
---@field public New fun():LoadedFont
---@field public GetID fun():FontHandle
---@field public Reset fun()

local LoadedFont = {}
LoadedFont.__index = LoadedFont

---Creates a new LoadedFont
---@param name string
---@param size integer
---@return LoadedFont
function LoadedFont.New(name, size)
    local s = {
        id = rs.LoadFont(name, size)
    }

    function s.GetID()
        if not s.id then
            s.id = rs.LoadFont(name, size)
        end

        return s.id
    end

    function s.Reset()
        s.id = nil
    end

    return setmetatable(s, LoadedFont)
end

return LoadedFont

end)()
_REQ['YFS:../e/render/src/native/Font.lua']=(function()
local rs = _REQ['YFS:../e/render/src/native/RenderScript.lua'].Instance()
local LoadedFont = _REQ['YFS:../e/render/src/native/LoadedFont.lua']


---@enum FontName
FontName = {
    FiraMono                = "FiraMono",
    FiraMonoBold            = "FiraMono-Bold",
    Montserrat              = "Montserrat",
    MontserratLight         = "Montserrat-Light",
    MontserratBold          = "Montserrat-Bold",
    Play                    = "Play",
    PlayBold                = "Play-Bold ",
    RefrigeratorDeluxe      = "RefrigeratorDeluxe",
    RefrigeratorDeluxeLight = "RefrigeratorDeluxe-Light",
    RobotoCondensed         = "RobotoCondensed",
    RobotoMono              = "RobotoMono",
    RobotoMonoBold          = "RobotoMono-Bold",
}

---@class Font
---@field Get fun(name:string, size:integer):LoadedFont
---@field Clear fun()

local Font = {}
Font.__index = Font

local loaded = {} ---@type table<string, LoadedFont>

---Gets the requested font
---@param name FontName
---@param size integer
---@return LoadedFont
function Font.Get(name, size)
    local nameAndSize = string.format("%s%0.3f", name, size)

    local exists = loaded[nameAndSize]
    if not exists then
        loaded[nameAndSize] = LoadedFont.New(name, size)
    end

    return loaded[nameAndSize]
end

---Clears fonts, call this at the end of the screen render.
function Font.Clear()
    for _, value in pairs(loaded) do
        value.Reset()
    end
end

return Font

end)()
_REQ['YFS:../e/render/src/native/ColorAndDistance.lua']=(function()
local Color = _REQ['YFS:../e/render/src/native/Color.lua']

---@class ColorAndDistance
---@field Color Color The color
---@field Distance number The distance
---@field Clone fun():ColorAndDistance
---@field New fun(color:Color, distance:number):ColorAndDistance
---@field None fun():ColorAndDistance

local ColorAndDistance = {}
ColorAndDistance.__index = ColorAndDistance

---Creates a new Shadow
---@param color Color
---@param distance number
function ColorAndDistance.New(color, distance)
    local s = {
        Color = color,
        Distance = distance
    }

    ---Clones the ColorAndDistance
    ---@return ColorAndDistance
    function s.Clone()
        return ColorAndDistance.New(s.Color.Clone(), s.Distance)
    end

    return setmetatable(s, ColorAndDistance)
end

---@return ColorAndDistance
function ColorAndDistance.None()
    return ColorAndDistance.New(Color.Transparent(), 0)
end

return ColorAndDistance

end)()
_REQ['YFS:../e/render/src/native/TextAlign.lua']=(function()
---@enum RSAlignHor
RSAlignHor = {
    Left = 0,
    Center = 1,
    Right = 2,
}

---@enum RSAlignVer
RSAlignVer = {
    Ascender = 0,
    Top = 1,
    Middle = 2,
    Baseline = 3,
    Bottom = 4,
    Descender = 5,
}


---@class TextAlign
---@field Hor RSAlignHor
---@field Ver RSAlignVer
---@field Default fun():TextAlign
---@field Clone fun():Text
---@field ToString fun():string

local TextAlign = {}
TextAlign.__index = TextAlign

---Creates a new Shadow
---@param horizontal RSAlignHor
---@param vertical RSAlignVer
function TextAlign.New(horizontal, vertical)
    local s = {
        Hor = horizontal,
        Ver = vertical
    }

    ---Clones the TextAlign
    ---@return TextAlign
    function s.Clone()
        return TextAlign.New(s.Hor, s.Ver)
    end

    function s.ToString()
        return string.format("h%d,v%d", s.Hor, s.Ver)
    end

    ---ToString meta function
    ---@param a TextAlign
    ---@return string
    function TextAlign.__tostring(a)
        return a.ToString()
    end

    return setmetatable(s, TextAlign)
end

---Creates a default text alignment
---@return TextAlign
function TextAlign.Default()
    return TextAlign.New(RSAlignHor.Left, RSAlignVer.Top)
end

---Creates a text align from the string
---@param s string
function TextAlign.FromString(s)
    if not s then return TextAlign.Default() end
    local h, v = s:match("^h%s*(%d)%s*,%s*v%s*(%d)%s*$")
    h = tonumber(h)
    v = tonumber(v)

    if h and v then
        return TextAlign.New(h, v)
    end

    return TextAlign.Default()
end

---@param a TextAlign
---@param b TextAlign
---@return unknown
function TextAlign.__eq(a, b)
    return a.Hor == b.Hor and a.Ver == b.Ver
end

return TextAlign

end)()
_REQ['YFS:../e/render/src/native/Props.lua']=(function()
local Color = _REQ['YFS:../e/render/src/native/Color.lua']
local ColorAndDistance = _REQ['YFS:../e/render/src/native/ColorAndDistance.lua']
local TextAlign = _REQ['YFS:../e/render/src/native/TextAlign.lua']
local rs = _REQ['YFS:../e/render/src/native/RenderScript.lua'].Instance()

---@alias PropsTableStruct {fill:string, rotation:number, shadow: {color:string, distance:number}, stroke:{color:string, distance:number}, align:string}

---@class Props
---@field Fill Color The fill color
---@field Rotation number The rotation, in degrees
---@field Shadow ColorAndDistance The shadow
---@field Stroke ColorAndDistance The stroke color for shapes
---@field Align TextAlign The text alignment for text strings
---@field Apply fun(layer:integer) Applies the properties to the layer
---@field ApplyDefault fun(layer:integer, shape:RSShape) Applies the properties as defaults to the layer
---@field Clone fun():Props
---@field Load fun(input:PropsTableStruct):Props Loads a Props from a table
---@field Persist fun():PropsTableStruct
---@field Show fun()
---@field Hide fun()

local Props = {}
Props.__index = Props

---Creates a new properties container
---@param color? Color
---@param rotation? number
---@param shadow? ColorAndDistance
---@param stroke? ColorAndDistance
---@param align? TextAlign
---@return Props
function Props.New(color, rotation, shadow, stroke, align)

    local s = {
        Fill = color or Color.Transparent(),
        Rotation = rotation or 0,
        Shadow = shadow or ColorAndDistance.New(Color.Transparent(), 0),
        Stroke = stroke or ColorAndDistance.New(Color.Transparent(), 0),
        Align = align or TextAlign.Default(),
    }

    ---Applies the propertries to the layer
    ---@param layer integer
    function s.Apply(layer)
        rs.SetNextFillColor(layer, s.Fill:Unpack())
        rs.SetNextRotationDegrees(layer, s.Rotation)
        rs.SetNextShadow(layer, s.Shadow.Distance, s.Shadow.Color:Unpack())
        rs.SetNextStrokeColor(layer, s.Stroke.Color:Unpack())
        rs.SetNextStrokeWidth(layer, s.Stroke.Distance)
        rs.SetNextTextAlign(layer, s.Align.Hor, s.Align.Ver)
    end

    ---Applies the propertries as defaults to the layer
    ---@param layer integer
    ---@param shape RSShape
    function s.ApplyDefault(layer, shape)
        rs.SetDefaultFillColor(layer, shape, s.Fill:Unpack())
        rs.SetDefaultRotation(layer, shape, s.Rotation)
        rs.SetDefaultShadow(layer, shape, s.Shadow.Distance, s.Shadow.Color:Unpack())
        rs.SetDefaultStrokeColor(layer, shape, s.Stroke.Color:Unpack())
        rs.SetDefaultStrokeWidth(layer, shape, s.Stroke.Distance)
        rs.SetDefaultTextAlign(layer, s.Align.Hor, s.Align.Ver)
    end

    ---Deeply clones a Props
    function s.Clone()
        return Props.New(s.Fill.Clone(), s.Rotation, s.Shadow.Clone(), s.Stroke.Clone(), s.TextAlign.Clone())
    end

    ---Creates a table with data ready to persist
    ---@return PropsTableStruct
    function s.Persist()
        local t = {
            fill = s.Fill.ToString(),
            align = s.Align.ToString(),
            rotation = s.Rotation,
            shadow = { color = s.Shadow.Color.ToString(), distance = s.Shadow.Distance },
            stroke = { color = s.Stroke.Color.ToString(), distance = s.Stroke.Distance }
        }

        return t
    end

    return setmetatable(s, Props)
end

---Creates a default Props
---@return Props
function Props.Default()
    return Props.New(Color.New(1, 1, 1))
end

---Loads a Props from the table (all lower case keys)
---@param input PropsTableStruct
---@return Props
function Props.Load(input)
    -- Load the different parts that makes up a Props and return a new one.
    local color = Color.FromString(input.fill) or Color.Transparent()
    local rotation = input.rotation or 0
    local shadowColor, shadowDist
    if input.shadow then
        shadowColor = Color.FromString(input.shadow.color)
        shadowDist = input.shadow.distance
    end

    local shadow
    if shadowColor and shadowDist then
        shadow = ColorAndDistance.New(shadowColor, shadowDist)
    else
        shadow = ColorAndDistance.New(Color.Transparent(), 0)
    end

    local strokeColor, strokeDist
    if input.stroke then
        strokeColor = Color.FromString(input.stroke.color)
        strokeDist = input.stroke.distance
    end

    local stroke
    if strokeColor and strokeDist then
        stroke = ColorAndDistance.New(strokeColor, strokeDist)
    else
        stroke = ColorAndDistance.New(Color.Transparent(), 0)
    end

    local align = TextAlign.FromString(input.align)

    return Props.New(color, rotation, shadow, stroke, align)
end

return Props

end)()
_REQ['YFS:../e/render/e/stream/e/serializer.lua']=(function()
local concat = table.concat
local sFormat=string.format

local function internalSerialize(table, tC, t)
    t[tC] = "{"
    tC = tC + 1
    if #table == 0 then
        local hasValue = false
        for key, value in pairs(table) do
            hasValue = true
            local keyType = type(key)
            if keyType == "string" then
                t[tC] = sFormat("[%q]=", key)
            elseif keyType == "number" then
                t[tC] = "[" .. key .. "]="
            elseif keyType == "boolean" then
                t[tC] = "[" .. tostring(key) .. "]="
            else
                t[tC] = "notsupported="
            end
            tC = tC + 1

            local check = type(value)
            if check == "table" then
                tC = internalSerialize(value, tC, t)
            elseif check == "string" then
                t[tC] = sFormat("%q", value)
            elseif check == "number" then
                t[tC] = value
            elseif check == "boolean" then
                t[tC] = tostring(value)
            else
                t[tC] = '"Not Supported"'
            end
            t[tC + 1] = ","
            tC = tC + 2
        end
        if hasValue then
            tC = tC - 1
        end
    else
        for i = 1, #table do
            local value = table[i]
            local check = type(value)
            if check == "table" then
                tC = internalSerialize(value, tC, t)
            elseif check == "string" then
                t[tC] = sFormat("%q", value)
            elseif check == "number" then
                t[tC] = value
            elseif check == "boolean" then
                t[tC] = tostring(value)
            else
                t[tC] = '"Not Supported"'
            end
            t[tC + 1] = ","
            tC = tC + 2
        end
        tC = tC - 1
    end
    t[tC] = "}"
    return tC
end

function serialize(value)
    local t = {}
    local check = type(value)

    if check == "table" then
        internalSerialize(value, 1, t)
    elseif check == "string" then
        return sFormat("%q", value)
    elseif check == "number" then
        return value
    elseif check == "boolean" then
        return tostring(value)
    else
        return '"Not Supported"'
    end

    return concat(t)
end

function deserialize(s)
    return load("return " .. s)()
end


end)()
_REQ['YFS:../e/render/e/stream/src/Stream.lua']=(function()
local _ = _REQ['YFS:../e/render/e/stream/e/serializer.lua']
local byte = string.byte
local concat = table.concat

---@module "interface.Device"

---@alias CommQueue { queue:string[], waitingForReply:boolean, seq:integer }
---@alias ScreenLink {setScriptInput:fun(string), clearScriptOutput:fun(), getScriptOutput:fun():string}
---@alias Renderer {setOutput:fun(string), getInput:fun():string}

---@class Stream
---@field New fun(device:Device, parent:DataReceiver, timeout:number):Stream
---@field Tick fun()
---@field Write fun(data:table|string)
---@field WaitingToSend fun():boolean

--[[
    Data format:
    #new_message|checksum|remaining_chunks|seq|cmd|payload

    Where:
    - new_message is 0 or 1 where 0 means continuation of a message, and 1 means a new message.
    - checksum is HEX representation of the XOR checksum of the data
    - remaining_chunks is an integer indicating how many chunks remains to complete the message. 0 means the last chuck.
    - seq is a single digit seqence number, used to ensure we don't read the same data twice. It wraps around at 9.
    - cmd is a two digit integer indicating what to do with the data
    - payload is the actual payload, if any
]]
local HEADER_SIZE = 1 -- #
    + 1               -- new_message
    + 1               -- |
    + 2               -- checksum
    + 1               -- |
    + 3               -- remaining_chucks
    + 1               -- |
    + 1               -- seq
    + 1               -- |
    + 2               -- cmd
    + 1               -- |

local BLOCK_HEADER_FORMAT = "#%0.1d|%0.2x|%0.3d|%0.1d|%0.2d|%s"
local BLOCK_HEADER_PATTERN = "^#(%d)|(%x%x)|(%d+)|(%d)|(%d+)|(.*)$"

---@enum StreamCommand
local Command = {
    Reset = 0,
    Poll = 1,
    Ack = 2,
    Data = 3,
}

---Represents a stream between two entities.
local Stream = {}
Stream.__index = Stream

---Create a new Stream
---@param device Device
---@param parent DataReceiver
---@param timeout number The amount of time to wait for a reply before considering the connection broken.
---@return Stream
function Stream.New(device, parent, timeout)
    local s = {}
    local DATA_SIZE = device.BlockSize() - HEADER_SIZE -- Game allows only a certain amount of bytes in buffers

    ---@diagnostic disable-next-line: undefined-global
    local getTime = getTime or system.getUtcTime

    device.Clear()

    local input = { queue = {}, waitingForReply = false, seq = -1, payloadChecksum = 0 }
    local output = { queue = {}, waitingForReply = false, seq = 0 }
    local lastReceived = getTime()

    ---@param data string
    ---@return string # Two character HEX value
    local function xor(data)
        local x = 0
        for i = 1, data:len() do
            x = x ~ byte(data, i)
        end

        return x
    end

    ---Assembles the package
    ---@param payload string
    local function assemblePackage(payload)
        input.queue[#input.queue + 1] = payload
    end

    ---Completes a transmission
    ---@param remaining number
    local function completeTransmission(remaining)
        if remaining == 0 then
            local complete = concat(input.queue)

            if xor(complete) == input.payloadChecksum then
                local deserialized = deserialize(complete)
                parent.OnData(deserialized)
            end

            -- Last part, begin new data
            input.queue = {}
        end
    end

    local function sameInput(seq)
        if seq == input.seq then
            return true
        end

        input.seq = seq
        return false
    end

    ---Creates a block
    ---@param newMessage boolean
    ---@param blockCount integer
    ---@param commQueue CommQueue
    ---@param cmd StreamCommand
    ---@param payload string?
    ---@return string
    local function createBlock(newMessage, blockCount, commQueue, cmd, payload, checksum)
        checksum = checksum or 0

        commQueue.seq = (commQueue.seq + 1)
        if commQueue.seq > 9 then
            commQueue.seq = 0
        end

        payload = payload or ""
        local b = string.format(BLOCK_HEADER_FORMAT, (newMessage and 1 or 0), checksum, blockCount, commQueue.seq, cmd,
            payload)

        return b
    end

    ---Reads incoming data
    ---@return boolean #New message
    ---@return StreamCommand|nil #Command
    ---@return number #Packet chunks remaning
    ---@return string #Payload
    ---@return integer #Checksum
    local function readData()
        local r = device.Read()

        local new, checksum, remaining, seq, cmd, payload = r:match(BLOCK_HEADER_PATTERN)

        payload = payload or ""
        local validPacket = remaining and cmd and new and checksum
        if validPacket then
            cmd = tonumber(cmd)
            new = tonumber(new)
            remaining = tonumber(remaining)
            checksum = tonumber("0x" .. checksum)
            validPacket = cmd and remaining and new and checksum
        end

        if not validPacket then
            return true, nil, 0, "", 0
        end

        -- Since we can't clear the input when running in RenderScript, we have to rely on the sequence number to prevent duplicate data.
        if sameInput(seq) then
            return true, nil, 0, "", 0
        end

        return new == 1, cmd, remaining, payload, checksum
    end

    local function resetQueues()
        output.queue = {}
        output.waitingForReply = false
        input.queue = {}
        input.waitingForReply = false
    end

    ---Call this function once every frame (i.e. in Update)
    function s.Tick()
        local new, cmd, remaining, payload, checksum = readData()

        -- Did we get any input?
        if cmd then
            if new then
                input.payloadChecksum = checksum
            end

            parent.OnTimeout(false, s)
            lastReceived = getTime()

            if new then
                input.queue = {}
            end

            if device.IsController() then
                if cmd == Command.Data then
                    assemblePackage(payload)
                    completeTransmission(remaining)
                end
                -- No need to handle ACK, it's just a trigger to move on.
                output.waitingForReply = false
            else
                local sendAck = false

                if cmd == Command.Poll or cmd == Command.Data then
                    if cmd == Command.Data then
                        assemblePackage(payload)
                        completeTransmission(remaining)
                    end

                    -- Send either ACK or actual data as a reply
                    if #output.queue > 0 then
                        device.Send(table.remove(output.queue, 1))
                    else
                        sendAck = true
                    end
                elseif cmd == Command.Reset then
                    resetQueues()
                    sendAck = true
                end

                if sendAck then
                    device.Send(createBlock(true, 0, output, Command.Ack))
                end
            end
        end

        if getTime() - lastReceived >= timeout then
            parent.OnTimeout(true, s)
            input.payloadChecksum = 0
            lastReceived = getTime() -- Reset to trigger again
            resetQueues()
        end

        if device.IsController() and not output.waitingForReply then
            if #output.queue == 0 then
                device.Send(createBlock(true, 0, output, Command.Poll))
            else
                device.Send(table.remove(output.queue, 1))
            end
            output.waitingForReply = true
        end
    end

    ---Write the data to the stream
    ---@param dataToSend table|string
    function s.Write(dataToSend)
        local data = serialize(dataToSend) ---@type string
        local checksum = xor(data)
        local blockCount = math.ceil(data:len() / DATA_SIZE)

        if blockCount > 999 then
            error("Too large data")
        end

        local new = true

        while data:len() > 0 do
            blockCount = blockCount - 1
            local part = data:sub(1, DATA_SIZE)
            data = data:sub(DATA_SIZE + 1)
            output.queue[#output.queue + 1] = createBlock(new, blockCount, output, Command.Data, part, checksum)
            new = false
            checksum = 0
        end
    end

    ---Returns true if there is data waiting to be sent. Good for holding off additional write.
    ---@return boolean
    function s.WaitingToSend() return #output.queue > 0 end

    setmetatable(s, Stream)

    parent.RegisterStream(s)

    return s
end

return Stream

end)()
_REQ['YFS:../e/render/src/DeepCopy.lua']=(function()
-- http://lua-users.org/wiki/CopyTable
-- It is important that only one argument is supplied to this version of the deepcopy function.
-- Otherwise, it will attempt to use the second argument as a table, which can have unintended consequences.
local function deepcopy(orig, copies)
    copies = copies or {}
    local orig_type = type(orig)
    local copy
    if orig_type == 'table' then
        if copies[orig] then
            copy = copies[orig]
        else
            copy = {}
            copies[orig] = copy
            for orig_key, orig_value in next, orig, nil do
                copy[deepcopy(orig_key, copies)] = deepcopy(orig_value, copies)
            end
            setmetatable(copy, deepcopy(getmetatable(orig), copies))
        end
    else -- number, string, boolean, etc
        copy = orig
    end
    return copy
end

---Deeply copies the provided table
---@generic T
---@param o T
---@return T
function DeepCopy(o)
    return deepcopy(o)
end

return DeepCopy

end)()
_REQ['YFS:../e/render/src/Layout.lua']=(function()
local Font             = _REQ['YFS:../e/render/src/native/Font.lua']
local Props            = _REQ['YFS:../e/render/src/native/Props.lua']
local Vec2             = _REQ['YFS:../e/render/src/native/Vec2.lua']
local rs               = _REQ['YFS:../e/render/src/native/RenderScript.lua'].Instance()
local Color            = _REQ['YFS:../e/render/src/native/Color.lua']
local Binder           = _REQ['YFS:../e/render/src/Binder.lua']
local ColorAndDistance = _REQ['YFS:../e/render/src/native/ColorAndDistance.lua']
local DeepCopy         = _REQ['YFS:../e/render/src/DeepCopy.lua']

---@module "Stream"

-- These are Lua structures for the layout
---@alias Style PropsTableStruct
---@alias NamedFonts table<string, {font:string, size:FontHandle}>
---@alias NamedStyles table<string,Style>
---@alias ReplicateStruct {x_step:number, y_step:number, x_count:integer, y_count:number, column_mode:boolean}
---@alias StringOrBool string|boolean
---@alias BaseCompStruct {type:string, layer:integer, hitable:StringOrBool, replicate:ReplicateStruct}
---@alias MouseStruct { click: { command:string }, inside: { set_style:string }}
---@alias PageStruct {components:BaseCompStruct[]}
---@alias NamedPagesStruct table<string,PageStruct>
---@alias LayoutStruct { fonts:NamedFonts, styles:table<string,Props>, pages:table<string, PageStruct> }

---@alias BoxStruct {pos1:string, pos2:string, corner_radius:number, style:string, mouse:MouseStruct, type:string, layer:integer, visible:StringOrBool, hitable:StringOrBool, replicate:ReplicateStruct}
---@alias TextStruct {pos1:string, style:string, font:string, text:string, mouse:MouseStruct, type:string, layer:integer, visible:StringOrBool, hitable:StringOrBool, replicate:ReplicateStruct}
---@alias LineStruct {pos1:string, pos2:string, style:string, mouse:MouseStruct, mouse:MouseStruct, type:string, layer:integer, visible:StringOrBool, hitable:StringOrBool, replicate:ReplicateStruct}
---@alias CircleStruct {pos1:string, radius:number, style:string, mouse:MouseStruct, mouse:MouseStruct, type:string, layer:integer, visible:StringOrBool, hitable:StringOrBool, replicate:ReplicateStruct}
---@alias ImageStruct {pos1:string, dimensions:string, sub:string, subDimensions:string, url:string, mouse:MouseStruct, type:string, layer:integer, visible:StringOrBool, hitable:StringOrBool, replicate:ReplicateStruct}

---@alias Page Layer[]
---@alias Pages table<string,Page>

---@class Layout
---@field SetLayout fun(layout:LayoutStruct):boolean
---@field Styles fun():table<string,Props>
---@field Fonts fun():table<string,FontHandle>
---@field Activate fun(page:string):boolean

local Layout           = {}
Layout.__index         = Layout

---@param screen Screen
---@param behaviour Behaviour
---@param binder Binder
---@param stream Stream
---@return Layout
function Layout.New(screen, behaviour, binder, stream)
    local s = {}

    local fonts = {} ---@type table<string,LoadedFont>
    local styles = {} ---@type table<string,Props>
    local layoutData = {} ---@type LayoutStruct
    -- Use a crimson color for missing styles
    local crimson = Color.New(0.862745098, 0.078431373, 0.235294118)
    local missingStyle = Props.New(crimson, 0, ColorAndDistance.New(Color.Transparent(), 0),
        ColorAndDistance.New(crimson, 1))
    local missingFont = Font.Get(FontName.RobotoMono, 10)
    local activatePagePat = "activatepage{%s*(.-)%s*}"

    ---Loads fonts
    ---@param fontData NamedFonts
    local function loadFonts(fontData)
        if not fontData then return false end
        for name, data in pairs(fontData) do
            fonts[name] = Font.Get(data.font, data.size)
        end

        return true
    end

    ---@param namedStyles NamedStyles
    ---@return boolean
    local function loadStyles(namedStyles)
        if not namedStyles then return false end
        for name, value in pairs(namedStyles) do
            styles[name] = Props.Load(value)
        end

        return true
    end

    ---@param pos string
    ---@param object Box|Line|Text|Circle|Image
    ---@param prop string
    ---@param componentType string
    ---@return boolean
    local function bindPos(pos, object, prop, componentType)
        if not binder.CreateBinding(pos, object, prop) then
            local p = Vec2.FromString(pos)
            if p then
                object[prop] = p
            else
                rs.Log("Invalid value for Vec2 for " .. prop .. " in " .. componentType .. " '" .. tostring(pos) .. "'")
                return false
            end
        end
        return true
    end

    ---Binds mouse actions
    ---@param object Text|Box|Line|Circle|Image
    ---@param data BoxStruct|TextStruct|LineStruct|CircleStruct|ImageStruct
    local function bindStyles(object, data)
        local bindData = {
            ---@type string
            style = "",
            ---@type string|nil
            insideStyle = nil,
            ---@type string|nil
            clickCommand = nil
        }

        local style = Binder.GetStrByPath(data, "style") or "-"
        if not binder.CreateBinding(style, bindData, "style") then
            -- Assume style is just a style name
            bindData.style = style
        end

        local insideStyle = Binder.GetStrByPath(data, "mouse/inside/set_style")
        if insideStyle then
            if not binder.CreateBinding(insideStyle, bindData, "insideStyle") then
                -- Assume style is just a name
                bindData.insideStyle = insideStyle
            end
        end

        behaviour.OnMouseInsideOrOutside(object, function(element, event)
            if event == MouseState.MouseInside and bindData.insideStyle then
                object.Props = styles[bindData.insideStyle] or missingStyle
            else
                object.Props = styles[bindData.style] or missingStyle
            end
        end)
    end

    ---Binds mouse actions
    ---@param object Text|Box|Line|Circle|Image
    ---@param data BoxStruct|TextStruct|LineStruct|CircleStruct|ImageStruct
    local function bindClick(object, data)
        local bindData = {
            ---@type string|nil
            clickCommand = nil
        }

        local cmd = Binder.GetStrByPath(data, "mouse/click/command")

        if cmd then
            if not binder.CreateBinding(cmd, bindData, "clickCommand") then
                bindData.clickCommand = cmd
            end

            behaviour.OnMouseClick(object, function(element, event)
                local c = bindData.clickCommand
                if c ~= nil and string.len(c) > 0 then
                    local page = c:match(activatePagePat)
                    if page then
                        s.Activate(page)
                    else
                        stream.Write({ mouse_click = c })
                    end
                end
            end)
        end
    end

    ---@param object Text|Box|Line|Circle|Image
    ---@param data BoxStruct|TextStruct|LineStruct|CircleStruct|ImageStruct
    local function bindVisibility(object, data)
        local t = type(data.visible)
        if t == "boolean" then
            local b = data.visible
            ---@cast b boolean
            object.Visible = b
        elseif t == "string" then
            local b = data.visible
            ---@cast b string
            if not binder.CreateBinding(b, object, "Visible") then
                return false
            end
        elseif t ~= "nil" then
            rs.Log("Invalid data type for visibility binding: " .. t)
            return false
        end
        return true
    end

    ---@param object Text|Box|Line|Circle|Image
    ---@param data BoxStruct|TextStruct|LineStruct|CircleStruct|ImageStruct
    local function bindHitable(object, data)
        local t = type(data.hitable)
        if t == "boolean" then
            local b = data.hitable
            ---@cast b boolean
            object.Hitable = b
        elseif t == "string" then
            local b = data.hitable
            ---@cast b string
            if not binder.CreateBinding(b, object, "Hitable") then
                return false
            end
        elseif t ~= "nil" then
            rs.Log("Invalid data type for hitable binding: " .. t)
            return false
        end
        return true
    end

    ---@param object Text|Box|Line|Circle|Image
    ---@param data BoxStruct|TextStruct|LineStruct|CircleStruct|ImageStruct
    local function applyBindings(object, data)
        bindStyles(object, data)
        bindClick(object, data)
        bindVisibility(object, data)
        bindHitable(object, data)
    end

    ---@param layer Layer
    ---@param data BoxStruct
    ---@return Box|nil
    local function createBox(layer, data)
        local corner = Binder.GetNumByPath(data, "corner_radius") or 0

        local box = layer.Box(Vec2.New(), Vec2.New(), corner)

        if not (bindPos(data.pos1, box, "Pos1", "box")
                and bindPos(data.pos2, box, "Pos2", "box")) then
            return nil
        end

        applyBindings(box, data)

        return box
    end

    ---@param layer Layer
    ---@param data TextStruct
    ---@return Text|nil
    local function createText(layer, data)
        local fontName = Binder.GetStrByPath(data, "font") or "-"
        local textFont = fonts[fontName] or missingFont

        local text = layer.Text("", Vec2.New(), textFont)

        if not bindPos(data.pos1, text, "Pos1", "text") then
            return nil
        end

        if not binder.CreateBinding(data.text, text, "Text") then
            text.Text = data.text
        end

        applyBindings(text, data)

        return text
    end

    ---@param layer Layer
    ---@param data LineStruct
    ---@return Line|nil
    local function createLine(layer, data)
        local line = layer.Line(Vec2.New(), Vec2.New())

        if not (bindPos(data.pos1, line, "Pos1", "line")
                and bindPos(data.pos2, line, "Pos2", "line")) then
            return nil
        end

        applyBindings(line, data)

        return line
    end

    ---@param layer Layer
    ---@param data CircleStruct
    ---@return Circle|nil
    local function createCircle(layer, data)
        local radius = Binder.GetNumByPath(data, "radius") or 50

        local circle = layer.Circle(Vec2.New(), radius)

        if not bindPos(data.pos1, circle, "Pos1", "circle") then
            return nil
        end

        applyBindings(circle, data)
        return circle
    end

    ---@param layer Layer
    ---@param data ImageStruct
    ---@return Image|nil
    local function createImage(layer, data)
        local url = Binder.GetStrByPath(data, "url")

        local image = layer.Image(url or "", Vec2.zero, Vec2.zero)

        if not (bindPos(data.pos1, image, "Pos", "image") and
                bindPos(data.dimensions or tostring(Vec2.zero), image, "Dimensions", "image")) then
            return nil
        end

        if data.sub and data.subDimensions then
            if not (bindPos(data.sub, image, "Sub", "image") and bindPos(data.subDimensions, image, "SubDimensions", "image")) then
                return nil
            end
        end

        applyBindings(image, data)
        return image
    end

    ---@param comp BaseCompStruct
    ---@return boolean
    local function createComponent(comp)
        local res = nil ---@type Box|Circle|Line|Image|Text|nil
        local layer = comp.layer
        local t = tostring(comp.type)

        if type(layer) == "number" then
            local l = screen.Layer(layer)
            if t == "box" then
                ---@cast comp BoxStruct
                res = createBox(l, comp)
            elseif t == "text" then
                ---@cast comp TextStruct
                res = createText(l, comp)
            elseif t == "line" then
                ---@cast comp LineStruct
                res = createLine(l, comp)
            elseif t == "circle" then
                ---@cast comp CircleStruct
                res = createCircle(l, comp)
            elseif t == "image" then
                ---@cast comp ImageStruct
                res = createImage(l, comp)
            end
        else
            rs.Log("Invalid layer number '" .. tostring(layer) .. "', type " .. t)
        end

        if res == nil then
            rs.Log("Could not create component for type " .. t)
        end

        return res ~= nil
    end

    ---@param c table
    ---@param count integer
    local function replaceReplicationCount(c, count)
        for key, value in pairs(c) do
            ---@cast key string
            if type(value) == "table" then
                replaceReplicationCount(value, count)
            elseif type(value) == "string" then
                ---@cast value string
                c[key] = value:gsub("%[%#%]", tostring(count))
            end
        end
    end

    ---@param comp table
    ---@param addX number
    ---@param addY number
    ---@param count integer
    local function applyReplication(comp, addX, addY, count)
        local i = 1

        ---@param v Vec2
        ---@return string
        local function addToVec(v)
            return (v + Vec2.New(addX, addY)):ToString()
        end

        while true do
            local name = string.format("pos%d", i)
            i = i + 1

            ---@type string|nil
            local val = comp[name]
            if not val then
                break
            end

            local p = Vec2.FromString(val)

            if p then
                comp[name] = addToVec(p)
            else
                local init = val:match(Binder.InitPat)
                if init then
                    p = Vec2.FromString(init)
                    if p then
                        val = val:gsub("init{%(.-%)}", "init{" .. addToVec(p) .. "}")
                    end
                end

                local percent = val:match(Binder.PercentPat)
                if percent then
                    p = Vec2.FromString(percent)
                    if p then
                        val = val:gsub("percent{%(.-%)}", "percent{" .. addToVec(p) .. "}")
                    end
                end

                comp[name] = val
            end
        end

        replaceReplicationCount(comp, count)
    end

    ---Loads the page
    ---@param page PageStruct
    ---@return boolean
    local function loadPage(page)
        if not page.components then
            rs.Log("No components in page")
            return false
        end

        local res = true
        for _, comp in pairs(page.components) do
            local rep = comp.replicate or {}

            rep.x_count = rep.x_count or 1
            rep.y_count = rep.y_count or 1
            rep.x_step = rep.x_step or 0
            rep.y_step = rep.y_step or 0

            local addX = 0
            local addY = 0

            ---@param count number
            ---@return number
            local xInc = function(count)
                local x = addX

                if rep.x_step > 0 then
                    if rep.column_mode then
                        if count % rep.y_count == 0 then
                            addX = addX + rep.x_step
                        end
                    else
                        if count % rep.x_count == 0 then
                            addX = 0
                        else
                            addX = addX + rep.x_step
                        end
                    end
                end

                return x
            end

            ---@param count number
            ---@return number
            local yInx = function(count)
                local y = addY

                if rep.y_step > 0 then
                    if rep.column_mode then
                        if count % rep.y_count == 0 then
                            addY = 0
                        else
                            addY = addY + rep.y_step
                        end
                    else
                        if count % rep.x_count == 0 then
                            addY = addY + rep.y_step
                        end
                    end
                end

                return y
            end

            for i = 1, rep.x_count * rep.y_count do
                local copy = DeepCopy(comp)
                applyReplication(copy, xInc(i), yInx(i), i)
                res = createComponent(copy)
                if not res then break end
            end

            if not res then return res end
        end

        return true
    end

    ---Sets the layout and loads fonts and styles
    ---@param layout LayoutStruct
    ---@return boolean
    function s.SetLayout(layout)
        layoutData = layout
        return loadFonts(layoutData.fonts) and loadStyles(layoutData.styles)
    end

    ---Loads controls and data bindings
    ---@param pageNames string The page name to activate. Comma separated list of pages to be shown at the same time
    ---@return boolean
    function s.Activate(pageNames)
        screen.Clear()
        behaviour.Clear()
        binder.Clear()

        local pages = layoutData.pages

        if pages then
            for _, name in ipairs(Binder.Split(pageNames, ",")) do
                local p = pages[name]

                if not p or not loadPage(p) then
                    rs.Log("Could not load page by name '" .. name .. "'")
                    return false
                end
            end
        else
            rs.Log("No pages in layout")
        end

        return true
    end

    ---Gets the syles
    ---@return table<string, Props>
    function s.Styles()
        return styles
    end

    ---Gets the fonts
    ---@return table<string, LoadedFont>
    function s.Fonts()
        return fonts
    end

    return setmetatable(s, Layout)
end

return Layout

end)()
_REQ['YFS:../e/render/e/stream/src/device/RenderScriptDevice.lua']=(function()
---@class RenderScriptDevice
---@field Send fun(data:string)
---@field Read fun():string
---@field Clear fun()
---@field IsController fun():boolean
---@field BlockSize fun():integer
---@field New fun(screenLink:table):Device

local RenderScriptDevice = {}
RenderScriptDevice.__index = RenderScriptDevice

---Creates a new screen device
---@return Device
function RenderScriptDevice.New()
    local s = {}

    function s.Send(data)
        ---@diagnostic disable-next-line: undefined-global
        setOutput(data)
    end

    ---@return string
    function s.Read()
        ---@diagnostic disable-next-line: undefined-global
        return getInput()
    end

    function s.Clear()

    end

    ---@return boolean
    function s.IsController()
        return false
    end

    function s.BlockSize()
        return 1024
    end

    return setmetatable(s, RenderScriptDevice)
end

return RenderScriptDevice

end)()
_REQ['YFS:../e/render/src/native/Text.lua']=(function()
local rs = _REQ['YFS:../e/render/src/native/RenderScript.lua'].Instance()
local abs = math.abs
local Vec2 = _REQ['YFS:../e/render/src/native/Vec2.lua']

---@module "Color"
---@module "Font"

---@class Text
---@field Text string
---@field Pos1 Vec2
---@field Font FontHandle
---@field Layer Layer
---@field Props Props
---@field Bounds fun():number, number
---@field Width fun():number
---@field Height fun():number
---@field Visible boolean
---@field Hitable boolean
---@field GetHitBoxOffset fun():Vec2
---@field Render fun()
---@field Hit fun(point:Vec2):boolean

local Text = {}
Text.__index = Text

---Creates a new Text
---@param text string
---@param pos Vec2
---@param layer Layer
---@param font LoadedFont
---@param props Props
---@return Text
function Text.New(text, pos, layer, font, props)
    local s = {
        Text = text or "",
        Pos1 = pos,
        Font = font,
        Props = props,
        Layer = layer,
        Visible = true,
        Hitable = true
    }

    ---Returns the width and height, in pixels the text occupies.
    ---@return Vec2
    function s.Bounds()
        return rs.GetTextBounds(s.Font, s.Text)
    end

    ---Width of text
    ---@return number
    function s.Width()
        return s.Bounds().x
    end

    ---Width of text
    ---@return number
    function s.Height()
        return s.Bounds().y
    end

    ---Renders the text
    function s.Render()
        local layerId = s.Layer.Id
        s.Props.Apply(layerId)
        rs.AddText(layerId, s.Font.GetID(), s.Text, s.Pos1:Unpack())
    end

    ---Gets the hitbox offset, as adjusted by the text alignment.
    ---@return Vec2
    function s.GetHitBoxOffset()
        local fontId = s.Font.GetID()
        local ascender, descender = rs.GetFontMetrics(fontId)
        local height = rs.GetFontSize(fontId)
        local horAlign = s.Props.Align.Hor
        local verAlign = s.Props.Align.Ver

        local xOffset = 0
        if horAlign == RSAlignHor.Center then
            xOffset = -s.Bounds().x / 2
        elseif horAlign == RSAlignHor.Right then
            xOffset = -s.Bounds().x
        end

        local yOffset = 0
        if verAlign == RSAlignVer.Ascender then
            yOffset = height - ascender
        elseif verAlign == RSAlignVer.Top then
            yOffset = 0
        elseif verAlign == RSAlignVer.Middle then
            yOffset = -s.Bounds().y / 2
        elseif verAlign == RSAlignVer.Baseline then
            yOffset = -ascender
        elseif verAlign == RSAlignVer.Bottom then
            yOffset = -height + descender
        elseif verAlign == RSAlignVer.Descender then
            yOffset = -height + descender
        end

        return Vec2.New(xOffset, yOffset)
    end

    --Determines if the position is within the element
    ---@param point Vec2
    ---@return boolean
    function s.Hit(point)
        -- Alignment affects the position of the string so we must take care of that here.
        local upperLeft = s.Pos1 + s.GetHitBoxOffset()
        local lowerRight = upperLeft + s.Bounds()

        return s.Hitable and s.Visible
            and point.x >= upperLeft.x and point.x <= lowerRight.x
            and point.y >= upperLeft.y and point.y <= lowerRight.y
    end

    return setmetatable(s, Text)
end

return Text

end)()
_REQ['YFS:../e/render/src/native/Image.lua']=(function()
local rs = _REQ['YFS:../e/render/src/native/RenderScript.lua'].Instance()
local Vec2 = _REQ['YFS:../e/render/src/native/Vec2.lua']

---@module "Props"

---@alias ImageHandle integer

---@class Image
---@field Id ImageHandle
---@field Pos Vec2
---@field Dimensions Vec2
---@field Sub Vec2
---@field SubDimensions Vec2
---@field Props Props
---@field FillScreen fun()
---@field IsLoaded fun():boolean
---@field Bounds fun():Vec2
---@field Width fun():number
---@field Height fun():number
---@field Render fun()
---@field Hit fun(point:Vec2):boolean
---@field Visible boolean
---@field Hitable boolean

local Image = {}
Image.__index = Image

---Creates a new Image
---@param url string
---@param pos Vec2
---@param dimensions Vec2
---@param layer Layer
---@param props Props
---@param sub? Vec2
---@param subDimensions? Vec2
---@return Image
function Image.New(url, pos, dimensions, layer, props, sub, subDimensions)
    local s = {
        Pos = pos,
        Dimensions = dimensions,
        Sub = sub,
        SubDimensions = subDimensions,
        Props = props,
        Layer = layer,
        Visible = true,
        Hitable = true
    }

    ---Returns true if the image is loaded
    ---@return boolean
    function s.IsLoaded()
        return rs.IsImageLoaded(s.Id)
    end

    ---Width of image
    ---@return number
    function s.Width()
        return s.Dimensions.x
    end

    ---Width of image
    ---@return number
    function s.Height()
        return s.Dimensions.y
    end

    function s.FillScreen()
        s.Pos = Vec2.New()
        s.Dimensions = Vec2.New(rs.GetResolution())
    end

    ---Renders the text
    function s.Render()
        local id = rs.LoadImage(url)
        local loaded = rs.IsImageLoaded(id)

        if loaded and s.Dimensions == Vec2.zero then
            -- Set default size if not already set
            s.Dimensions = Vec2.New(rs.GetImageSize(id))
        end

        local layerId = s.Layer.Id
        s.Props.Apply(layerId)
        if s.Sub and s.SubDimensions then
            rs.AddImageSub(s.Layer.Id, id, s.Pos.x, s.Pos.y, s.Dimensions.x, s.Dimensions.y, s.Sub.x, s.Sub.y,
                s.SubDimensions.x, s.SubDimensions.y)
        else
            rs.AddImage(s.Layer.Id, id, s.Pos.x, s.Pos.y, s.Dimensions.x, s.Dimensions.y)
        end
    end

    --Determines if the position is within the element
    ---@param point Vec2
    ---@return boolean
    function s.Hit(point)
        local max = s.Pos + s.Dimensions
        return s.Hitable and s.Visible and point.x >= s.Pos.x and point.x <= max.x
            and point.y >= s.Pos.y and point.y <= max.y
    end

    return setmetatable(s, Image)
end

return Image

end)()
_REQ['YFS:../e/render/src/native/Box.lua']=(function()
local rs = _REQ['YFS:../e/render/src/native/RenderScript.lua'].Instance()

---@class Box
---@field Pos1 Vec2
---@field Pos2 Vec2
---@field Props Props
---@field Visible boolean
---@field Hitable boolean
---@field Render fun()
---@field Hit fun(point:Vec2):boolean

local Box = {}
Box.__index = Box

---Creates a new Box
---@param layer Layer
---@param pos1 Vec2
---@param pos2 Vec2
---@param cornerRadius number
---@param props Props
function Box.New(layer, pos1, pos2, cornerRadius, props)
    local s = {
        Layer = layer,
        Pos1 = pos1,
        Pos2 = pos2,
        CornerRadius = cornerRadius,
        Props = props,
        Visible = true,
        Hitable = true
    }

    function s.Render()
        local layerId = s.Layer.Id
        s.Props.Apply(layerId)

        -- The RenderScript API wants positon and width/hight
        local dimensions = s.Pos2 - s.Pos1

        local r = s.CornerRadius
        if r and r > 0 then
            rs.AddBoxRounded(layerId, s.Pos1.x, s.Pos1.y, dimensions.x, dimensions.y, r)
        else
            rs.AddBox(layerId, s.Pos1.x, s.Pos1.y, dimensions.x, dimensions.y)
        end
    end

    --Determines if the position is within the element
    ---@param point Vec2
    ---@return boolean
    function s.Hit(point)
        local min = s.Pos1
        local max = s.Pos2
        return s.Hitable and s.Visible
            and point.x >= min.x and point.x <= max.x
            and point.y >= min.y and point.y <= max.y
    end

    return setmetatable(s, Box)
end

return Box

end)()
_REQ['YFS:../e/render/src/native/Bezier.lua']=(function()
local rs = _REQ['YFS:../e/render/src/native/RenderScript.lua'].Instance()

---@class Bezier
---@field Pos1 Vec2
---@field Pos2 Vec2
---@field Pos3 Vec2
---@field Props Props
---@field Visible Props
---@field Render fun()

local Bezier = {}
Bezier.__index = Bezier

---Creates a new Bezier
---@param layer Layer
---@param a Vec2
---@param b Vec2
---@param c Vec2
---@param props Props
function Bezier.New(layer, a, b, c, props)
    local s = {
        Layer = layer,
        Pos1 = a,
        Pos2 = b,
        Pos3 = c,
        Props = props,
        Visible = true
    }

    function s.Render()
        local layerId = s.Layer.Id
        s.Props.Apply(layerId)
        local x1, y1 = s.Pos1:Unpack()
        local x2, y2 = s.Pos2:Unpack()
        local x3, y3 = s.Pos3:Unpack()
        rs.AddBezier(layerId, x1, y1, x2, y2, x3, y3)
    end

    return setmetatable(s, Bezier)
end

return Bezier

end)()
_REQ['YFS:../e/render/src/native/Circle.lua']=(function()
local rs = _REQ['YFS:../e/render/src/native/RenderScript.lua'].Instance()

---@class Circle
---@field Pos1 Vec2
---@field Radius number
---@field Props Props
---@field Visible boolean
---@field Hitable boolean
---@field Render fun()
---@field Hit fun(point:Vec2):boolean

local Circle = {}
Circle.__index = Circle

---Creates a new Circle
---@param layer Layer
---@param pos Vec2
---@param radius number
---@param props Props
function Circle.New(layer, pos, radius, props)
    local s = {
        Layer = layer,
        Pos1 = pos,
        Radius = radius,
        Props = props,
        Visible = true,
        Hitable = true
    }

    function s.Render()
        local layerId = s.Layer.Id
        s.Props.Apply(layerId)
        local x, y = s.Pos1:Unpack()
        rs.AddCircle(layerId, x, y, s.Radius)
    end

    ---Determines if the position is within the element
    ---@param point Vec2
    ---@return boolean
    function s.Hit(point)
        return s.Hitable and s.Visible and (s.Pos1 - point):Len() <= s.Radius
    end

    return setmetatable(s, Circle)
end

return Circle

end)()
_REQ['YFS:../e/render/src/native/Line.lua']=(function()
local rs = _REQ['YFS:../e/render/src/native/RenderScript.lua'].Instance()

---@class Line
---@field Pos1 Vec2
---@field Pos2 Vec2
---@field Props Props
---@field Visible boolean
---@field Render fun()

local Line = {}
Line.__index = Line

---Creates a new Line
---@param layer Layer
---@param a Vec2
---@param b Vec2
---@param props Props
function Line.New(layer, a, b, props)
    local s = {
        Layer = layer,
        Pos1 = a,
        Pos2 = b,
        Props = props,
        Visible = true
    }

    function s.Render()
        local layerId = s.Layer.Id
        s.Props.Apply(layerId)
        local x1, y1 = s.Pos1:Unpack()
        local x2, y2 = s.Pos2:Unpack()
        rs.AddLine(layerId, x1, y1, x2, y2)
    end

    return setmetatable(s, Line)
end

return Line

end)()
_REQ['YFS:../e/render/src/native/Triangle.lua']=(function()
local rs = _REQ['YFS:../e/render/src/native/RenderScript.lua'].Instance()

---@class Triangle
---@field Pos1 Vec2
---@field Pos2 Vec2
---@field Pos3 Vec2
---@field Visible boolean
---@field Hitable boolean
---@field Props Props
---@field Render fun()
---@field Hit fun(point:Vec2):boolean

local Triangle = {}
Triangle.__index = Triangle

---Creates a new Triangle
---@param layer Layer
---@param a Vec2
---@param b Vec2
---@param c Vec2
---@param props Props
function Triangle.New(layer, a, b, c, props)
    local s = {
        Layer = layer,
        Pos1 = a,
        Pos2 = b,
        Pos3 = c,
        Props = props,
        Visible = true,
        Hitable = true
    }

    function s.Render()
        local layerId = s.Layer.Id
        s.Props.Apply(layerId)
        local x1, y1 = s.Pos1:Unpack()
        local x2, y2 = s.Pos2:Unpack()
        local x3, y3 = s.Pos3:Unpack()
        rs.AddTriangle(layerId, x1, y1, x2, y2, x3, y3)
    end

    --Determines if the position is within the element
    ---@param point Vec2
    ---@return boolean
    function s.Hit(point)
        -- https://www.youtube.com/watch?v=HYAgJN3x4GA
        local s1 = s.Pos3.y - s.Pos1.y;
        local s2 = s.Pos3.x - s.Pos1.x;
        local s3 = s.Pos2.y - s.Pos1.y;
        local s4 = point.y - s.Pos1.y;

        local w1 = (s.Pos1.x * s1 + s4 * s2 - point.x * s1) / (s3 * s2 - (s.Pos2.x - s.Pos1.x) * s1);
        local w2 = (s4 - w1 * s3) / s1;
        return s.Hitable and s.Visible and w1 >= 0 and w2 >= 0 and (w1 + w2) <= 1;
    end

    return setmetatable(s, Triangle)
end

return Triangle

end)()
_REQ['YFS:../e/render/src/native/Quad.lua']=(function()
local rs = _REQ['YFS:../e/render/src/native/RenderScript.lua'].Instance()

---@class Quad
---@field Pos1 Vec2
---@field Pos2 Vec2
---@field Pos3 Vec2
---@field PosD Vec2
---@field Visible boolean
---@field Props Props
---@field Render fun()

local Quad = {}
Quad.__index = Quad

---Creates a new Quad
---@param layer Layer
---@param a Vec2
---@param b Vec2
---@param c Vec2
---@param d Vec2
---@param props Props
function Quad.New(layer, a, b, c, d, props)
    local s = {
        Layer = layer,
        Pos1 = a,
        Pos2 = b,
        Pos3 = c,
        PosD = d,
        Props = props,
        Visible = true,
        Hitable = true
    }

    function s.Render()
        local layerId = s.Layer.Id
        s.Props.Apply(layerId)
        local x1, y1 = s.Pos1:Unpack()
        local x2, y2 = s.Pos2:Unpack()
        local x3, y3 = s.Pos3:Unpack()
        local x4, y4 = s.PosD:Unpack()
        rs.AddQuad(layerId, x1, y1, x2, y2, x3, y3, x4, y4)
    end

    return setmetatable(s, Quad)
end

return Quad

end)()
_REQ['YFS:../e/render/src/native/Layer.lua']=(function()
---@module "Screen"

local rs = _REQ['YFS:../e/render/src/native/RenderScript.lua'].Instance()
local Vec2 = _REQ['YFS:../e/render/src/native/Vec2.lua']
local Text = _REQ['YFS:../e/render/src/native/Text.lua']
local Image = _REQ['YFS:../e/render/src/native/Image.lua']
local Box = _REQ['YFS:../e/render/src/native/Box.lua']
local Bezier = _REQ['YFS:../e/render/src/native/Bezier.lua']
local Circle = _REQ['YFS:../e/render/src/native/Circle.lua']
local Line = _REQ['YFS:../e/render/src/native/Line.lua']
local Triangle = _REQ['YFS:../e/render/src/native/Triangle.lua']
local Quad = _REQ['YFS:../e/render/src/native/Quad.lua']
local Props = _REQ['YFS:../e/render/src/native/Props.lua']

---@class Layer
---@field New fun():Layer
---@field Id integer
---@field Origin Vec2
---@field Rotation number
---@field Scale Vec2
---@field Text fun(text:string, pos:Vec2, font:LoadedFont, props:Props?):Text
---@field Image fun(url:string, pos:Vec2, dimensions:Vec2, props:Props?):Image
---@field Box fun(pos1:Vec2, pos2:Vec2, cornerRadius:number, props:Props?):Box
---@field Bezier fun(a:Vec2, b:Vec2, c:Vec2, props:Props?):Bezier
---@field Line fun(a:Vec2, b:Vec2, props:Props?):Line
---@field Triangle fun(a:Vec2, b:Vec2, c:Vec2, props:Props?):Triangle
---@field Circle fun(pos:Vec2, radius:number, props:Props?):Circle
---@field Quad fun(a:Vec2, b:Vec2, c:Vec2, d:Vec2, props:Props?):Quad
---@field Render fun()
---@field Clear fun()
---@field DetermineHitElement fun(cursor:Vec2):table
---@field Components BasicComponent[]

local Layer = {}
Layer.__index = Layer

---Create a new layer
---@return Layer
function Layer.New()
    local s = {
        Id = 0, -- Set on render
        Origin = Vec2.New(),
        Rotation = 0,
        Scale = Vec2.New(1, 1),
        ---@type BasicComponent[]
        Components = {},
    }

    ---Create a new text on the layer
    ---@param text string
    ---@param pos Vec2
    ---@param font LoadedFont
    ---@param props Props?
    ---@return Text
    function s.Text(text, pos, font, props)
        local t = Text.New(text, pos, s, font, props or Props.Default())
        table.insert(s.Components, t)
        return t
    end

    ---Adds an image to the layer
    ---@param url string
    ---@param pos Vec2
    ---@param dimensions Vec2
    ---@param props Props?
    ---@return Image
    function s.Image(url, pos, dimensions, props)
        local img = Image.New(url, pos, dimensions, s, props or Props.Default())
        table.insert(s.Components, img)
        return img
    end

    ---Adds a box to the layer
    ---@param pos1 Vec2
    ---@param pos2 Vec2
    ---@param cornerRadius number
    ---@param props Props?
    ---@return Box
    function s.Box(pos1, pos2, cornerRadius, props)
        local b = Box.New(s, pos1, pos2, cornerRadius, props or Props.Default())
        table.insert(s.Components, b)
        return b
    end

    ---Adds a bezier to the layer
    ---@param a Vec2
    ---@param b Vec2
    ---@param c Vec2
    ---@param props Props?
    ---@return Bezier
    function s.Bezier(a, b, c, props)
        local bezier = Bezier.New(s, a, b, c, props or Props.Default())
        table.insert(s.Components, bezier)
        return bezier
    end

    ---Adds a circle to the layer
    ---@param pos Vec2
    ---@param radius number
    ---@param props Props?
    ---@return Circle
    function s.Circle(pos, radius, props)
        local circle = Circle.New(s, pos, radius, props or Props.Default())
        table.insert(s.Components, circle)
        return circle
    end

    ---Adds a line to the layer
    ---@param a Vec2
    ---@param b Vec2
    ---@param props Props?
    ---@return Line
    function s.Line(a, b, props)
        local line = Line.New(s, a, b, props or Props.Default())
        table.insert(s.Components, line)
        return line
    end

    ---Adds a Quad to the layer
    ---@param a Vec2
    ---@param b Vec2
    ---@param c Vec2
    ---@param d Vec2
    ---@param props Props?
    ---@return Quad
    function s.Quad(a, b, c, d, props)
        local quad = Quad.New(s, a, b, c, d, props or Props.Default())
        table.insert(s.Components, quad)
        return quad
    end

    ---Adds a Triangle to the layer
    ---@param a Vec2
    ---@param b Vec2
    ---@param c Vec2
    ---@param props Props?
    ---@return Triangle
    function s.Triangle(a, b, c, props)
        local triangle = Triangle.New(s, a, b, c, props or Props.Default())
        table.insert(s.Components, triangle)
        return triangle
    end

    function s.Render()
        s.Id = rs.CreateLayer() -- Refresh the id on each render
        rs.SetLayerOrigin(s.Id, s.Origin:Unpack())
        rs.SetLayerRotation(s.Id, math.rad(s.Rotation))
        rs.SetLayerScale(s.Id, s.Scale:Unpack())

        for _, comp in ipairs(s.Components) do
            if comp.Visible then
                comp.Render()
            end
        end
    end

    function s.Clear()
        s.Components = {}
    end

    ---Determines which element that is hit
    ---@param cursor Vec2
    ---@return table|nil
    function s.DetermineHitElement(cursor)
        -- Components are drawn bottom up so find the top most one by searching backwards.
        for i = #s.Components, 1, -1 do
            local comp = s.Components[i]
            if type(comp.Hit) == "function" then
                if comp.Hit(cursor) then
                    return comp
                end
            end
        end

        return nil
    end

    return setmetatable(s, Layer)
end

return Layer

end)()
_REQ['YFS:../e/render/src/native/Screen.lua']=(function()
local rs = _REQ['YFS:../e/render/src/native/RenderScript.lua'].Instance()
local Vec2 = _REQ['YFS:../e/render/src/native/Vec2.lua']
local Layer = _REQ['YFS:../e/render/src/native/Layer.lua']
local Font = _REQ['YFS:../e/render/src/native/Font.lua']

---@class Screen Represents a screen
---@field New fun():Screen
---@field Layer fun(id:integer):Layer
---@field Render fun(printStats:boolean)
---@field Animate fun(frames:integer, printStats:boolean)
---@field Bounds fun():Vec2
---@field Stats fun():number
---@field CursorPos fun():Vec2
---@field Pressed fun():boolean
---@field Released fun():boolean
---@field DetermineHitElement fun():table
---@field Clear fun()
---@field CountParts fun(onlyVisible:boolean?):integer, integer
---@field TimeSinceStart fun():number

local Screen = {}
Screen.__index = Screen

---Creates a new Screen
---@return Screen
function Screen.New()
    local s = {}
    local layers = {} ---@type Layer[]

    ---Gets the layer with the given id
    ---@param id integer
    ---@return Layer
    function s.Layer(id)
        while id > #layers do
            table.insert(layers, Layer.New())
        end

        return layers[id]
    end

    ---Returns the width and height, in pixels the text occupies.
    ---@return Vec2
    function s.Bounds()
        return Vec2.New(rs.GetResolution())
    end

    ---Width of screen
    ---@return number
    function s.Width()
        return s.Bounds().x
    end

    ---Height of screen
    ---@return number
    function s.Height()
        return s.Bounds().y
    end

    ---Renders the screen content
    ---@param printStats boolean
    function s.Render(printStats)
        for i = 1, #layers do
            layers[i].Render()
        end

        if printStats then
            local layer
            -- Render on top-most layer
            if #layers == 0 then
                layer = s.Layer(1)
                -- New layer so need to render it to get its id.
                layer.Render()
            else
                layer = layers[#layers]
            end

            local costFont = Font.Get(FontName.Play, 20)
            local cost = string.format("Res: %s, cost: %0.2f%%", s.Bounds():ToString(), s.Stats())
            local textBounds = rs.GetTextBounds(costFont, cost)
            local rWidth = rs.GetTextBounds(costFont, "R").x
            local pos = Vec2.New(rWidth, s.Bounds().y - textBounds.y)
            rs.SetNextFillColor(layer.Id, 1, 1, 1, 1)
            rs.AddText(layer.Id, costFont.GetID(), cost, pos:Unpack())
        end

        Font.Clear()
    end

    function s.Clear()
        for i = 1, #layers do
            layers[i].Clear()
        end
    end

    ---Renders and animates the screen context
    ---@param frames integer
    ---@param printCost boolean
    function s.Animate(frames, printCost)
        s.Render(printCost)
        rs.RequestAnimationFrame(frames)
    end

    ---Gets the render cost in percentage
    ---@return number
    function s.Stats()
        return rs.GetRenderCost() / rs.GetRenderCostMax() * 100
    end

    ---Gets the number of seconds since the screen started
    ---@return number
    function s.TimeSinceStart()
        return rs.GetTime()
    end

    ---Gets the number of seconds between each frame
    ---@return number
    function s.DeltaTime()
        return rs.GetDeltaTime()
    end

    ---Gets the cursor position
    ---@return Vec2
    function s.CursorPos()
        return Vec2.New(rs.GetCursor())
    end

    ---Returns true if the cursor was pressed since the last frame.
    ---@return boolean
    function s.Pressed()
        return rs.GetCursorPressed()
    end

    ---Returns true if the cursor was released since the last frame.
    ---@return boolean
    function s.Released()
        return rs.GetCursorReleased()
    end

    ---Determines which element that is hit
    function s.DetermineHitElement()
        local cursor = Vec2.New(rs.GetCursor())

        -- Top layer first
        for i = #layers, 1, -1 do
            -- Here we can add check on layer clipping
            local hit = layers[i].DetermineHitElement(cursor)
            if hit then
                return hit
            end
        end

        return nil
    end

    function s.CountParts(onlyVisible)
        if onlyVisible == nil then
            onlyVisible = false
        end

        local comps = 0
        for _, layer in ipairs(layers) do
            if onlyVisible then
                for _, comp in ipairs(layer.Components) do
                    if comp.Visible then
                        comps = comps + 1
                    end
                end
            else
                comps = comps + #layer.Components
            end
        end

        return #layers, comps
    end

    return setmetatable(s, Screen)
end

return Screen

end)()
_REQ['YFS:../e/render/src/Behaviour.lua']=(function()
local rs = _REQ['YFS:../e/render/src/native/RenderScript.lua'].Instance()
local Vec2 = _REQ['YFS:../e/render/src/native/Vec2.lua']

---@enum MouseState
MouseState = {
    Click = 1,
    MouseDown = 2,
    MouseUp = 3,
    MouseInside = 4,
    MouseOutside = 5
}

---@alias HitFunc fun(pos:Vec2):boolean
---@alias InteractibleElement {Hit:HitFunc}
---@alias ClickHandler fun(element:InteractibleElement, event:MouseState)
---@alias BooleanMouseContainer {obj:table, handler:ClickHandler}
---@alias MouseHandler fun(element:InteractibleElement, handler:ClickHandler)

---@class Behaviour
---@field New fun():Behaviour
---@field Clear fun()
---@field OnMouseClick MouseHandler
---@field OnMouseDownOrUp MouseHandler
---@field OnMouseInsideOrOutside MouseHandler

local Behaviour = {}
Behaviour.__index = Behaviour

function Behaviour.New()
    local s = {}

    local onMouseClick = {} ---@type BooleanMouseContainer[]
    local onMouseDownOrUp = {} ---@type BooleanMouseContainer[]
    local onMouseInSideorOutside = {} ---@type BooleanMouseContainer[]

    ---Registers the element for mouse click events
    ---@param element InteractibleElement
    ---@param handler ClickHandler
    function s.OnMouseClick(element, handler)
        table.insert(onMouseClick, { obj = element, handler = handler })
    end

    ---Registers the element for mouse down and/or up events
    ---@param element InteractibleElement
    ---@param handler ClickHandler
    function s.OnMouseDownOrUp(element, handler)
        table.insert(onMouseDownOrUp, { obj = element, handler = handler })
    end

    ---Registers the element for mouse inside and/or outside events
    ---@param element InteractibleElement
    ---@param handler ClickHandler
    function s.OnMouseInsideOrOutside(element, handler)
        table.insert(onMouseInSideorOutside, { obj = element, handler = handler })
    end

    ---Triggers events
    ---@param screen Screen
    function s.TriggerEvents(screen)
        local pressed = rs.GetCursorPressed()
        local down = rs.GetCursorDown()

        local hitElement = screen.DetermineHitElement()

        for _, cont in ipairs(onMouseClick) do
            if pressed and hitElement == cont.obj then
                cont.handler(cont.obj, MouseState.Click)
            end
        end

        for _, cont in ipairs(onMouseDownOrUp) do
            if down and hitElement == cont.obj then
                cont.handler(cont.obj, MouseState.MouseDown)
            else
                cont.handler(cont.obj, MouseState.MouseUp)
            end
        end

        for _, cont in ipairs(onMouseInSideorOutside) do
            if hitElement == cont.obj then
                cont.handler(cont.obj, MouseState.MouseInside)
            else
                cont.handler(cont.obj, MouseState.MouseOutside)
            end
        end
    end

    function s.Clear()
        onMouseClick = {}
        onMouseDownOrUp = {}
        onMouseInSideorOutside = {}
    end

    return setmetatable(s, Behaviour)
end

return Behaviour

end)()
_REQ['YFS:../e/render/src/Driver.lua']=(function()
local Binder       = _REQ['YFS:../e/render/src/Binder.lua']
local Font         = _REQ['YFS:../e/render/src/native/Font.lua']
local Props        = _REQ['YFS:../e/render/src/native/Props.lua']
local Color        = _REQ['YFS:../e/render/src/native/Color.lua']
local Stream       = _REQ['YFS:../e/render/e/stream/src/Stream.lua']
local Layout       = _REQ['YFS:../e/render/src/Layout.lua']
local rs           = _REQ['YFS:../e/render/src/native/RenderScript.lua'].Instance()
local RenderDevice = _REQ['YFS:../e/render/e/stream/src/device/RenderScriptDevice.lua']

---@class Driver
---@field Tick fun()
---@field Render fun(frames:integer, displayStats:boolean)
---@field Animate fun(displayStats?:boolean)
---@field SetOfflineLayout fun(layout:table|nil)

local Driver       = {}
Driver.__index     = Driver

function Driver.Instance()
    if _ENV.DriverSingelton then
        return _ENV.DriverSingelton
    end

    local s             = {}
    local offlineLayout = nil ---@type table|nil

    local screen        = _REQ['YFS:../e/render/src/native/Screen.lua'].New()
    local binder        = Binder.New()
    local behavior      = _REQ['YFS:../e/render/src/Behaviour.lua'].New()
    local layout ---@type Layout

    function s.OnData(data)
        local screen_layout = Binder.GetTblByPath(data, "screen_layout")
        local activate_page = Binder.GetStrByPath(data, "activate_page")

        if screen_layout then
            if not layout.SetLayout(screen_layout) then
                rs.Log("Could not load layout")
            end
        elseif activate_page then
            layout.Activate(activate_page)
        else
            binder.MergeData(data)
        end
    end

    function s.OnTimeout(isTimedOut, stream)
        if isTimedOut then
            screen.Clear()
            binder.Clear()
            behavior.Clear()

            if offlineLayout == nil then
                local l = screen.Layer(1)
                local msg = "No communication!"
                local font = Font.Get(FontName.Play, 30)
                local text = l.Text(msg, screen.Bounds() / 2 - (rs.GetTextBounds(font, msg) / 2), font, Props.New())
                text.Props.Fill = Color.New(1, 0, 0)
            elseif not (layout.SetLayout(offlineLayout) and layout.Activate("offline")) then
                rs.Log("Could not load offline layout or activate the page")
            end
        end
    end

    function s.RegisterStream(stream)

    end

    local stream = Stream.New(RenderDevice.New(), s, 1)
    layout       = Layout.New(screen, behavior, binder, stream)

    ---Call this this to setup a slower update than Animate()
    ---@param frames integer
    ---@param displayStats boolean
    function s.Render(frames, displayStats)
        stream.Tick()
        binder.Render()
        behavior.TriggerEvents(screen)
        screen.Animate(frames, displayStats)
    end

    ---Call this to enable animation
    ---@param displayStats? boolean
    function s.Animate(displayStats)
        s.Render(1, displayStats or false)
    end

    ---Sets the layout to use when there is no communication
    ---@param layout table The layout, as Lua table
    function s.SetOfflineLayout(layout)
        offlineLayout = layout
    end

    _ENV.DriverSingelton = setmetatable(s, Driver)
    return s
end

return Driver

end)()

local offline = _REQ['YFS:screen/offline_layout.lua']
local driver = _REQ['YFS:../e/render/src/Driver.lua'].Instance()
driver.SetOfflineLayout(offline)
driver.Render(10, false)
