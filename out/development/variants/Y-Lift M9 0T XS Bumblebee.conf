name: YFS variants/Y-Lift M9 0T XS Bumblebee
slots:
  receiver:
    name: receiver
    class: Receiver
    select: null
    type:
      events: []
      methods: []
  spaceRadar:
    name: spaceRadar
    class: RadarPVPUnit
    select: null
    type:
      events: []
      methods: []
  atmoRadar:
    name: atmoRadar
    class: RadarPVPUnit
    select: null
    type:
      events: []
      methods: []
handlers:
  receiver:
    "onReceived(channel,message)":
      lua: receiver:triggerEvent('onReceived',channel,message)
  spaceRadar:
    onEnter(id):
      lua: spaceRadar:triggerEvent('onEnter',id)
    onLeave(id):
      lua: spaceRadar:triggerEvent('onLeave',id)
    onIdentified(id):
      lua: spaceRadar:triggerEvent('onIdentified',id)
  atmoRadar:
    onEnter(id):
      lua: atmoRadar:triggerEvent('onEnter',id)
    onLeave(id):
      lua: atmoRadar:triggerEvent('onLeave',id)
    onIdentified(id):
      lua: atmoRadar:triggerEvent('onIdentified',id)
  library:
    onStart():
      lua: >-
        ;(function()

        local a={}local b=0;function library.addEventHandlers(c)if not c or c.onEvent and c.triggerEvent then return false end;b=b+1;a[b]=c;local d,e,f='table','function','thread'if d~=type(c)then error('You can only add event handlers to table objects!')end;local g={}local function h(c)local i=type(c)return e==i or d==i and h(getmetatable(c).__call)or f==i end;c.onEvent=function(self,j,k,l)if not h(k)then error('Event handler must be a function, a callable object or a thread!')end;l=l or self;if d~=type(l)then error('The value of self must be a table!')end;if not g[j]then g[j]={_=0}end;local m=f==type(k)and function(...)coroutine.resume(k,...)end or k;local k=g[j]local n=k._+1;k[n]={m,l}k._=n;return n end;c.clearEvent=function(self,j,o)if g[j]and g[j][o]then g[j][o]=nil end end;c.clearAllEvents=function(self)g={}end;c.triggerEvent=function(self,j,...)local p=g[j]if p then for q=1,p._ do local k=p[q]if k then k[1](k[2],...)end end end end;return true end;function library.clearAllEventHandlers()for q=1,b do local c=a[q]if c and c.clearAllEvents then c:clearAllEvents()end end end

        end)()

        ;(function()

        local a=DULibrary or{}function a.getLinks(b,c)local d={}if not b then b={}end;for e,f in pairs(unit.getOutPlugs())do local g=unit[f.name]if'table'==type(g)and'function'==type(g.getClass)then local h=true;for i,j in pairs(b)do if not('function'==type(g[i])and j==g[i]():sub(1,#j))then h=false;break end end;if h then if c then table.insert(d,g)else d[f.name]=g end end end end;return d end;function a.getLinksByClass(k,c)return a.getLinks({getClass=k},c)end;function a.getLinkByClass(k)return a.getLinksByClass(k,true)[1]end;function a.getCoreUnit()return a.getLinkByClass('CoreUnit')end;function a.getLinkByName(l)local m=a.getCoreUnit()if not m then error('getLinkByName requires a linked CoreUnit to work')end;local d=a.getLinks()for n,o in pairs(d)do if l==m.getElementNameById(o.getLocalId())then return o end end end

        end)()

        package.preload['YFS:../e/lib/src/input/Keys.lua']=(function()

        ---@class Keys

        local Keys = {}

        Keys.__index = Keys


        Keys["lshift"] = 1

        Keys["lalt"] = 2

        Keys["brake"] = 3

        Keys["forward"] = 4

        Keys["backward"] = 5

        Keys["yawleft"] = 6

        Keys["yawright"] = 7

        Keys["strafeleft"] = 8

        Keys["straferight"] = 9

        Keys["left"] = 10

        Keys["right"] = 11

        Keys["up"] = 12

        Keys["down"] = 13

        Keys["groundaltitudeup"] = 14

        Keys["groundaltitudedown"] = 15

        Keys["gear"] = 16

        Keys["light"] = 17

        Keys["stopengines"] = 18

        Keys["speedup"] = 19

        Keys["speeddown"] = 20

        Keys["antigravity"] = 21

        Keys["booster"] = 22

        Keys["option0"] = 23

        Keys["option1"] = 24

        Keys["option2"] = 25

        Keys["option3"] = 26

        Keys["option4"] = 27

        Keys["option5"] = 28

        Keys["option6"] = 29

        Keys["option7"] = 30

        Keys["option8"] = 31

        Keys["option9"] = 32

        Keys["option10"] = 33

        Keys["option11"] = 34

        Keys["option12"] = 35

        Keys["option13"] = 36

        Keys["option14"] = 37

        Keys["option15"] = 38

        Keys["option16"] = 39

        Keys["option17"] = 40

        Keys["option18"] = 41

        Keys["option19"] = 42

        Keys["option20"] = 43

        Keys["option21"] = 44

        Keys["option22"] = 45

        Keys["option23"] = 46

        Keys["option24"] = 47

        Keys["option25"] = 48

        Keys["option26"] = 49

        Keys["option27"] = 50

        Keys["option28"] = 51

        Keys["option29"] = 52


        local indexToName = {}

        for key, value in pairs(Keys) do
            indexToName[value] = key
        end


        ---Returns the name of the key

        ---@param value integer

        ---@return string

        function Keys.Name(value)
            return indexToName[value] or "unknown key"
        end


        return setmetatable({}, Keys)


        end)

        package.preload['YFS:../e/lib/src/input/Criteria.lua']=(function()

        local keys = require('YFS:../e/lib/src/input/Keys.lua')


        ---@class Criteria

        ---@field Matches fun(input:Input, isRepeat:boolean, isPressed:boolean):boolean

        ---@field LShift fun():Criteria

        ---@field IgnoreLShift fun():Criteria

        ---@field LCtrl fun():Criteria

        ---@field IgnoreLCtrl fun():Criteria

        ---@field OnPress fun():Criteria

        ---@field OnRelease fun():Criteria

        ---@field OnRepeat fun():Criteria


        local Criteria = {}

        Criteria.__index = Criteria


        function Criteria.New()
            local s = {}
            local requiredMods = {} ---@type integer[]
            local prohibitedMods = { [keys.lshift] = true, [keys.brake] = true } ---@type table<integer,boolean>
            local onRepeat = false
            local onPress = false
            local onRelease = false
            local lastPressed = false -- when reacting to release events, we must know that we've been pressed first

            ---Checks if the key events matches the set criterias
            ---@param input Input
            ---@param isRepeat boolean
            ---@param isPressed boolean
            ---@return boolean
            function s.Matches(input, isRepeat, isPressed)
                local released = onRelease and not isPressed

                if not onRepeat and isRepeat then
                    return false
                end

                -- This check does not work with checking released keys, when the key is also a modifier key.
                -- Only when pressing the key
                if isPressed then
                    for _, k in pairs(requiredMods) do
                        if not input.IsPressed(k) then
                            return false
                        end
                    end

                    -- Also need to check that other modifier keys are *not* pressed
                    for k, v in pairs(prohibitedMods) do
                        if v and input.IsPressed(k) then
                            return false
                        end
                    end

                    lastPressed = true
                end

                if released then
                    if not lastPressed then
                        return false
                    end

                    lastPressed = false
                end

                return (onRepeat and isRepeat) or (onPress and isPressed) or released
            end

            function Criteria.__tostring()
                local str = ""
                for _, c in pairs(requiredMods) do
                    str = str .. " " .. c
                end

                return "" .. str
            end

            -- Q: Where is Alt key?
            -- A: The game doesn't pass that though to us

            ---Requires left shift to be pressed
            ---@return Criteria
            function s.LShift()
                table.insert(requiredMods, keys.lshift)
                prohibitedMods[keys.lshift] = false
                return s
            end

            ---Requires left control to be pressed
            ---@return Criteria
            function s.LCtrl()
                table.insert(requiredMods, keys.brake)
                prohibitedMods[keys.brake] = false
                return s
            end

            ---@return Criteria
            function s.IgnoreLCtrl()
                prohibitedMods[keys.brake] = false
                return s
            end

            ---@return Criteria
            function s.IgnoreLShift()
                prohibitedMods[keys.lshift] = false
                return s
            end

            ---Makes the critera match when the button is pressed
            ---@return Criteria
            function s.OnPress()
                onPress = true
                return s
            end

            ---Makes the criteria match when the button is released.
            ---@return Criteria
            function s.OnRelease()
                onRelease = true
                return s
            end

            ---Makes the critera match when the button is repeated
            ---@return Criteria
            function s.OnRepeat()
                onRepeat = true
                return s
            end

            return setmetatable(s, Criteria)
        end


        return Criteria


        end)

        package.preload['YFS:../e/lib/src/math/Vec3.lua']=(function()

        --- A 3 component vector.

        -- https://github.com/excessive/cpml/blob/master/modules/Vec3.lua


        local sqrt    = math.sqrt

        local cos     = math.cos

        local sin     = math.sin

        local acos    = math.acos


        ---@class Vec3

        ---@field x number

        ---@field y number

        ---@field z number

        ---@field New fun(a:number, b:number, c:number):Vec3

        ---@field unit_x Vec3 X axis of rotation

        ---@field unit_y Vec3 Y axis of rotation

        ---@field unit_z Vec3 Z axis of rotation

        ---@field zero Vec3 Empty vector

        ---@field Clone fun():Vec3

        ---@field Add fun(a:Vec3, b:Vec3):Vec3

        ---@field Sub fun(a:Vec3, b:Vec3):Vec3

        ---@field Mul fun(a:Vec3, b:Vec3):Vec3

        ---@field Div fun(a:Vec3, b:Vec3):Vec3

        ---@field Normalize fun(a:Vec3):Vec3

        ---@field NormalizeInPlace fun(a:Vec3):Vec3

        ---@field NormalizeLen fun(a:Vec3):Vec3,number

        ---@field Trim fun(a:Vec3, len:number):Vec3

        ---@field TrimInPlace fun(a:Vec3, len:number):Vec3

        ---@field Cross fun(a:Vec3, b:Vec3):Vec3

        ---@field Dot fun(a:Vec3, b:Vec3):number

        ---@field Len fun(a:Vec3):number

        ---@field Len2 fun(a:Vec3):number

        ---@field Dist fun(a:Vec3, b:Vec3):number

        ---@field Dist2 fun(a:Vec3, b:Vec3):number

        ---@field Scale fun(a:Vec3, b:number):Vec3

        ---@field ScaleInPlace fun(a:Vec3, b:number):Vec3

        ---@field Rotate fun(a:Vec3, phi:number, axis:Vec3):Vec3

        ---@field Perpendicular fun(a:Vec3):Vec3

        ---@field Lerp fun(a:Vec3, b:Vec3, s:number):Vec3

        ---@field Unpack fun(a:Vec3):number,number,number

        ---@field ComponentMin fun(a:Vec3, b:Vec3):Vec3

        ---@field ComponentMax fun(a:Vec3, b:Vec3):Vec3

        ---@field FlipX fun(a:Vec3):Vec3

        ---@field FlipY fun(a:Vec3):Vec3

        ---@field FlipZ fun(a:Vec3):Vec3

        ---@field AngleTo fun(a:Vec3, b:Vec3):number

        ---@field AngleToDeg fun(a:Vec3, b:Vec3):number

        ---@field ProjectOn fun(a:Vec3, b:Vec3):Vec3

        ---@field ProjectOnPlane fun(a:Vec3, planeNormal:Vec3):Vec3

        ---@field IsVec3 fun(a:any):boolean

        ---@field IsZero fun(a:Vec3):boolean

        ---@field ToString fun(a:Vec3):string

        ---@operator add(Vec3):Vec3

        ---@operator sub(Vec3):Vec3

        ---@operator div(Vec3):Vec3

        ---@operator div(number):Vec3

        ---@operator mul(Vec3):Vec3

        ---@operator mul(number):Vec3

        ---@operator unm:Vec3


        local rad2deg = 180 / math.pi


        local Vec3    = {}

        Vec3.__index  = Vec3



        ---Creates a new Vec3

        -- X can be {x, y, z} or {x=x, y=y, z=z} or a scalar to fill the vector eg. {x, x, x}

        ---@param x? number|{x:number,y:number,z:number}|number X component

        ---@param y? number Y component

        ---@param z? number Z component

        ---@return Vec3 out

        function Vec3.New(x, y, z)
            local s = {}
            -- number, number, number
            if x and y and z then
                s.x = x
                s.y = y
                s.z = z
                -- {x, y, z} or {x=x, y=y, z=z}
            elseif type(x) == "table" then -- table in vanilla lua, cdata in luajit
                s.x, s.y, s.z = x.x or x[1], x.y or x[2], x.z or x[3]
                -- number
            elseif type(x) == "number" then
                s.x = x
                s.y = x
                s.z = x
            else
                s.x = 0
                s.y = 0
                s.z = 0
            end

            return setmetatable(s, Vec3)
        end


        --- Constants

        Vec3.unit_x = Vec3.New(1, 0, 0)

        Vec3.unit_y = Vec3.New(0, 1, 0)

        Vec3.unit_z = Vec3.New(0, 0, 1)

        Vec3.zero   = Vec3.New(0, 0, 0)


        --- Clone a vector.

        ---@param a Vec3 Vector to be cloned

        ---@return Vec3

        function Vec3.Clone(a)
            return Vec3.New(a.x, a.y, a.z)
        end


        --- Add two vectors.

        ---@param a Vec3 Left hand operand

        ---@param b Vec3 Right hand operand

        ---@return Vec3 out

        function Vec3.Add(a, b)
            return Vec3.New(
                a.x + b.x,
                a.y + b.y,
                a.z + b.z
            )
        end


        --- Subtract one vector from another.

        -- Order: If a and b are positions, computes the direction and distance from b to a.

        ---@param a Vec3 Left hand operand

        ---@param b Vec3 Right hand operand

        ---@return Vec3 out

        function Vec3.Sub(a, b)
            return Vec3.New(
                a.x - b.x,
                a.y - b.y,
                a.z - b.z
            )
        end


        --- Multiply a vector by another vector.

        -- Component-wise multiplication not matrix multiplication.

        ---@param a Vec3 Left hand operand

        ---@param b Vec3 Right hand operand

        ---@return Vec3 out

        function Vec3.Mul(a, b)
            return Vec3.New(
                a.x * b.x,
                a.y * b.y,
                a.z * b.z
            )
        end


        --- Divide a vector by another.

        -- Component-wise inv multiplication. Like a non-uniform Scale().

        ---@param a Vec3 Left hand operand

        ---@param b Vec3 Right hand operand

        ---@return Vec3 out

        function Vec3.Div(a, b)
            return Vec3.New(
                a.x / b.x,
                a.y / b.y,
                a.z / b.z
            )
        end


        --- Scale a vector to unit length (1).

        ---@param a Vec3 vector to Normalize

        ---@return Vec3

        function Vec3.Normalize(a)
            if a:IsZero() then
                return Vec3.New()
            end
            return a:Scale(1 / a:Len())
        end


        ---Normalizes the vector in place

        ---@param a Vec3

        ---@return Vec3

        function Vec3.NormalizeInPlace(a)
            if a:IsZero() then
                return a
            end

            return a:ScaleInPlace(1 / a:Len())
        end


        --- Scale a vector to unit length (1), and return the input length.

        ---@param a Vec3 vector to normalize

        ---@return Vec3, number

        function Vec3.NormalizeLen(a)
            if a:IsZero() then
                return Vec3.New(), 0
            end
            local len = a:Len()
            return a:Scale(1 / len), len
        end


        --- Trim a vector to a given length

        ---@param a Vec3 vector to be trimmed

        ---@param len number Length to trim the vector to

        ---@return Vec3 out

        function Vec3.Trim(a, len)
            return a:Normalize():Scale(math.min(a:Len(), len))
        end


        --- Trim the vector, in place, to a given length

        ---@param a Vec3 vector to be trimmed

        ---@param len number Length to trim the vector to

        ---@return Vec3 out

        function Vec3.TrimInPlace(a, len)
            return a:NormalizeInPlace():ScaleInPlace(math.min(a:Len(), len))
        end


        ---Get the cross product of two vectors.

        ---Resulting direction is right-hand rule normal of plane defined by a and b.

        ---Magnitude is the area spanned by the parallelograms that a and b span.

        ---Order: Direction determined by right-hand rule.

        ---@param a Vec3 Left hand operand

        ---@param b Vec3 Right hand operand

        ---@return Vec3

        function Vec3.Cross(a, b)
            return Vec3.New(
                a.y * b.z - a.z * b.y,
                a.z * b.x - a.x * b.z,
                a.x * b.y - a.y * b.x
            )
        end


        --- Get the dot product of two vectors.

        ---@param a Vec3 Left hand operand

        ---@param b Vec3 Right hand operand

        ---@return number

        function Vec3.Dot(a, b)
            return a.x * b.x + a.y * b.y + a.z * b.z
        end


        --- Get the length of a vector.

        ---@param a Vec3 Vector to get the length of

        ---@return number len

        function Vec3.Len(a)
            return sqrt(a.x * a.x + a.y * a.y + a.z * a.z)
        end


        --- Get the squared length of a vector.

        ---@param a Vec3 Vector to get the squared length of

        ---@return number len

        function Vec3.Len2(a)
            return a.x * a.x + a.y * a.y + a.z * a.z
        end


        --- Get the distance between two vectors.

        ---@param a Vec3 Left hand operand

        ---@param b Vec3 Right hand operand

        ---@return number dist

        function Vec3.Dist(a, b)
            local dx = a.x - b.x
            local dy = a.y - b.y
            local dz = a.z - b.z
            return sqrt(dx * dx + dy * dy + dz * dz)
        end


        --- Get the squared distance between two vectors.

        ---@param a Vec3 Left hand operand

        ---@param b Vec3 Right hand operand

        ---@return number dist

        function Vec3.Dist2(a, b)
            local dx = a.x - b.x
            local dy = a.y - b.y
            local dz = a.z - b.z
            return dx * dx + dy * dy + dz * dz
        end


        --- Scale a vector by a scalar.

        ---@param a Vec3 Left hand operand

        ---@param b number Right hand operand

        ---@return Vec3

        function Vec3.Scale(a, b)
            return Vec3.New(a):ScaleInPlace(b)
        end


        --- Scale a vector, in place, by a scalar.

        ---@param a Vec3 Left hand operand

        ---@param b number Right hand operand

        ---@return Vec3

        function Vec3.ScaleInPlace(a, b)
            a.x = a.x * b
            a.y = a.y * b
            a.z = a.z * b
            return a
        end


        --- Rotate vector about an axis.

        ---@param a Vec3 Vector to rotate

        ---@param phi number Angle to rotate vector by (in radians)

        ---@param axis Vec3 Axis to rotate by

        ---@return Vec3

        function Vec3.Rotate(a, phi, axis)
            if not Vec3.IsVec3(axis) then
                return a
            end

            local u = axis:Normalize()
            local c = cos(phi)
            local s = sin(phi)

            -- Calculate generalized rotation matrix
            local m1 = Vec3.New((c + u.x * u.x * (1 - c)), (u.x * u.y * (1 - c) - u.z * s), (u.x * u.z * (1 - c) + u.y * s))
            local m2 = Vec3.New((u.y * u.x * (1 - c) + u.z * s), (c + u.y * u.y * (1 - c)), (u.y * u.z * (1 - c) - u.x * s))
            local m3 = Vec3.New((u.z * u.x * (1 - c) - u.y * s), (u.z * u.y * (1 - c) + u.x * s), (c + u.z * u.z * (1 - c)))

            return Vec3.New(
                a:Dot(m1),
                a:Dot(m2),
                a:Dot(m3)
            )
        end


        --- Get the perpendicular vector of a vector.

        ---@param a Vec3 Vector to get perpendicular axes from

        ---@return Vec3 out

        function Vec3.Perpendicular(a)
            return Vec3.New(-a.y, a.x, 0)
        end


        --- Lerp between two vectors.

        ---@param a Vec3 Left hand operand

        ---@param b Vec3 Right hand operand

        ---@param s number Step value

        ---@return Vec3 out

        function Vec3.Lerp(a, b, s)
            return a + (b - a) * s
        end


        --- Unpack a vector into individual components.

        ---@param a Vec3 Vector to unpack

        ---@return number x

        ---@return number y

        ---@return number z

        function Vec3.Unpack(a)
            return a.x, a.y, a.z
        end


        --- Return the component-wise minimum of two vectors.

        ---@param a Vec3 Left hand operand

        ---@param b Vec3 Right hand operand

        ---@return Vec3 A vector where each component is the lesser value for that component between the two given vectors.

        function Vec3.ComponentMin(a, b)
            return Vec3.New(math.min(a.x, b.x), math.min(a.y, b.y), math.min(a.z, b.z))
        end


        --- Return the component-wise maximum of two vectors.

        ---@param a Vec3 Left hand operand

        ---@param b Vec3 Right hand operand

        ---@return Vec3 A vector where each component is the lesser value for that component between the two given vectors.

        function Vec3.ComponentMax(a, b)
            return Vec3.New(math.max(a.x, b.x), math.max(a.y, b.y), math.max(a.z, b.z))
        end


        -- Negate x axis only of vector.

        ---@param a Vec3 Vector to x-flip.

        ---@return Vec3

        function Vec3.FlipX(a)
            return Vec3.New(-a.x, a.y, a.z)
        end


        -- Negate y axis only of vector.

        ---@param a Vec3 Vector to y-flip.

        ---@return Vec3

        function Vec3.FlipY(a)
            return Vec3.New(a.x, -a.y, a.z)
        end


        -- Negate z axis only of vector.

        ---@param a Vec3 Vector to z-flip.

        ---@return Vec3 z-flipped vector

        function Vec3.FlipZ(a)
            return Vec3.New(a.x, a.y, -a.z)
        end


        ---Gets the angle to b from a

        ---@param a Vec3

        ---@param b Vec3

        ---@return number

        function Vec3.AngleTo(a, b)
            local v = a:Normalize():Dot(b:Normalize())
            return acos(v)
        end


        ---Gets the angle to b from a in degrees

        ---@param a Vec3

        ---@param b Vec3

        ---@return number

        function Vec3.AngleToDeg(a, b)
            return a:AngleTo(b) * rad2deg
        end


        ---Projects vector a onto b

        ---@param a Vec3

        ---@param v Vec3

        ---@return Vec3

        function Vec3.ProjectOn(a, v)
            -- (self * v) * v / v:Len2()
            local s = (a.x * v.x + a.y * v.y + a.z * v.z) / (v.x * v.x + v.y * v.y + v.z * v.z)
            return Vec3.New(s * v.x, s * v.y, s * v.z)
        end


        ---Project a on plane containing origin

        ---@param a Vec3

        ---@param planeNormal Vec3

        ---@return Vec3

        function Vec3.ProjectOnPlane(a, planeNormal)
            return a - planeNormal * a:Dot(planeNormal)
        end


        --- Return a boolean showing if a table is or is not a Vec3.

        ---@param a any Vector to be tested

        ---@return boolean is_vec3

        function Vec3.IsVec3(a)
            return type(a) == "table" and
                type(a.x) == "number" and
                type(a.y) == "number" and
                type(a.z) == "number"
        end


        --- Return a boolean showing if a table is or is not a zero Vec3.

        ---@param a Vec3 Vector to be tested

        ---@return boolean IsZero

        function Vec3.IsZero(a)
            return a.x == 0 and a.y == 0 and a.z == 0
        end


        --- Return a formatted string.

        ---@param a Vec3 Vector to be turned into a string

        ---@return string formatted

        function Vec3.ToString(a)
            return string.format("(%+0.3f,%+0.3f,%+0.3f)", a.x, a.y, a.z)
        end


        function Vec3.__tostring(a)
            return a:ToString()
        end


        ---Negation operator

        ---@param a Vec3

        ---@return Vec3

        function Vec3.__unm(a)
            return Vec3.New(-a.x, -a.y, -a.z)
        end


        ---Equality operator

        ---@param a Vec3

        ---@param b Vec3

        ---@return boolean

        function Vec3.__eq(a, b)
            if not Vec3.IsVec3(a) or not Vec3.IsVec3(b) then
                return false
            end
            return a.x == b.x and a.y == b.y and a.z == b.z
        end


        ---Addition operator

        ---@param a Vec3

        ---@param b Vec3

        ---@return unknown

        function Vec3.__add(a, b)
            return a:Add(b)
        end


        ---Subtraction operator

        ---@param a Vec3

        ---@param b Vec3

        ---@return Vec3

        function Vec3.__sub(a, b)
            return a:Sub(b)
        end


        ---Multiplication operator

        ---@param a Vec3|number

        ---@param b Vec3|number

        ---@return Vec3

        function Vec3.__mul(a, b)
            local aIsVec3 = Vec3.IsVec3(a)
            local bIsVec3 = Vec3.IsVec3(b)
            if aIsVec3 and bIsVec3 then
                ---@cast b Vec3
                return a:Mul(b)
            end

            -- The case when doing <number> * Vec3 a opposed to Vec3 * <number>
            if type(a) == "number" and bIsVec3 then
                return b:Scale(a)
            end

            ---@cast b number
            return a:Scale(b)
        end


        ---Division operator

        ---@param a Vec3

        ---@param b Vec3

        ---@return Vec3

        function Vec3.__div(a, b)
            if Vec3.IsVec3(b) then
                return a:Div(b)
            end

            return a:Scale(1 / b)
        end


        return Vec3


        end)

        package.preload['YFS:../e/lib/src/system/Taskmanager.lua']=(function()

        ---@module "Task"


        ---@class Taskmanager

        ---@field Instance fun():Taskmanager Returns the Taskmanager singleton

        ---@field Add fun(t:Task) Adds a task

        ---@field Count fun():number Returns the number of tasks



        local Taskmanager = {}

        Taskmanager.__index = {}

        local instance


        function Taskmanager.Instance()
            if instance then
                return instance
            end

            local s = {}
            local tasks = {} ---@type Task[]

            ---@param task Task
            function s.Add(task)
                tasks[#tasks + 1] = task
            end

            function s.Count()
                return #tasks
            end

            local function update()
                local keep = {}
                for i, t in ipairs(tasks) do
                    local curr = tasks[i]
                    if curr.Run() == TaskState.Dead then
                        if not curr.Success() then
                            if curr.catcher then
                                curr.catcher(curr)
                            end
                        end

                        if curr.finalizer then
                            curr.finalizer(curr)
                        end
                    else
                        keep[#keep + 1] = curr
                    end
                end

                tasks = keep
            end

            instance = setmetatable(s, Taskmanager)

            system:onEvent("onUpdate", update)

            return instance
        end


        return Taskmanager


        end)

        package.preload['YFS:../e/lib/src/system/Task.lua']=(function()

        local taskmanager = require('YFS:../e/lib/src/system/Taskmanager.lua').Instance()

        local status = coroutine.status

        local resume = coroutine.resume


        ---@enum TaskState

        TaskState = {
            Dead = 0,
            Running = 1
        }


        ---@alias thenFunc fun(...:any): any


        ---@class Task

        ---@field New fun(taskName:string, f:thenFunc, arg1:any?, ...:any[]?):Task Creates a new Task and runs the function ansync.

        ---@field Run fun():TaskState The status of the task

        ---@field Success fun():boolean Returns true if the task succeeded

        ---@field Result fun():any|nil Returns the return value of the task.

        ---@field Error fun():string|nil Returns the error message value of the task, if an error is raised.

        ---@field Exited fun():boolean Returns true when the task has completed its work (or otherwise exited)

        ---@field Then fun(f:thenFunc, thenArg1:any?, ...:any?):Task Chains another call to be run when the previous one has completed.

        ---@field Catch fun(f:fun(t:Task)):Task Sets an error handler, called if the task raises an error

        ---@field Finally fun(f:fun(t:Task)):Task Sets a finalizer, always called before the task is removed from the task manager.

        ---@field Name fun():string Returns the name of the Task

        ---@field catcher fun(t:Task)

        ---@field finalizer fun(t:Task)


        local Task = {}

        Task.__index = Task


        ---Create a new task

        ---@param taskName string The name of the task

        ---@param toRun fun():any

        ---@param arg1 any? First argument to function to be run

        ---@param ... any?[] Other arguments to be passed to the function to be run

        ---@return Task

        function Task.New(taskName, toRun, arg1, ...)
            local s = {
                catcher = nil, ---@type fun(f:Task):Task
                finalizer = nil ---@type fun(f:Task):Task
            }

            local thenFunc = {} --- @type { co:thread, args:any[] }[]

            local function newThen(fun, ...)
                thenFunc[#thenFunc + 1] = { co = coroutine.create(fun), args = { ... } }
            end

            local resultValue ---@type any|nil
            local errorMessage ---@type string|nil
            local success = true
            local exited = false
            local name = taskName

            ---Moves to next call when needed
            local function next()
                if #thenFunc == 0 then
                    return TaskState.Dead
                end

                local dead = status(thenFunc[1].co) == "dead"

                if dead then
                    -- Move to next, or are we done?
                    table.remove(thenFunc, 1)
                    exited = #thenFunc == 0
                    if exited then
                        return TaskState.Dead
                    end
                end

                return TaskState.Running
            end

            function s.Run()
                local result
                if next() == TaskState.Running then
                    local t = thenFunc[1]
                    success, result = resume(t.co, table.unpack(t.args))
                end

                if success then
                    resultValue = result
                    return next()
                end

                errorMessage = result
                return TaskState.Dead
            end

            ---Chain another function to run after the previous one is completed
            ---@param thenfunc fun(...:any[]?)
            ---@param thenArg1 any? First argument to function to be run
            ---@param ... any? Other arguments to be passed to the function to be run
            function s.Then(thenfunc, thenArg1, ...)
                newThen(thenfunc, thenArg1, ...)
                return s
            end

            ---Sets an error handler
            ---@param catcher fun(t:Task)
            function s.Catch(catcher)
                if type(catcher) ~= "function" then
                    error("Can only add function as catchers")
                end

                s.catcher = catcher
                return s
            end

            ---Sets a finalizer
            ---@param finalizer fun(t:Task)
            function s.Finally(finalizer)
                if type(finalizer) ~= "function" then
                    error("Can only add function as catchers")
                end

                s.finalizer = finalizer
                return s
            end

            ---Indicates success of failure
            ---@return boolean
            function s.Success()
                return success
            end

            ---The result of the task
            ---@return any|nil
            function s.Result()
                return resultValue
            end

            ---The error of the task
            ---@return string|nil
            function s.Error()
                return errorMessage
            end

            ---Indicates if the task has completed its run
            ---@return boolean
            function s.Exited()
                return exited
            end

            ---Gets the task name
            ---@return string
            function s.Name()
                return name
            end

            newThen(toRun, arg1, ...)
            setmetatable(s, Task)

            taskmanager.Add(s)

            return s
        end


        ---Waits for the task to complete

        ---@param task Task

        ---@return any

        function Task.Await(task)
            while not task.Exited() do
                coroutine.yield()
            end

            return task.Result()
        end


        return Task


        end)

        package.preload['YFS:../e/lib/src/util/Table.lua']=(function()

        ---Get the length of the table. Operator "#" does not function on non-arrays or arrays with nil values.

        ---@param t table

        ---@return integer

        TableLen = function(t)
            local n = 0

            for _ in pairs(t) do
                n = n + 1
            end

            return n
        end


        ---Revereses the list in-place

        ---@param list any[]

        ReverseInplace = function(list)
            local n = #list

            for i = 1, n / 2 do
                list[i], list[n] = list[n], list[i]
                n = n - 1
            end
        end


        ---Copies elements from one list to another

        ---@param from table

        ---@param to table

        CopyList = function(to, from)
            local start = #to
            for i, item in ipairs(from) do
                to[start + i] = item
            end
        end


        -- http://lua-users.org/wiki/CopyTable

        -- It is important that only one argument is supplied to this version of the deepcopy function.

        -- Otherwise, it will attempt to use the second argument as a table, which can have unintended consequences.

        local function deepcopy(orig, copies)
            copies = copies or {}
            local orig_type = type(orig)
            local copy
            if orig_type == 'table' then
                if copies[orig] then
                    copy = copies[orig]
                else
                    copy = {}
                    copies[orig] = copy
                    for orig_key, orig_value in next, orig, nil do
                        copy[deepcopy(orig_key, copies)] = deepcopy(orig_value, copies)
                    end
                    setmetatable(copy, deepcopy(getmetatable(orig), copies))
                end
            else -- number, string, boolean, etc
                copy = orig
            end
            return copy
        end


        ---Deeply copies the provided table

        ---@generic T

        ---@param o T

        ---@return T

        DeepCopy = function(o)
            return deepcopy(o)
        end


        end)

        package.preload['YFS:flight/route/PointOptions.lua']=(function()

        local _ = require('YFS:../e/lib/src/util/Table.lua')


        ---@class PointOptions

        ---@field New fun():PointOptions Creates a new PointOptions

        ---@field Set fun(name:string, value:any) Sets an option value

        ---@field Get fun(opt:string, defaultValue:any): any a Gets an option value

        ---@field Data fun():table<string, any> Gets the options as a table

        ---@field Clone fun():PointOptions Clones the options


        local PointOptions = {}

        PointOptions.__index = PointOptions


        ---Creates a new PointOptions instance

        ---@param optionData? table An existing table holding option data or nil

        ---@return PointOptions

        function PointOptions.New(optionData)
            local s = {}
            local options = DeepCopy(optionData or {})

            ---@param opt string The name of the option to set
            ---@param value string|number The value of the option
            function s.Set(opt, value)
                options[opt] = value
            end

            ---@param opt string The name of the option to get
            ---@param default string|number The default value if the option doesn't exist
            ---@return string|number # The option value, or the default value
            function s.Get(opt, default)
                local curr = options[opt]
                if curr ~= nil then
                    return curr
                end
                return default
            end

            ---@return table<string, any> # The options as a table
            function s.Data()
                return options
            end

            ---Clones the options
            ---@return PointOptions
            function s.Clone()
                return PointOptions.New(DeepCopy(options))
            end

            return setmetatable(s, PointOptions)
        end


        --- Unit vector in world coordinates in format {x,y,z}. Causes the direction of the construct to be locked to the direction stored in the point throughout the approach to the point.

        PointOptions.LOCK_DIRECTION = "lockDir"

        --- Meters. How close must the construct be to consider the point reached.

        PointOptions.MARGIN = "margin"

        --- m/s. Desired speed when the point is reached.

        PointOptions.FINAL_SPEED = "finalSpeed"

        --- m/s. Desired maximal speed. (equal or less than finalSpeed)

        PointOptions.MAX_SPEED = "maxSpeed"

        -- Boolean. If true, final speed takese precedence over last-point in route check.

        PointOptions.FORCE_FINAL_SPEED = "forcefinalspeed"

        -- Boolean. If true, the point can be skipped while traveling along the route

        PointOptions.SKIPPABLE = "skippable"

        -- Boolean. If true, the point is not shown on the waypoint page

        PointOptions.SELECTABLE = "selectable"

        -- Boolean. If true, the point is considered to have gates that needs opening or closing

        PointOptions.GATE = "gate"

        -- Boolean. If true, forces alignment along vertical up

        PointOptions.FORCE_VERT = "forceVert"


        PointOptions.ALL = { PointOptions.LOCK_DIRECTION, PointOptions.MARGIN, PointOptions.FINAL_SPEED, PointOptions.MAX_SPEED,
            PointOptions.FORCE_FINAL_SPEED, PointOptions.SKIPPABLE, PointOptions.SELECTABLE, PointOptions.GATE,
            PointOptions.FORCE_VERT }

        return PointOptions


        end)

        package.preload['YFS:flight/route/Point.lua']=(function()

        local PointOptions = require('YFS:flight/route/PointOptions.lua')


        -- This class represents a position and behavior in a route.

        -- Keep data as small as possible.


        ---@alias PointPOD {pos:string, waypointRef?:string, opt:table<string, any>}


        ---@class Point Represents a point/waypoint in a route

        ---@field New fun(pos:string, waypointRef?:string, options?:PointOptions):Point

        ---@field Pos fun():string

        ---@field HasWaypointRef fun():boolean

        ---@field WaypointRef fun():string|nil

        ---@field SetWaypointRef fun(ref:string)

        ---@field Persist fun():PointPOD

        ---@field Options fun():PointOptions

        ---@field SetOptions fun(newOptions:PointOptions)

        ---@field LoadFromPOD fun(source:PointPOD):Point

        local Point = {}

        Point.__index = Point


        ---Creates a new Point

        ---@param pos string A ::pos{} string

        ---@param waypointRef? string A named waypoint reference or nil

        ---@param options? PointOptions Point options, or nil

        ---@return Point

        function Point.New(pos, waypointRef, options)
            local s = {}

            local position = pos -- ::pos{} string
            local wpRef = waypointRef
            local opt = options or PointOptions.New()

            ---Returns the ::pos{} string. When retrieved from a loaded route, this is guaranteed to be populated.
            ---@return string
            function s.Pos()
                return position
            end

            ---Indicates if the point has a waypoint reference
            ---@return boolean
            function s.HasWaypointRef()
                return wpRef ~= nil and #wpRef > 0
            end

            ---Returns the name of the waypoint reference
            ---@return string|nil
            function s.WaypointRef()
                return wpRef
            end

            ---Sets the named waypoint reference
            ---@param ref string
            function s.SetWaypointRef(ref)
                wpRef = ref
            end

            ---Returns a persistable table version of the point
            ---@return PointPOD
            function s.Persist()
                local pod ---@type PointPOD
                pod = {
                    pos = position,
                    waypointRef = wpRef,
                    opt = opt.Data() or {}
                }

                return pod
            end

            ---Returns the options for the point
            ---@return PointOptions
            function s.Options()
                return opt
            end

            ---Sets new options
            ---@param newOptions PointOptions
            function s.SetOptions(newOptions)
                opt = newOptions
            end

            return setmetatable(s, Point)
        end


        ---Loads data from a PointPOD

        ---@param source PointPOD

        function Point.LoadFromPOD(source)
            return Point.New(source.pos, source.waypointRef, PointOptions.New(source.opt))
        end


        return Point


        end)

        package.preload['YFS:../e/lib/src/system/Stopwatch.lua']=(function()

        ---@class Stopwatch

        ---@field Start fun() Starts the stopwatch, or leaves it running if it already is.

        ---@field Restart fun() Restarts the stopwatch

        ---@field Stop fun() Stops the stopwatch

        ---@field Reset fun() Resets the stopwatch to a state as if it never had been started

        ---@field Elapsed fun():number Returns the number of seconds the stopwatch has been running.

        ---@field IsRunning fun():boolean Returns true if the stopwatch is currently running, i.e. started, and not stopped.


        local Stopwatch = {}

        Stopwatch.__index = Stopwatch


        ---Creates a new Stopwatch

        ---@return Stopwatch

        function Stopwatch.New()
            local s = {}

            local utc = system.getUtcTime
            local startTime = nil
            local stopTime = nil

            ---Starts the stopwatch, or leaves it running if it already is.
            function s.Start()
                if not s.IsRunning() then
                    startTime = utc()
                    stopTime = nil
                end
            end

            ---Restarts the stopwatch
            function s.Restart()
                s.Stop()
                s.Start()
            end

            ---Stops the stopwatch
            function s.Stop()
                stopTime = utc()
            end

            ---Resets the stopwatch, Elapsed() will return 0 after this call
            function s.Reset()
                startTime = nil
                stopTime = nil
            end

            ---@return number # Elapsed time, in seconds with fractions.
            function s.Elapsed()
                if startTime == nil then
                    return 0
                elseif stopTime == nil then
                    return utc() - startTime
                else
                    return stopTime - startTime
                end
            end

            ---Checks if the stopwatch is running
            ---@return boolean
            function s.IsRunning()
                return startTime ~= nil and stopTime == nil
            end

            return setmetatable(s, Stopwatch)
        end


        return Stopwatch


        end)

        package.preload['YFS:../e/lib/src/abstraction/Vehicle.lua']=(function()

        local V3                      = require('YFS:../e/lib/src/math/Vec3.lua').New

        local core                    = library.getCoreUnit()


        ---@alias fun3 fun():Vec3

        ---@alias funn fun():number

        ---@alias funb fun():boolean

        ---@alias VPosition {Current:fun3}

        ---@alias VPlayer {position:{Current:fun3, orientation:{Forward:fun3, Up:fun3, Right:fun3, IsFirstPerson:funb}}}}

        ---@alias VSpeed {MaxSpeed:funn}


        ---@class Vehicle

        ---@field position VPosition

        ---@field player VPlayer

        ---@field speed VSpeed


        local ct                      = construct


        local Vehicle                 = {}

        Vehicle.__index               = Vehicle


        local atmoToSpaceDensityLimit = 0.09 -- At what density level we consider space to begin. Densities higher than this is atmo.


        local vehicle                 = {
            acceleration = {
                Angular = function()
                    return V3(ct.getWorldAngularAcceleration())
                end,
            },
            player = {
                position = {
                    Current = function()
                        return V3(player.getWorldPosition())
                    end
                },
                orientation = {
                    Up = function()
                        return V3(player.getWorldUp())
                    end
                },
            },
        }


        Current                       = function() return V3(ct.getWorldPosition()) end

        Up                            = function() return V3(ct.getWorldOrientationUp()) end

        Right                         = function() return V3(ct.getWorldOrientationRight()) end

        Forward                       = function() return V3(ct.getWorldOrientationForward()) end


        LocalUp                       = function() return V3(ct.getOrientationUp()) end

        LocalRight                    = function() return V3(ct.getOrientationRight()) end

        LocalForward                  = function() return V3(ct.getOrientationForward()) end


        AtmoDensity                   = unit.getAtmosphereDensity

        IsInAtmo                      = function() return AtmoDensity() > atmoToSpaceDensityLimit end

        IsInSpace                     = function() return not IsInAtmo() end

        GravityDirection              = function() return V3(core.getWorldVertical()) end

        G                             = core.getGravityIntensity

        AirFrictionAcceleration       = function() return V3(ct.getWorldAirFrictionAcceleration()) end


        MaxSpeed                      = function()
            return IsInAtmo() and ct.getFrictionBurnSpeed() * 0.99 or ct.getMaxSpeed()
        end


        Acceleration                  = function() return V3(ct.getWorldAcceleration()) end

        Velocity                      = function() return V3(ct.getWorldAbsoluteVelocity()) end

        LocalAngVel                   = function() return V3(ct.getAngularVelocity()) end

        LocalAngAcc                   = function() return V3(ct.getAngularAcceleration()) end


        -- player.isFrozen() can return nil, reported to NQ in ticket 81865

        -- Their answer is "don't call from flush"

        IsFrozen                      = player.isFrozen


        TotalMass                     = ct.getTotalMass


        return vehicle


        end)

        package.preload['YFS:YFSConstants.lua']=(function()

        local Vec3 = require('YFS:../e/lib/src/math/Vec3.lua')


        local constants = {
            ticksPerSecond = 60.0,
            flushTick = 1 / 60.0,
            universe = {
                up = Vec3.New(0, 1, 0),
                forward = Vec3.New(1, 0, 0),
                right = Vec3.New(0, 0, 1)
            },
            direction = {
                counterClockwise = 1,
                clockwise = -1,
                rightOf = 1,
                leftOf = -1,
                still = 0
            },
            flight = {
                speedPid = {
                    p = 5,
                    i = 0.005,
                    d = 100,
                    a = 0.99
                },
                axis = {
                    light = {
                        p = 10,
                        i = 0,
                        d = 800,
                        a = 0.1
                    },
                    heavy = {
                        p = 6,
                        i = 1,
                        d = 1600,
                        a = 0.1
                    }
                },
                throttleStep = 10,                   -- percent
                defaultMargin = 0.1,                 -- meter
                defaultStartEndMargin = 0.3,         -- meter
                defaultTurnAngle = 1,                -- degrees
                lightConstructMassThreshold = 10000, -- ten tons
                minimumPathCheckOffset = 2,          -- meters
                pathAlignmentAngleLimit = 10,        -- degrees
                pathAlignmentDistanceLimit = 200     -- meters

            },
            route = {
                routeStartDistanceLimit = 10,    -- meters
                autoShutdownFloorDistance = 5,   -- meters
                yawAlignmentThrustLimiter = 3,   -- degrees
                pitchAlignmentThrustLimiter = 5, -- degrees
                rollAlignmentThrustLimiter = 5,  -- degrees
                gateControlDistance = 5          -- meters
            },
            widgets = {
                showOnStart = false
            }
        }


        return constants


        end)

        package.preload['YFS:../e/lib/src/debug/Log.lua']=(function()

        ---@class Log

        ---@field Instance fun():Log

        ---@field SetLevel fun(level:LogLevel)

        ---@field Info fun(...:any)

        ---@field Warning fun(...:any)

        ---@field Error fun(...:any)

        ---@field Debug fun(...:any)


        local Log = {}

        Log.__index = Log


        ---@enum LogLevel

        LVL = {
            OFF = 0,
            INFO = 2,
            ERROR = 3,
            WARNING = 4,
            DEBUG = 5
        }


        local instance ---@type Log


        ---@return Log

        function Log.Instance()
            if instance then return instance end
            local s = {}
            local level = LVL.WARNING

            local function getLevelStr(lvl)
                if lvl == LVL.DEBUG then
                    return "D"
                elseif lvl == LVL.ERROR then
                    return "E"
                elseif lvl == LVL.INFO then
                    return "I"
                elseif lvl == LVL.WARNING then
                    return "W"
                else
                    return "UNKOWN"
                end
            end

            local function formatValues(...)
                local parts = {}
                local args = { ... }

                for i = 1, #args, 1 do
                    local v

                    v = args[i]
                    if v == nil then
                        v = ""
                    end

                    local r = ""

                    local t = type(v)
                    if t == "string" then
                        r = string.format("%s", v)
                    elseif t == "number" then
                        r = string.format("%s", tonumber(v))
                    elseif t == "boolean" then
                        r = tostring(v)
                    elseif t == "function" then
                        r = tostring(v)
                    elseif t == "table" then
                        r = "{"
                        for key, data in pairs(v) do
                            r = r .. formatValues(key, ": ", data, ",")
                        end
                        r = r .. "}"
                    else
                        r = "unprintable: '" .. t .. "'"
                    end

                    parts[#parts + 1] = string.format("%s", r)
                end

                return table.concat(parts)
            end

            ---@param logLevel LogLevel
            ---@param ... any
            function s.print(logLevel, ...)
                if logLevel <= level then
                    system.print(string.format("[%s] %s", getLevelStr(logLevel), formatValues(...)))
                end
            end

            ---@param logLevel LogLevel
            function s.SetLevel(logLevel)
                level = logLevel
            end

            ---@param msg any
            ---@param ... any
            function s.Info(msg, ...)
                s.print(LVL.INFO, msg, ...)
            end

            ---comment
            ---@param msg any
            ---@param ... any
            function s.Warning(msg, ...)
                s.print(LVL.WARNING, msg, ...)
            end

            ---@param msg any
            ---@param ... any
            function s.Error(msg, ...)
                s.print(LVL.ERROR, msg, ...)
            end

            ---@param msg any
            ---@param ... any
            function s.Debug(msg, ...)
                s.print(LVL.DEBUG, msg, ...)
            end

            return setmetatable(s, Log)
        end


        return Log


        end)

        package.preload['YFS:../e/lib/src/util/StringUtil.lua']=(function()

        local SU = {}


        function SU.CoSplit(str, pat)
           -- http://lua-users.org/wiki/SplitJoin

           local t = {} -- NOTE: use {n = 0} in Lua-5.0
           local fpat = "(.-)" .. pat
           local last_end = 1
           local s, e, cap = str:find(fpat, 1)
           while s do
              if s ~= 1 or cap ~= "" then
                 table.insert(t, cap)
              end
              last_end = e + 1
              s, e, cap = str:find(fpat, last_end)
              coroutine.yield()
           end
           if last_end <= #str then
              cap = str:sub(last_end)
              table.insert(t, cap)
           end
           return t
        end


        function SU.Round(num, numDecimalPlaces)
           local mult = 10 ^ (numDecimalPlaces or 0)
           return math.floor(num * mult + 0.5) / mult
        end


        function SU.RemoveDecimal(s)
           return s:gsub("%.%d", "")
        end


        function PadLeft(s, width)
           if #s < width then
              s = string.rep('&nbsp;', width - #s) .. s
           end

           return s
        end


        function SU.FormatThousands(value)
           local formatted = value
           local k
           local done = false

           while not done do
              formatted, k = string.gsub(formatted, "^(-?%d+)(%d%d%d)", '%1 %2')
              done = k == 0
           end

           return formatted
        end


        function SU.Trim(s)
           return s:match "^%s*(.-)%s*$"
        end


        ---Splits the string into parts, honoring " and ' as quote chars to make multi-word arguments

        ---@param s string

        ---@return string[]

        function SU.SplitQuoted(s)
           local function isQuote(c) return c == '"' or c == "'" end

           local function isSpace(c) return c == " " end

           local function add(target, v)
              v = SU.Trim(v)
              if v:len() > 0 then
                 table.insert(target, #target + 1, v)
              end
           end

           local inQuote = false
           local parts = {} ---@type string[]
           local current = ""

           for c in s:gmatch(".") do
              if isSpace(c) and not inQuote then
                 -- End of non-quoted part
                 add(parts, current)
                 current = ""
              elseif isQuote(c) then
                 if inQuote then
                    -- End of quote
                    add(parts, current)
                    current = ""
                    inQuote = false
                 else
                    -- End current, start quoted
                    add(parts, current)
                    current = ""
                    inQuote = true
                 end
              else
                 current = current .. c
              end
           end

           -- Add whatever is at the end of the string.
           add(parts, current)

           return parts
        end


        ---Returns true if the original string starts with the prefix

        ---@param original string

        ---@param prefix string

        function SU.StartsWith(original, prefix)
           return original:find(prefix, 1, true) == 1
        end


        function SU.EndsWith(str, ending)
           return ending == "" or str:sub(- #ending) == ending
        end


        ---@param original string

        ---@param prefix string

        function SU.RemovePrefix(original, prefix)
           if SU.StartsWith(original, prefix) then
              return original:sub(#prefix + 1, #original)
           else
              return original
           end
        end


        return SU


        end)

        package.preload['YFS:../e/lib/src/commandline/Types.lua']=(function()

        local log = require('YFS:../e/lib/src/debug/Log.lua').Instance()


        ---@alias ArgumentValueTypes nil|boolean|number|string


        ---@enum ArgTypes

        local argType = {
            EMPTY = 0,
            BOOLEAN = 1,
            NUMBER = 2,
            STRING = 3,
            EMPTY_BOOLEAN = 4
        }


        ---Parses the raw input returning status, value

        ---@param wantedType ArgTypes

        ---@param raw string

        ---@return boolean, ArgumentValueTypes

        function argType.parseValue(wantedType, raw)
            if wantedType == argType.EMPTY and raw == nil then
                return true, ""
            elseif raw == nil then
                return true, raw
            end

            if wantedType == argType.BOOLEAN then
                if raw == "true" or raw == "1" then
                    return true, true
                elseif raw == "false" or raw == "0" then
                    return true, false
                else
                    log.Error("Not a boolean: ", raw)
                end
            elseif wantedType == argType.NUMBER then
                local match = string.match(raw, "([+-]?%d*%.?%d+)")
                if match == nil then
                    log.Error("Not a number: ", raw)
                else
                    return true, tonumber(match)
                end
            else
                return true, raw
            end

            return false, nil
        end


        return argType


        end)

        package.preload['YFS:../e/lib/src/commandline/Option.lua']=(function()

        local log = require('YFS:../e/lib/src/debug/Log.lua').Instance()

        local argType = require('YFS:../e/lib/src/commandline/Types.lua')


        ---@class Option

        ---@field New fun(name:string):Option

        ---@field AsString fun():Option

        ---@field AsNumber fun():Option

        ---@field AsBoolean fun():Option

        ---@field AsEmptyBoolean fun():Option

        ---@field Must fun():Option

        ---@field Default fun(v:ArgumentValueTypes):Option

        ---@field Parse fun(args:string[], target:table<string,ArgumentValueTypes>):boolean


        local Option = {}

        Option.__index = Option


        ---Creates a new command option

        ---@param name string The option name, such as "-opt", "--opt" or just "opt". Im the latter case a "-" is added to the name.

        ---@return Option

        function Option.New(name)
            if name:sub(1, 1) ~= "-" then
                name = "-" .. name
            end

            local s = {}
            local sanitizedName = name:gsub("^%-*", "")
            local optType = argType.EMPTY
            local mandatory = false
            local default = nil

            ---Marks option to be a string
            ---@return Option
            function s.AsString()
                optType = argType.STRING
                return s
            end

            ---Mark option as number
            ---@return Option
            function s.AsNumber()
                optType = argType.NUMBER
                return s
            end

            ---Mark option as boolean
            ---@return Option
            function s.AsBoolean()
                optType = argType.BOOLEAN
                return s
            end

            ---Mark option as mandatory
            ---@return Option
            function s.Must()
                mandatory = true
                return s
            end

            ---Mark option as empty
            ---@return Option
            function s.AsEmptyBoolean()
                optType = argType.EMPTY_BOOLEAN
                return s
            end

            ---Set default value for option
            ---@param v ArgumentValueTypes
            function s.Default(v)
                default = v
                return s
            end

            ---Parses the arguments, putting the found values in the the target in a key:value fashion, with sanitized key names.
            ---@param args string[]
            ---@param target table<string, ArgumentValueTypes>
            ---@return boolean
            function s.Parse(args, target)
                -- Find the argument in the input data
                for i, key in ipairs(args) do
                    if key == name then
                        if optType == argType.EMPTY_BOOLEAN then
                            target[sanitizedName] = true
                            table.remove(args, i)
                        elseif i + 1 <= #args then          -- Next value is the argument, if it exists
                            table.remove(args, i)           -- Remove the arg itself
                            local v = table.remove(args, i) -- Remove and store the value

                            local ok
                            ok, target[sanitizedName] = argType.parseValue(optType, v)
                            if not ok then
                                return false
                            end
                        elseif mandatory then
                            log.Error("Missing value for mandatory option ", key)
                            return false
                        end

                        break
                    end
                end

                if optType == argType.EMPTY_BOOLEAN and target[sanitizedName] == nil then
                    target[sanitizedName] = false
                end

                if target[sanitizedName] == nil and default ~= nil then
                    target[sanitizedName] = default
                end

                local res = (not mandatory) or target[sanitizedName] ~= nil

                if not res then
                    log.Error("Option ", name, " not complete")
                end
                return res
            end

            return setmetatable(s, Option)
        end


        return Option


        end)

        package.preload['YFS:../e/lib/src/util/Calc.lua']=(function()

        local Vec3 = require('YFS:../e/lib/src/math/Vec3.lua')


        local solve3 = library.systemResolution3


        local atan = math.atan

        local cos = math.cos

        local acos = math.acos

        local max = math.max

        local min = math.min

        local abs = math.abs

        local sqrt = math.sqrt

        local deg2rad = math.pi / 180

        local rad2deg = 180 / math.pi


        local calc = {}


        ---Returns the absolute difference between a and b

        ---@param a any Value a to compare

        ---@param b any Value b to compare

        ---@return any Absolute difference between the two numbers.

        calc.AbsDiff = function(a, b)
            a, b = abs(a), abs(b)
            return max(a, b) - min(a, b)
        end


        calc.Round = function(number, decimalPlaces)
            local mult = 10 ^ (decimalPlaces or 0)
            return math.floor(number * mult + 0.5) / mult
        end


        ---@param v number

        ---@return number

        calc.Sign = function(v)
            if v > 0 then
                return 1
            elseif v < 0 then
                return -1
            else
                return 0
            end
        end


        ---@param value number

        ---@param sign integer -1 or 1

        ---@return number

        calc.SetSign = function(value, sign)
            value = abs(value)

            if sign ~= 0 then
                return value * sign
            end

            return value
        end


        calc.Scale = function(value, inMin, inMax, outMin, outMax)
            return (outMax - outMin) / (inMax - inMin) * (value - inMin) + outMin
        end


        --- @param coordinate Vec3 A position in in world coordinates to convert to local coordinates

        calc.WorldToLocal = function(coordinate)
            local localized = coordinate - Vec3.New(construct.getWorldPosition())
            return Vec3.New(solve3(construct.getWorldRight(), construct.getWorldForward(), construct.getWorldUp(),
                { localized:Unpack() }))
        end


        --- @param direction Vec3 A unit vector, in world coordinates to convert to a local unit vector

        calc.WorldDirectionToLocal = function(direction)
            return Vec3.New(solve3(construct.getWorldRight(), construct.getWorldForward(), construct.getWorldUp(),
                { direction:Unpack() }))
        end

        --[[ This one does the same thing as the above one, except that it doesn't subtract the construct position to move the vector to origo.

        calc.WorldToLocal = function(worldPos)
            local RGT = Vec3.New(construct.getWorldRight())
            local FWD = Vec3.New(construct.getWorldForward())
            local UP = Vec3.New(construct.getWorldUp())

            local localPos = Vec3.New(
                    worldPos:Dot(RGT),
                    worldPos:Dot(FWD),
                    worldPos:Dot(UP)
            )

            return localPos
        end]]


        ---Converts construct local coordinates to world coordinates

        ---@param localCoord Vec3

        ---@return Vec3

        calc.LocalToWorld = function(localCoord)
            local xOffset = localCoord.x * Vec3.New(construct.getWorldOrientationRight())
            local yOffset = localCoord.y * Vec3.New(construct.getWorldOrientationForward())
            local zOffset = localCoord.z * Vec3.New(construct.getWorldOrientationUp())
            return xOffset + yOffset + zOffset + Vec3.New(construct.getWorldPosition())
        end


        ---@param normal Vec3

        ---@param vecA Vec3

        ---@param vecB Vec3

        ---@return number

        calc.SignedRotationAngle = function(normal, vecA, vecB)
            vecA = vecA:ProjectOnPlane(normal)
            vecB = vecB:ProjectOnPlane(normal)
            return atan(vecA:Cross(vecB):Dot(normal), vecA:Dot(vecB))
        end


        ---@param up Vec3

        ---@param right Vec3

        ---@return Vec3

        calc.StraightForward = function(up, right)
            return up:Cross(right)
        end


        ---@param mps number

        ---@return number

        calc.Mps2Kph = function(mps)
            return mps * 3.6
        end


        ---@param kph number

        ---@return number

        calc.Kph2Mps = function(kph)
            return kph / 3.6
        end


        ---Clamps v between minVal and maxVal, inclusive

        ---@param v number

        ---@param minVal number

        ---@param maxVal number

        ---@return number

        calc.Clamp = function(v, minVal, maxVal)
            return min(maxVal, max(v, minVal))
        end



        ---Returns the nearest point on the line

        ---@param lineStart Vec3

        ---@param lineDirection Vec3

        ---@param pointAwayFromLine Vec3

        ---@return Vec3

        calc.NearestPointOnLine = function(lineStart, lineDirection, pointAwayFromLine)
            -- https://forum.unity.com/threads/how-do-i-find-the-closest-point-on-a-line.340058/
            local lineDir = lineDirection:Normalize()
            local v = pointAwayFromLine - lineStart
            local d = v:Dot(lineDir)
            return lineStart + lineDir * d
        end


        ---Gets the closest point to p on the line segment a-b

        ---@param a Vec3 Line start

        ---@param b Vec3 Line end

        ---@param p Vec3 The point away from the line

        ---@return Vec3 #Point on the line segment

        calc.NearestOnLineBetweenPoints = function(a, b, p)
            local ab = b - a
            local ap = p - a

            local proj = ap:Dot(ab)

            local abLen2 = ab:Len2()

            if abLen2 <= 0 then
                -- a and b are on the same place
                return a
            end

            local d = proj / abLen2

            if d <= 0 then
                return a
            elseif d >= 1 then
                return b
            else
                return a + ab * d
            end
        end


        -- https://gamedev.stackexchange.com/questions/96459/fast-ray-sphere-collision-code

        -- https://github.com/excessive/cpml/blob/master/modules/intersect.lua#L152

        ---@param ray Ray

        ---@param sphereCenter Vec3

        ---@param sphereRadius number

        ---@return boolean,Vec3,number

        calc.LineIntersectSphere = function(ray, sphereCenter, sphereRadius)
            local offset = ray.Start - sphereCenter
            local b = offset:Dot(ray.Dir)
            local c = offset:Dot(offset) - sphereRadius * sphereRadius

            -- ray's position outside sphere (c > 0)
            -- ray's direction pointing away from sphere (b > 0)
            if c > 0 and b > 0 then
                return false, Vec3.New(), 0
            end

            local discr = b * b - c

            -- negative discriminant
            if discr < 0 then
                return false, Vec3.New(), 0
            end

            -- If t is negative, ray started inside sphere so clamp t to zero
            local t = -b - sqrt(discr)
            t = t < 0 and 0 or t

            -- Return collision point and distance from ray origin
            return true, ray.Start + ray.Dir * t, t
        end


        ---Determmines of the value is NaN

        ---@param value number

        ---@return boolean

        calc.IsNaN = function(value)
            return value ~= value
        end


        ---Determines if the difference between a and b is within the margin

        ---@param a number

        ---@param b number

        ---@param margin number

        ---@return boolean

        calc.AreAlmostEqual = function(a, b, margin)
            return abs(a - b) < margin
        end


        ---Tenary function

        ---@generic T

        ---@param condition boolean

        ---@param a T

        ---@param b T

        ---@return T

        calc.Ternary = function(condition, a, b)
            if condition then
                return a
            end

            return b
        end


        ---Rotate a vector around a point

        ---@param vector Vec3 The vector to rotate

        ---@param rotationPoint Vec3 The point to rotate around

        ---@param degrees number The angle, in degrees, to rotate

        ---@param axis Vec3 The axis to rotate around

        ---@return Vec3 #The vector, rotated around the axis

        calc.RotateAroundAxis = function(vector, rotationPoint, degrees, axis)
            return (vector - rotationPoint):Rotate(degrees * deg2rad, axis:NormalizeInPlace()) + rotationPoint
        end


        ---@param vector Vec3

        ---@return number

        calc.SignLargestAxis = function(vector)
            local arr = { vector:Unpack() }

            local ix = 1
            local maxFound = abs(arr[ix])
            for i = 1, #arr, 1 do
                local v = abs(arr[i])
                if v > maxFound then
                    maxFound = v
                    ix = i
                end
            end

            return calc.Sign(arr[ix])
        end



        ---Calculates the brake distance

        ---@param speed number

        ---@param acceleration number

        ---@return number

        calc.CalcBrakeDistance = function(speed, acceleration)
            local d = (speed ^ 2) / (2 * acceleration)
            if calc.IsNaN(d) or acceleration == 0 then
                return 0
            end

            return d
        end


        ---Calculates the required brake acceleration to come to a stop in the remaining distance

        ---@param speed number

        ---@param remainingDistance number

        ---@return number

        calc.CalcBrakeAcceleration = function(speed, remainingDistance)
            ---Calculating the brake acceleration is the same mathematical operation as for the brake distance so we resuse for less code.
            return calc.CalcBrakeDistance(speed, remainingDistance)
        end



        -- https://github.com/GregLukosek/3DMath/blob/master/Math3D.cs


        -- Get the shortest distance between a point and a plane. The output is signed so it holds information

        -- as to which side of the plane normal the point is.

        ---@param planeNormal Vec3

        ---@param planePoint Vec3

        ---@param point Vec3

        ---@return number

        local function signedDistancePlanePoint(planeNormal, planePoint, point)
            return planeNormal:Dot(point - planePoint)
        end


        ---Project a point on a plane

        ---@param planeNormal Vec3

        ---@param planePoint Vec3

        ---@param point Vec3

        ---@return Vec3

        calc.ProjectPointOnPlane = function(planeNormal, planePoint, point)
            -- First calculate the distance from the point to the plane:
            local distance = signedDistancePlanePoint(planeNormal, planePoint, point)

            -- Reverse the sign of the distance
            distance = distance * -1;

            -- Get a translation vector
            local translationVector = planeNormal * distance

            -- Translate the point to form a projection
            return point + translationVector
        end



        ---Returns the corresponding angle for the given dot product (for unit vectors)

        ---@param dot number Dot product

        ---@return number # Angle in degrees

        calc.DotToAngle = function(dot)
            return rad2deg * acos(dot)
        end


        calc.AngleToDot = function(angleDeg)
            return cos(angleDeg * deg2rad)
        end


        ---@param v number

        ---@param minV number

        ---@param maxV number

        ---@return boolean

        calc.BetweenOrEqual = function(v, minV, maxV)
            return v >= minV and v <= maxV
        end


        return calc


        end)

        package.preload['YFS:../e/lib/src/commandline/Command.lua']=(function()

        local log = require('YFS:../e/lib/src/debug/Log.lua').Instance()

        local Option = require('YFS:../e/lib/src/commandline/Option.lua')

        local argType = require('YFS:../e/lib/src/commandline/Types.lua')

        local calc = require('YFS:../e/lib/src/util/Calc.lua')

        require('YFS:../e/lib/src/util/Table.lua')


        ---@module "commandline/Types"


        ---@alias CommandResult table<string, ArgumentValueTypes> -- Actual layout: {commandValue:value, sanitizedName:optionValue}


        ---@class Command

        ---@field New fun():Command

        ---@field AsString fun():Command

        ---@field AsNumber fun():Command

        ---@field AsBoolean fun():Command

        ---@field AsEmpty fun():Command

        ---@field Must fun():Command

        ---@field Option fun(name:string):Option

        ---@field Parse fun(args:string[]):CommandResult


        local Command = {}

        Command.__index = Command


        function Command.New()
            local s = {}
            local type = argType.EMPTY ---@type ArgTypes
            local option = {} ---@type table<string,Option>
            local mandatory = false

            ---Marks command as string
            ---@return Command
            function s.AsString()
                type = argType.STRING
                return s
            end

            ---Marks command as number
            ---@return Command
            function s.AsNumber()
                type = argType.NUMBER
                return s
            end

            ---Marks command as boolean
            ---@return Command
            function s.AsBoolean()
                type = argType.BOOLEAN
                return s
            end

            ---Marks command as emtpy
            ---@return Command
            function s.AsEmpty()
                if mandatory then
                    error("Command is mandatory, cannot set as type empty")
                end
                type = argType.EMPTY
                return s
            end

            ---Marks command as mandatory
            ---@return Command
            function s.Must()
                if type == argType.EMPTY then
                    error("Command is of type empty, cannot set as mandatory")
                end
                mandatory = true
                return s
            end

            ---Adds an option to the command
            ---@param name string
            ---@return Option
            function s.Option(name)
                local opt = Option.New(name)
                option[name] = opt
                return opt
            end

            ---Parses command and options from args
            ---@param args string[]
            ---@return CommandResult|nil
            function s.Parse(args)
                -- Let the options extract their data first; whatever is left is for the command
                local data = {} ---@type CommandResult

                for _, opt in pairs(option) do
                    if not opt.Parse(args, data) then
                        return nil
                    end
                end

                local expectedLength = type == argType.EMPTY and 0 or 1
                local len = TableLen(args)
                if len < expectedLength then
                    log.Error("Too few arguments for command.")
                    return nil
                elseif len > expectedLength then
                    log.Error("Too many arguments for command.")
                    log.Error(args)
                    return nil
                end

                local ok
                ok, data.commandValue = argType.parseValue(type, args[1])

                if not ok then
                    return nil
                end

                if data.commandValue == nil and mandatory then
                    log.Error("Missing mandatory value for command")
                    return nil
                end

                return data
            end

            return setmetatable(s, Command)
        end


        return Command


        end)

        package.preload['YFS:../e/lib/src/commandline/CommandLine.lua']=(function()

        local log = require('YFS:../e/lib/src/debug/Log.lua').Instance()

        local su = require('YFS:../e/lib/src/util/StringUtil.lua')

        local Command = require('YFS:../e/lib/src/commandline/Command.lua')


        ---@alias CommandFunction fun(data:CommandResult)

        ---@alias PreparedCommand {cmd:Command, exec:CommandFunction}

        ---@alias AccessCheck fun(cmd:string):boolean


        ---@class CommandLine

        ---@field Accept fun(name:string, func:CommandFunction):Command

        ---@field Clear fun()

        ---@field Exec fun(command:string)

        ---@field SetAccess fun(f:AccessCheck)


        local CommandLine = {}

        CommandLine.__index = CommandLine

        local singleton


        ---Get the commandline instance

        ---@return CommandLine

        function CommandLine.Instance()
            if singleton then
                return singleton
            end

            local s       = {}
            local command = {} ---@type table<string, PreparedCommand>
            ---@type AccessCheck
            local access  = function(_)
                return true
            end

            ---@param f AccessCheck
            function s.SetAccess(f)
                access = f
            end

            ---Accepts a command
            ---@param name string
            ---@param func CommandFunction
            ---@return Command
            function s.Accept(name, func)
                local o = Command.New()
                command[name] = { cmd = o, exec = func }
                return o
            end

            ---Clears all registered commands
            function s.Clear()
                command = {}
            end

            ---Parses and executes the input command
            ---@param input string
            local function exec(input)
                local exeFunc = function(commandString)
                    local parts = su.SplitQuoted(commandString)
                    -- We now have each part of the command in an array, where the first part is the command itself.
                    local possibleCmd = table.remove(parts, 1)
                    local preparedCommand = command[possibleCmd]
                    if preparedCommand == nil then
                        log.Error("Command not supported: ", possibleCmd)
                    else
                        -- Let the command parse the rest of the arguments. If successful, we get back a table with the values as per the options.
                        -- The command-value itself may be empty if it is not mandatory.
                        local data = preparedCommand.cmd.Parse(parts)
                        if data == nil then
                            log.Error("Cannot execute: ", commandString)
                        else
                            if access(possibleCmd) then
                                log.Info("Executing: ", commandString)
                                preparedCommand.exec(data)
                            else
                                log.Error("Not authorized to execute command '", possibleCmd, "'")
                            end
                        end
                    end
                end

                local status, ret = xpcall(exeFunc, traceback, input)
                if not status then
                    log.Error(ret)
                end
            end

            ---Executes the provided command
            ---@param command string
            function s.Exec(command)
                exec(command)
            end

            ---Receiver of input from the lua chat
            ---@param cmdLine CommandLine
            ---@param text string
            function s.inputText(cmdLine, text)
                exec(text)
            end

            singleton = setmetatable(s, CommandLine)

            system:onEvent("onInputText", s.inputText, s)
            return singleton
        end


        return CommandLine


        end)

        package.preload['YFS:../e/lib/src/input/Input.lua']=(function()

        local keys = require('YFS:../e/lib/src/input/Keys.lua')

        local clamp = require('YFS:../e/lib/src/util/Calc.lua').Clamp


        ---@alias InputCallback fun()

        ---@alias CallbackPair {criteria:Criteria, func:InputCallback}


        ---@class Input

        ---@field Instance fun():Input

        ---@field Register fun(key:integer, criteria:Criteria, callback:InputCallback)

        ---@field RegisterMany fun(keys:integer[], criteria:Criteria, callback:InputCallback)

        ---@field IsPressed fun(key:integer):boolean

        ---@field AnyPressed fun(keys:integer[]):boolean

        ---@field KeyState fun():table<integer, boolean>

        ---@field Clear fun()

        ---@field Throttle fun():number

        ---@field SetThrottle fun(value:number)

        ---@field SetThrottleStep fun(value:number)


        local Input = {}

        Input.__index = Input

        local singleton


        ---Returns the Input intance

        ---@return Input

        function Input.Instance()
            if singleton then
                return singleton
            end

            local s = {}
            local lookup = {} ---@type table<Keys, CallbackPair[]>
            local keyState = {} ---@type table<integer, boolean>
            local throttleValue = 0
            local throttleStep = 0.1

            ---Decodes the event
            ---@param keyName string
            ---@param isPressed boolean
            ---@param isRepeat boolean
            function s.decode(keyName, isPressed, isRepeat)
                local key = keys[keyName]
                if key == nil then return end

                keyState[key] = isPressed

                local l = lookup[key]

                if l ~= nil then
                    for _, entry in ipairs(l) do
                        if entry.criteria.Matches(s, isRepeat, isPressed) then
                            entry.func()
                        end
                    end
                end
            end

            local function keyPress(_, key)
                s.decode(key, true, false)
            end

            local function keyRelease(_, key)
                s.decode(key, false, false)
            end

            local function keyRepeat(_, key)
                s.decode(key, true, true)
            end

            local function update()
                throttleValue = clamp(throttleValue + throttleStep * system.getThrottleInputFromMouseWheel(), 0, 1)
            end

            ---Indicates if a key is pressed
            ---@param key Keys
            ---@return boolean
            function s.IsPressed(key)
                return keyState[key] or false
            end

            ---Indicates if any of the keys are pressed
            ---@param keys Keys[]
            ---@return boolean
            function s.AnyPressed(keys)
                for _, k in ipairs(keys) do
                    if s.IsPressed(k) then return true end
                end

                return false
            end

            ---@return table<integer, boolean>
            function s.KeyStates()
                return keyState
            end

            ---Register a function to be triggered when a key is pressed and certain modifiers are set
            ---@param key integer
            ---@param criteria Criteria
            ---@param callback InputCallback
            function s.Register(key, criteria, callback)
                local cbPair = lookup[key]

                if cbPair == nil then
                    cbPair = {}
                    lookup[key] = cbPair
                end

                table.insert(cbPair, { criteria = criteria, func = callback })
            end

            ---Registers multiple keys to the same function
            ---@param keys integer[]
            ---@param critera Criteria
            ---@param callback InputCallback
            function s.RegisterMany(keys, critera, callback)
                for _, v in ipairs(keys) do
                    s.Register(v, critera, callback)
                end
            end

            ---Clears all registered callbacks
            function s.Clear()
                lookup = {}
                keyState = {}
            end

            ---Returns the throttle value, 0...1
            ---@return number
            function s.Throttle()
                return throttleValue
            end

            ---Sets the throttle value 0...1
            ---@param value number
            function s.SetThrottle(value)
                throttleValue = clamp(value, 0, 1)
            end

            ---Sets the throttle step 0...1
            ---@param value number
            function s.SetThrottleStep(value)
                throttleStep = clamp(value, 0.01, 1)
            end

            singleton = setmetatable(s, Input)

            system:onEvent("onActionStart", keyPress)
            system:onEvent("onActionStop", keyRelease)
            system:onEvent("onActionLoop", keyRepeat)
            system:onEvent("onUpdate", update)

            return singleton
        end


        return Input


        end)

        package.preload['YFS:../e/lib/src/util/PubSub.lua']=(function()

        ---@class PubSub

        ---@field RegisterString fun(topic:string, callback:SubStringCallback)

        ---@field RegisterNumber fun(topic:string, callback:SubNumberCallback)

        ---@field RegisterTable fun(topic:string, callback:SubTableCallback)

        ---@field RegisterBool fun(topic:string, callback:SubBooleanCallback)

        ---@field Publish fun(topic:string, value:string|number|table|boolean)

        ---@field Unregister fun(topic:string, callback:SubStringCallback|SubNumberCallback|SubTableCallback|SubBooleanCallback)

        ---@field Instance fun():PubSub


        ---@alias SubStringCallback fun(topic:string, value:string)

        ---@alias SubNumberCallback fun(topic:string, value:number)

        ---@alias SubBooleanCallback fun(topic:string, value:boolean)

        ---@alias SubTableCallback fun(topic:string, value:table)


        local PubSub = {}

        PubSub.__index = PubSub

        local singelton


        ---Gets the instance

        ---@return PubSub

        function PubSub.Instance()
            if singelton then
                return singelton
            end

            local s = {}
            local subscribers = {
                number = {}, ---@type table<string, SubNumberCallback[]>
                string = {}, ---@type table<string, SubStringCallback[]>
                table = {}, ---@type table<string, SubTableCallback[]>
                boolean = {} ---@type table<string, SubBooleanCallback[]>
            }

            ---@param subs table
            ---@param topic string
            ---@param callback SubStringCallback|SubNumberCallback|SubTableCallback|SubBooleanCallback
            local function register(subs, topic, callback)
                local callbacks = subs[topic]
                if not callbacks then
                    callbacks = {}
                    subs[topic] = callbacks
                end

                table.insert(callbacks, callback)
            end

            ---@param topic string
            ---@param callback SubStringCallback|SubNumberCallback|SubTableCallback|SubBooleanCallback
            function s.Unregister(topic, callback)
                for _, topics in pairs(subscribers) do
                    local subs = topics[topic]
                    if subs then
                        for index, sub in ipairs(subs) do
                            if sub == callback then
                                table.remove(subs, index)
                                return
                            end
                        end
                    end
                end
            end

            ---Registers a string callback for the topic
            ---@param topic string
            ---@param callback SubStringCallback
            function s.RegisterString(topic, callback)
                register(subscribers[type("")], topic, callback)
            end

            ---Registers a number callback for the topic
            ---@param topic string
            ---@param callback SubNumberCallback
            function s.RegisterNumber(topic, callback)
                register(subscribers[type(1)], topic, callback)
            end

            ---Registers a table callback for the topic
            ---@param topic string
            ---@param callback SubTableCallback
            function s.RegisterTable(topic, callback)
                register(subscribers[type({})], topic, callback)
            end

            ---Registers a boolean callback for the topic
            ---@param topic string
            ---@param callback SubBooleanCallback
            function s.RegisterBool(topic, callback)
                register(subscribers[type(true)], topic, callback)
            end

            ---Publishes the value on the topic
            ---@param topic string
            ---@param value string|number|table|boolean
            function s.Publish(topic, value)
                local subs = subscribers[type(value)]

                if not subs then return end

                local callbacks = subs[topic]
                if not callbacks then return end

                for _, subscriber in ipairs(callbacks) do
                    subscriber(topic, value)
                end
            end

            singelton = setmetatable(s, PubSub)
            return singelton
        end


        return PubSub


        end)

        package.preload['YFS:flight/Brakes.lua']=(function()

        require('YFS:../e/lib/src/abstraction/Vehicle.lua')

        local calc, nullVec, PID, pub, autoBrakeTimer = require('YFS:../e/lib/src/util/Calc.lua'), require('YFS:../e/lib/src/math/Vec3.lua').New(), require("cpml/pid"),
            require('YFS:../e/lib/src/util/PubSub.lua').Instance(), require('YFS:../e/lib/src/system/Stopwatch.lua').New()
        local Clamp = calc.Clamp

        local max = math.max


        local atmoBrakeCutoffSpeed = calc.Kph2Mps(360) -- Speed limit under which atmospheric brakes become less effective (down to 10m/s [36km/h] where they give 0.1 of max)

        local atmoBrakeEfficiencyFactor = 0.9          -- Kept at 0.9

        local spaceEfficiencyFactor = 0.9              -- Reduced from one to counter brake PID not reacting immediately, thus inducing a delay and subsequent overshoot.


        ---@class Brake

        ---@field Instance fun() Brake

        ---@field Forced fun(enable:boolean)

        ---@field BrakeUpdate fun()

        ---@field BrakeFlush fun()

        ---@field MaxBrakeAcc fun():number

        ---@field GravityInfluencedAvailableDeceleration fun():number

        ---@field MaxSeenGravityInfluencedAvailableAtmoDeceleration fun():number

        ---@field BrakeEfficiency fun(inAtmo:boolean, speed:number):number

        ---@field EffectiveBrakeDeceleration fun():number

        ---@field Feed fun(desiredMovementDir:Vec3, accelerationDir:Vec3, targetSpeed:number)

        ---@field Active fun():boolean

        ---@field SetAutoBrakeAngle fun(angle:number)

        ---@field SetAutoBrakeDelay fun(delay:number)

        ---@field CalcMaxAllowedSpeed fun(distance:number, endSpeed:number, availableBrakeDeceleration:number|nil):number



        local Brake = {}

        Brake.__index = Brake


        local instance


        ---Gets the brake instance

        ---@return Brake

        function Brake.Instance()
            if instance then
                return instance
            end

            local pidHighSpeed = PID(1, 0, 0.01)
            local pidLowSpeed = PID(0.1, 0.0, 1)
            local deceleration = nullVec
            local maxSeenBrakeAtmoAcc = 0
            local _100kmph = calc.Kph2Mps(100)
            local brakeData = { maxDeceleration = 0, currentDeceleration = 0, pid = 0, setAutoBrakeAngle = 0, autoBrakeAngle = 0 } ---@type BrakeData
            local autoBrakeAngle = 45
            local autoBrakeDelay = 1
            local _1kmph = calc.Kph2Mps(1)

            local s = {
                engaged = false,
                forced = false,
                totalMass = TotalMass()
            }

            ---Returns the deceleration the construct is capable of in the given movement.
            ---@return number Deceleration
            local function rawAvailableDeceleration()
                -- F = m * a => a = F / m
                return construct.getMaxBrake() / s.totalMass
            end

            ---@return Vec3
            local function finalDeceleration()
                if s.forced then
                    return -Velocity():Normalize() * rawAvailableDeceleration()
                else
                    return deceleration
                end
            end

            function s.BrakeUpdate()
                s.totalMass = TotalMass()
                local raw = rawAvailableDeceleration()
                brakeData.maxDeceleration = raw
                brakeData.currentDeceleration = construct.getCurrentBrake() / s.totalMass
                if IsInAtmo() then
                    maxSeenBrakeAtmoAcc = max(raw, maxSeenBrakeAtmoAcc)
                end
                brakeData.setAutoBrakeAngle = autoBrakeAngle
                pub.Publish("BrakeData", brakeData)
            end

            ---Enables/disables forced brakes
            ---@param on boolean
            function s.Forced(on)
                s.forced = on
            end

            function s.BrakeFlush()
                -- The brake vector must point against the direction of travel.
                local brakeVector = finalDeceleration()
                unit.setEngineCommand("brake", { brakeVector:Unpack() }, { 0, 0, 0 }, true, true, "", "", "", 0.001)
            end

            ---Gets the available brake deceleration, after taking gravity into account
            ---@return number
            function s.GravityInfluencedAvailableDeceleration()
                local dot = GravityDirection():Dot(Velocity():Normalize())
                local movingTowardsGravityWell = dot > 0
                local influence = calc.Ternary(movingTowardsGravityWell, -1, 1)
                -- Might not be enough brakes to counter gravity so don't go below 0
                return max(0, rawAvailableDeceleration() + influence * dot * G())
            end

            function s.MaxSeenGravityInfluencedAvailableAtmoDeceleration()
                local dot = GravityDirection():Dot(Velocity():Normalize())
                local movingTowardsGravityWell = dot > 0
                local influence = calc.Ternary(movingTowardsGravityWell, -1, 1)
                -- Might not be enough brakes to counter gravity so don't go below 0
                return max(0, maxSeenBrakeAtmoAcc + influence * dot * G())
            end

            ---@param desiredMovementDir Vec3 The direction we want to move
            ---@param accelerationDir Vec3 Current acceleration vector
            ---@param targetSpeed number The desired speed
            function s.Feed(desiredMovementDir, accelerationDir, targetSpeed)
                local movementDir, currentSpeed = Velocity():NormalizeLen()
                local angle = 0

                -- Prefer acceleration over desired movement dir
                if currentSpeed > _1kmph then
                    if not accelerationDir:IsZero() then
                        angle = accelerationDir:AngleToDeg(movementDir)
                    elseif not desiredMovementDir:IsZero() then
                        angle = desiredMovementDir:AngleToDeg(movementDir)
                    end
                end

                if angle > autoBrakeAngle then
                    autoBrakeTimer.Start()
                else
                    autoBrakeTimer.Reset()
                end

                if autoBrakeTimer.Elapsed() > autoBrakeDelay then
                    targetSpeed = 0
                end

                local diff = currentSpeed - targetSpeed -- make PID become positive when we have too high speed.
                pidHighSpeed:inject(diff)
                pidLowSpeed:inject(diff)

                local pid = currentSpeed > _100kmph and pidHighSpeed or pidLowSpeed

                local brakeValue = Clamp(pid:get(), 0, 1)

                if currentSpeed <= targetSpeed then
                    pidHighSpeed:reset()
                    pidLowSpeed:reset()
                    brakeValue = 0
                end

                brakeData.pid = brakeValue
                brakeData.autoBrakeAngle = angle

                deceleration = -movementDir * brakeValue * rawAvailableDeceleration()
            end

            function s.Active()
                return brakeData.pid > 0
            end

            ---Gets the brake efficiency to use
            ---@param inAtmo boolean
            ---@param speed number
            ---@return number
            function s.BrakeEfficiency(inAtmo, speed)
                if not inAtmo then
                    return spaceEfficiencyFactor
                end

                if speed <= atmoBrakeCutoffSpeed then
                    return 0.1
                else
                    return atmoBrakeEfficiencyFactor
                end
            end

            --- Returns the current effective brake deceleration
            ---@return number # The deceleration, a negative value
            function s.EffectiveBrakeDeceleration()
                local currentSpeed = Velocity():Len()
                local inAtmo = IsInAtmo()
                local brakeEfficiency = s.BrakeEfficiency(inAtmo, currentSpeed)

                local atmoDensity = AtmoDensity()
                if atmoDensity > 0 then
                    brakeEfficiency = brakeEfficiency * atmoDensity
                end

                local availableBrakeDeceleration = -s.GravityInfluencedAvailableDeceleration() * brakeEfficiency

                if inAtmo and currentSpeed < calc.Kph2Mps(3) then
                    -- When standing (nearly) still in atmo, assume brakes gives current g of brake acceleration (brake API gives a 0 as response in this case)
                    local maxSeen = s.MaxSeenGravityInfluencedAvailableAtmoDeceleration()
                    availableBrakeDeceleration = -max(maxSeen, G())
                end

                return availableBrakeDeceleration
            end

            --- Calculates the max allowed speed we may have while still being able to decelerate to the endSpeed
            ---@param distance number Remaining distance to target
            ---@param endSpeed number Desired speed when reaching target
            ---@param brakeAcc number|nil Brake acceleration, or nil to use the currently effective deceleration. Remember to pass in a negative number.
            ---@return number
            function s.CalcMaxAllowedSpeed(distance, endSpeed, brakeAcc)
                -- v^2 = v0^2 + 2a*d
                -- v0^2 = v^2 - 2a*d
                -- v0 = sqrt(v^2 - 2ad)

                brakeAcc = brakeAcc or s.EffectiveBrakeDeceleration()

                local v0 = (endSpeed * endSpeed - 2 * brakeAcc * distance) ^ 0.5
                return v0
            end

            ---Gets the max brake acceleration
            ---@return number
            function s.MaxBrakeAcc()
                return rawAvailableDeceleration()
            end

            ---Sets the auto brake angle
            ---@param angle number
            function s.SetAutoBrakeAngle(angle)
                autoBrakeAngle = angle
            end

            ---Sets the auto brake angle
            ---@param delay number
            function s.SetAutoBrakeDelay(delay)
                autoBrakeDelay = delay
            end

            instance = setmetatable(s, Brake)
            return instance
        end


        return Brake


        end)

        package.preload['YFS:../e/lib/src/system/locale.lua']=(function()

        ---@enum

        local locales = {
            "en-US",
            "fr-FR",
            "de-DE"
        }


        ---Returns the index of the local

        ---@return integer

        function LocaleIndex()
            local locale = system.getLocale()
            for index, value in ipairs(locales) do
                if locale == value then
                    return index
                end
            end

            return 1 -- default to en-US
        end


        end)

        package.preload['YFS:../e/lib/src/universe/Body.lua']=(function()

        -- Body - stellar body


        require('YFS:../e/lib/src/system/locale.lua')

        local Vec3 = require('YFS:../e/lib/src/math/Vec3.lua')

        local abs = math.abs


        local max = math.max


        ---@module "Galaxy"


        ---@class Body

        ---@field Galaxy Galaxy The galaxy the body resides in

        ---@field Id number The body ID

        ---@field Name string The name of the body

        ---@field Type string The type of the body

        ---@field Physics { Gravity:number } Physics properties

        ---@field Geography { Center:Vec3, Radius:number} Geography properties

        ---@field Atmosphere {Present:boolean, Thickness:number, Radius:number} Atmosphere properties

        ---@field Surface {MaxAltitude:number, MinAltitude:number}} Surface properties

        ---@field PvP {LocatedInSafeZone:boolean} Pvp properties

        ---@field DistanceToAtmo fun(self:Body, point:Vec3):number

        ---@field DistanceToAtmoEdge fun(self:Body, point:Vec3):number

        ---@field HasAtmo fun():boolean

        ---@field IsInAtmo fun(self:Body, point:Vec3):boolean

        ---@field DistanceToHighestPossibleSurface fun(coordinate:Vec3):number

        ---@field AboveSeaLevel fun(coordinate:Vec3):boolean, number


        local Body = {}

        Body.__index = Body


        ---@param galaxy table

        ---@param bodyData table

        ---@return Body

        function Body.New(galaxy, bodyData)
            local language = LocaleIndex()

            local s = {
                ---@type Body
                Galaxy = galaxy,
                Id = bodyData.id,
                Name = bodyData.name[language],
                Type = bodyData.type[language],
                Physics = {
                    Gravity = bodyData.gravity
                },
                Geography = {
                    Center = Vec3.New(bodyData.center),
                    Radius = bodyData.radius -- This is the water level, i.e. 0 elevation
                },
                Atmosphere = {
                    Present = bodyData.hasAtmosphere,
                    Thickness = bodyData.atmosphereThickness,
                    Radius = bodyData.atmosphereRadius
                },
                Surface = {
                    MaxAltitude = bodyData.surfaceMaxAltitude,
                    MinAltitude = bodyData.surfaceMinAltitude
                },
                Pvp = {
                    LocatedInSafeZone = bodyData.isInSafeZone
                }
            }

            function Body.__tostring(instance)
                return instance.Name
            end

            ---Returns the distance between the given position and the atmosphere of the body, 0 if already in atmosphere of the body
            ---@param coordinate Vec3
            ---@return number
            function s:DistanceToAtmo(coordinate)
                return max(0, (coordinate - s.Geography.Center):Len() - s.Atmosphere.Radius)
            end

            ---Returns the distance to the edge of the atmosphere, from the given position
            ---@param coordinate Vec3
            function s:DistanceToAtmoEdge(coordinate)
                local dist = s:DistanceToAtmo(coordinate)
                if dist == 0 then
                    -- Inside atmo
                    return s.Atmosphere.Radius - (coordinate - s.Geography.Center):Len()
                end

                return dist
            end

            ---Returns true if the coordinate is within the atmosphere of the body
            ---@param coordinate any
            ---@return boolean
            function s:IsInAtmo(coordinate)
                return s:DistanceToAtmo(coordinate) == 0
            end

            ---Returns true if the body has an atmosphere
            ---@return boolean
            function s:HasAtmo()
                return s.Atmosphere.Radius > 0
            end

            ---Returns the distance to the highest possible point on the body or 0 if below higest surface
            ---@param coordinate Vec3
            ---@return number
            function s.DistanceToHighestPossibleSurface(coordinate)
                return max(0, (coordinate - s.Geography.Center):Len() - s.Geography.Radius - s.Surface.MaxAltitude)
            end

            ---Returns a boolean indicating if the coordinate is above sea level and a number representing the absolute distance to the sea level
            ---@param coordinate Vec3 The coordinate to get info on.
            ---@return boolean, number
            function s.AboveSeaLevel(coordinate)
                local seaLevel = s.Geography.Radius
                local distanceToCenter = (coordinate - s.Geography.Center):Len()
                return distanceToCenter >= seaLevel, abs(distanceToCenter - seaLevel)
            end

            return setmetatable(s, Body)
        end


        return Body


        end)

        package.preload['YFS:../e/lib/src/universe/Galaxy.lua']=(function()

        -- galaxy - utility class to manage the in-game atlas


        local Body = require('YFS:../e/lib/src/universe/Body.lua')

        local calc = require('YFS:../e/lib/src/util/Calc.lua')

        local max = math.max


        ---@class Galaxy

        ---@field New fun(galaxyId:integer, galaxyAtlas:table):Galaxy

        ---@field BodyById fun(self:Galaxy, id:integer):Body Gets a body by the id

        ---@field GetBodyClosestToPosition fun(self:Galaxy, position:Vec3):Body Gets the body closes to the position

        ---@field BodiesInPath fun(self:Galaxy, path:Ray):Body[] Returns the bodies with which the ray intersects (including atmosphere), sorted by distance, closest first.

        ---@field Id integer The id of the galaxy


        local Galaxy = {}

        Galaxy.__index = Galaxy


        ---Creates a new Galaxy

        ---@param galaxyId integer The id of the galaxy

        ---@param galaxyAtlas table The lookup table from the in-game atlas.

        ---@return Galaxy

        function Galaxy.New(galaxyId, galaxyAtlas)
            local s = {
                Id = galaxyId
            }

            local body = {} ---@type Body[] -- Stellar bodies by id

            for bodyId, bodyData in pairs(galaxyAtlas) do
                body[bodyId] = Body.New(s, bodyData)
            end

            function s:BodyById(id)
                return body[id]
            end

            ---Gets the body closest to the given position
            ---@param position Vec3 position to get closest body for
            ---@return Body The body
            function s:GetBodyClosestToPosition(position)
                local closest
                local smallestDistance

                for _, b in pairs(body) do
                    local dist = (b.Geography.Center - position):Len()
                    if smallestDistance == nil or dist < smallestDistance then
                        smallestDistance = dist
                        closest = b
                    end
                end

                return closest
            end

            --- Gets the bodies the path intersects, sorted by distance, closest first.
            ---@param ray Ray The ray to check for intersecting bodies
            ---@return table A list of bodies that the path intersects
            function s:BodiesInPath(ray)
                local res = {}

                local sortFunc = function(a, b)
                    return (a.Geography.Center - ray.Start):Len2() < (b.Geography.Center - ray.Start):Len2()
                end

                for _, b in pairs(body) do
                    -- If no atmosphere, then use physical body
                    local radius = max(b.Geography.Radius, b.Atmosphere.Radius)
                    local intersects, _, _ = calc.LineIntersectSphere(ray, b.Geography.Center, radius)

                    if intersects then
                        table.insert(res, b)
                    end
                end

                table.sort(res, sortFunc)

                return res
            end

            return setmetatable(s, Galaxy)
        end


        return Galaxy


        end)

        package.preload['YFS:../e/lib/src/universe/Position.lua']=(function()

        ---Represents a position in the universe.


        local stringFormat = string.format


        ---@class Position

        ---@field New fun(galaxy:integer, bodyRef:Body, x:integer, y:integer, z:integer):Position Creates a new Position

        ---@field AsPosString fun():string returns a ::pos{} string

        ---@field Coordinates fun():Vec3 returns the coordinates


        local Position = {}

        Position.__index = Position


        ---Creates a new position from the galaxy, body and x,y and z coordinates

        ---@param galaxy Galaxy The Galaxy the position belongs in

        ---@param bodyRef Body The closest body

        ---@param coordinate Vec3 World coordinates

        ---@return Position

        function Position.New(galaxy, bodyRef, coordinate)
            local s = {
                Body = bodyRef,
                Galaxy = galaxy,
                Coords = coordinate
            }

            function s.AsPosString()
                return tostring(s)
            end

            ---Returns the coordinates of the position
            ---@return Vec3
            function s.Coordinates()
                return s.Coords
            end

            function Position.__tostring(p) -- __tostring must be in the metatable, not the instance
                -- The game starts giving space coordinates at an altitude of 70km above
                -- the planets radius on Alioth so we're mimicing that behaviour.
                local altitude = (p.Coords - p.Body.Geography.Center):Len() - p.Body.Geography.Radius
                if altitude < p.Body.Geography.Radius + 70000 then
                    -- Use a radius that includes the altitude
                    local radius = p.Body.Geography.Radius + altitude
                    -- Calculate around origo; planet center is added in Universe:ParsePosition
                    -- and we're reversing that calculation.
                    local calcPos = p.Coords - p.Body.Geography.Center

                    local lat = 0
                    local lon = 0

                    -- When the input coordinates are the same as the center of the planet, trigonomitry fails so just leave them at 0.
                    if calcPos:Len2() > 0 then
                        lat = math.asin(calcPos.z / radius)
                        lon = math.atan(calcPos.y, calcPos.x)
                    end

                    return stringFormat("::pos{%d,%d,%.4f,%.4f,%.4f}", p.Galaxy.Id, p.Body.Id, math.deg(lat), math.deg(lon),
                        altitude)
                else
                    return stringFormat("::pos{%d,0,%.4f,%.4f,%.4f}", p.Galaxy.Id, p.Coords.x, p.Coords.y, p.Coords.z)
                end
            end

            return setmetatable(s, Position)
        end


        return Position


        --[[

        ---Calculates the distance 'as the crow flies' to the other position

        ---using the haversine formula

        ---@param other Position The position to calculate the distance to.

        function position:DistanceAtHeight(other)
            -- http://www.movable-type.co.uk/scripts/latlong.html
            if self.Body.Id == other.Body.Id then

            else

            end

            return nil
        end

        ]]


        end)

        package.preload['YFS:../e/lib/src/universe/Universe.lua']=(function()

        -- Universe - utility class to manage the in-game atlas

        local log = require('YFS:../e/lib/src/debug/Log.lua').Instance()

        local Galaxy = require('YFS:../e/lib/src/universe/Galaxy.lua')

        local Position = require('YFS:../e/lib/src/universe/Position.lua')

        local Vec3 = require('YFS:../e/lib/src/math/Vec3.lua')

        local cos = math.cos

        local sin = math.sin


        local stringMatch = string.match

        local numberPattern = " *([+-]?%d+%.?%d*e?[+-]?%d*)"

        local posPattern = "::pos{" ..
            numberPattern .. "," .. numberPattern .. "," .. numberPattern .. "," .. numberPattern .. "," .. numberPattern .. "}"

        ---@class Universe

        ---@field Instance fun():Universe

        ---@field CurrentGalaxyId fun():integer Gets the current galaxy id

        ---@field CurrentGalaxy fun():Galaxy Gets the current galaxy

        ---@field ParsePosition fun(pos:string):Position|nil Parses the ::pos{} string and returns a Position or nil.

        ---@field CreatePos fun(coordinate:Vec3):Position

        ---@field ClosestBody fun(scoordinate:Vec3):Body Returns the closest body to the given coordinate

        ---@field VerticalReferenceVector fun():Vec3

        local Universe = {}

        Universe.__index = Universe


        local singleton = nil


        function Universe.Instance()
            if singleton then
                return singleton
            end

            local galaxy = {} -- Galaxies by id
            local core = library.getCoreUnit()

            local s = {}

            local duAtlas = require("atlas")

            if type(duAtlas) ~= "table" then
                error("Invalid atlas")
                unit.exit()
            end

            for galaxyId, galaxyData in pairs(duAtlas) do
                galaxy[galaxyId] = Galaxy.New(galaxyId, galaxyData)
            end

            ---Gets the current galaxy id
            ---@return number The id of the current galaxy
            function s.CurrentGalaxyId()
                return 0 -- Until there are more than one galaxy in the game.
            end

            ---Gets the current galaxy
            ---@return Galaxy The current galaxy
            function s.CurrentGalaxy()
                return galaxy[s.CurrentGalaxyId()]
            end

            ---Parses a position string
            ---@param pos string The "::pos{...}" string
            ---@return Position|nil A position in space or on a planet
            function s.ParsePosition(pos)
                local x, y, z, bodyRef
                local galaxyId, bodyId, latitude, longitude, altitude = stringMatch(pos, posPattern)

                if galaxyId ~= nil then
                    galaxyId = tonumber(galaxyId)
                    bodyId = tonumber(bodyId)

                    --[[Positions in space, such as asteroids have no bodyId id. In this case
                    latitude, longitude, altitude are x, y, z in meters.

                    In either case, the closest stellar body is set as the positions body.
                    ]]
                    if bodyId == 0 then
                        x = tonumber(latitude)
                        y = tonumber(longitude)
                        z = tonumber(altitude)
                        local coordinate = Vec3.New(x, y, z)
                        bodyRef = s.CurrentGalaxy():GetBodyClosestToPosition(coordinate)
                        return Position.New(galaxy[galaxyId], bodyRef, coordinate)
                    else
                        -- https://stackoverflow.com/questions/1185408/converting-from-longitude-latitude-to-cartesian-coordinates
                        -- The x-axis goes through long,lat (0,0), so longitude 0 meets the equator
                        -- The y-axis goes through (0,90)
                        -- and the z-axis goes through the poles.
                        -- Positions on a body have lat, long in degrees and altitude in meters
                        latitude = math.rad(latitude)
                        longitude = math.rad(longitude)
                        local body = galaxy[galaxyId]:BodyById(bodyId)

                        local radius = body.Geography.Radius + altitude
                        local cosLat = cos(latitude)
                        local position = Vec3.New(radius * cosLat * cos(longitude), radius * cosLat * sin(longitude),
                            radius * sin(latitude))
                        position = position + body.Geography.Center

                        return Position.New(galaxy[galaxyId], body, position)
                    end
                end

                log.Error("Invalid position string: ", pos)

                return nil
            end

            ---comment Creates a :Position from the given coordinate, within the current galaxy.
            ---@param coordinate Vec3 The coordinate to create the position for
            ---@return Position
            function s.CreatePos(coordinate)
                local closestBody = s.ClosestBody(coordinate)
                local p = Position.New(s.CurrentGalaxy(), closestBody, coordinate)
                return p
            end

            --- Gets the information for the closest stellar body
            ---@param coordinate Vec3 The coordinate to get the closest body for
            ---@return Body #The Body
            function s.ClosestBody(coordinate)
                local g = s.CurrentGalaxy()
                return g:GetBodyClosestToPosition(coordinate)
            end

            ---Returns a unit vector pointing towards the center of the closest 'gravity well', i.e. planet or space construct.
            --- @return Vec3
            function s.VerticalReferenceVector()
                local worldGrav = Vec3.New(core.getWorldGravity())
                local wDir, wLen = worldGrav:NormalizeLen()
                if wLen == 0 then
                    local position = Vec3.New(construct.getWorldPosition())
                    local body = s.ClosestBody(position)
                    return (body.Geography.Center - position):Normalize()
                else
                    return wDir
                end
            end

            singleton = setmetatable(s, Universe)
            return singleton
        end


        return Universe


        end)

        package.preload['YFS:controller/GateControl.lua']=(function()

        local pub, log, Stopwatch = require('YFS:../e/lib/src/util/PubSub.lua').Instance(), require('YFS:../e/lib/src/debug/Log.lua').Instance(),
            require('YFS:../e/lib/src/system/Stopwatch.lua')

        ---@class GateControl

        ---@field Instance fun():GateControl

        ---@field Open fun()

        ---@field Close fun()

        ---@field Enabled fun():boolean

        ---@field Enable fun(on:boolean)


        local GateControl         = {}

        GateControl.__index       = {}


        local instance


        function GateControl.Instance()
            if instance then return instance end

            local s = {}
            local wantsOpen = false
            local enabled = true
            local timer = Stopwatch.New()
            local followGate = library.getLinkByName("FollowGate") ---@type any

            if followGate and (type(followGate.activate) ~= "function" or type(followGate.deactivate) ~= "function") then
                followGate = nil
            end

            if followGate then
                log.Info("Found FollowGate switch")
            end

            ---@param topic string
            ---@param data {state:string}
            local function onData(topic, data)
                if data.state == wantsOpen then
                    timer.Stop()
                    log.Info("Gates reported in desired state")
                end
            end

            local function activate(open)
                wantsOpen = open
                timer.Restart()
            end

            function s.Open()
                activate(true)
            end

            function s.Close()
                activate(false)
            end

            function s.Enable(on)
                enabled = on
            end

            function s.Enabled()
                return enabled
            end

            function s.AreInDesiredState()
                -- When timer no longer is running, gates are in the expected state. (Assuming Open or Closed has been called.)
                return not enabled or not timer.IsRunning()
            end

            instance = setmetatable(s, GateControl)
            pub.RegisterTable("RecData-GateControl", onData)

            system:onEvent("onUpdate", function()
                if enabled and timer.IsRunning() and timer.Elapsed() > 0.5 then
                    timer.Restart()
                    pub.Publish("SendData",
                        { topic = "GateControl", data = { desiredState = wantsOpen } })

                    if followGate then
                        if wantsOpen then
                            followGate.activate()
                        else
                            followGate.deactivate()
                        end
                    end
                end
            end)

            return instance
        end


        return GateControl


        end)

        package.preload['YFS:../e/lib/src/element/Radar.lua']=(function()

        local log = require('YFS:../e/lib/src/debug/Log.lua').Instance()


        ---@class RadarControl

        ---@field Instance fun():RadarControl

        ---@field Show fun(on:boolean)

        ---@field Sort fun(method:integer)

        ---@field IsVisible fun():boolean

        ---@field NextMethod fun()


        local RadarControl = {}

        RadarControl.__index = RadarControl



        ---@enum RadaraState

        RadarState = {
            Operational = 1,
            Broken = 0,
            BadEnvironment = -1,
            Obstructed = -2,
            AlreadyInUse = -3
        }


        local radarSortMethod = {
            "Distance acending",
            "Distance descending",
            "Size ascending",
            "Size descending",
            "Threat ascending",
            "Threat descending"
        }


        local radarSortCount = TableLen(radarSortMethod)


        local atmoRadars = { "RadarPvPAtmospheric" }

        local spaceRadars = { "RadarPVPSpaceSmallGroup", "RadarPVPSpaceMediumGroup", "RadarPVPSpaceLargeGroup" }


        ---@param names string[]

        ---@return Radar

        local function getRadar(names)
            local r = nil
            for _, n in ipairs(names) do
                r = r or library.getLinkByClass(n)
            end

            return r
        end


        local instance ---@type RadarControl


        ---@return RadarControl

        function RadarControl.Instance()
            if instance then return instance end

            local s = {}
            local showRadar = false
            local sortMethod = 1

            ---@type Radar[]
            local radars = { getRadar(atmoRadars), getRadar(spaceRadars) }

            local count = radars[1] ~= nil and 1 or 0
            count = count + (radars[2] ~= nil and 1 or 0)

            local function update()
                for _, r in ipairs(radars) do
                    if r then
                        if not showRadar or r.getOperationalState() == RadarState.BadEnvironment then
                            r.hideWidget()
                        else
                            r.showWidget()
                        end
                    end
                end
            end

            ---@param on boolean
            function s.Show(on)
                showRadar = on
                log.Info("Radar ", on and "shown" or "hidden")
                if on then
                    s.Sort(sortMethod)
                end
            end

            ---@return boolean
            function s.IsVisible()
                return showRadar
            end

            function s.NextMethod()
                local next = (sortMethod + 1) % (radarSortCount + 1)
                if next == 0 then
                    next = 1
                end
                s.Sort(next)
            end

            ---@param method integer
            function s.Sort(method)
                sortMethod = method
                for _, r in ipairs(radars) do
                    if r and r.getSortMethod() ~= radars then
                        if r.setSortMethod(sortMethod) then
                            log.Error("Sort method set to ", radarSortMethod[sortMethod])
                        end
                    end
                end
            end

            system:onEvent("onUpdate", update)

            instance = setmetatable(s, RadarControl)
            return instance
        end


        return RadarControl


        end)

        package.preload['YFS:../e/lib/src/element/Telemeter.lua']=(function()

        local Vec3 = require('YFS:../e/lib/src/math/Vec3.lua')


        ---@alias TelemeterVec3 {x:number, y:number, z:number}

        ---@alias TelemeterData {hit:boolean, distance:number, point:TelemeterVec3}

        ---@alias TeleRaycast fun():TelemeterData

        ---@alias TeleDist fun():number

        ---@alias TeleWorldAxis fun():TelemeterVec3

        ---@alias TelementerAPI {raycast:TeleRaycast, getMaxDistance:TeleDist, getRayWorldAxis:TeleWorldAxis, getRayWorldOrigin:TeleWorldAxis}

        ---@alias TelemeterResult {Hit:boolean, Distance:number, Point:Vec3}


        ---@class Telemeter

        ---@field New fun(telemeter:TelementerAPI):Telemeter

        ---@field Measure fun():TelemeterResult

        ---@field IsTelemeter fun():boolean

        ---@field MaxDistance fun():number


        local Telemeter = {}

        Telemeter.__index = Telemeter


        ---Create a new Telemeter

        ---@param api TelementerAPI

        ---@return Telemeter

        function Telemeter.New(api)
            local s = {}

            ---Measure distance
            ---@return TelemeterResult
            function s.Measure()
                local res = api.raycast()
                return { Hit = res.hit, Point = Vec3.New(res.point), Distance = res.distance }
            end

            ---Checks if the link has the expected functions
            ---@return boolean
            function s.IsTelemeter()
                return type(api.getMaxDistance) == "function"
                    and type(api.raycast) == "function"
                    and type(api.getRayWorldOrigin) == "function"
            end

            ---Gets the max measure distance
            ---@return number
            function s.MaxDistance()
                return api.getMaxDistance()
            end

            return setmetatable(s, Telemeter)
        end


        return Telemeter


        end)

        package.preload['YFS:controller/FloorDetector.lua']=(function()

        local Telemeter, log, Vec3 = require('YFS:../e/lib/src/element/Telemeter.lua'), require('YFS:../e/lib/src/debug/Log.lua').Instance(), require('YFS:../e/lib/src/math/Vec3.lua')


        ---@class FloorDetector

        ---@field Instance fun():FloorDetector

        ---@field Measure fun():TelemeterResult

        ---@field Present fun():boolean

        ---@field MaxDist fun():number

        ---@field IsWithinShutdownDistance fun():boolean

        ---@field IsParkingEnabled fun():boolean

        ---@field ReturningHome fun()

        ---@field IsReturningHome fun():boolean


        local FloorDetector        = {}

        FloorDetector.__index      = FloorDetector


        local inst

        local floorDetectorName    = "FloorDetector"


        ---@return FloorDetector

        function FloorDetector.Instance()
            if inst then return inst end

            inst = {}
            local enabled = false

            local teleLink = library.getLinkByName(floorDetectorName)
            local tele ---@type Telemeter|nil

            if teleLink then
                tele = Telemeter.New(teleLink)
                if not tele.IsTelemeter() then
                    tele = nil
                end
            else
                log.Error("No telementer by name '", floorDetectorName, "' found")
            end

            function inst.Present()
                return tele ~= nil
            end

            ---@return TelemeterResult
            function inst.Measure()
                if tele then
                    return tele.Measure()
                else
                    return { Hit = false, Distance = 0, Point = Vec3.zero }
                end
            end

            ---@return number #Max distance or 0
            function inst.MaxDist()
                return tele and tele.MaxDistance() or 0
            end

            return setmetatable(inst, FloorDetector)
        end


        return FloorDetector


        end)

        package.preload['YFS:../e/lib/src/system/Timer.lua']=(function()

        ---@class Timer Handles function registration/deregistration of tick functions

        ---@field Instance fun():Timer Returns the singleton instance

        ---@field Add fun(id:string, func:function, interval:number) Adds a timer with the given interval and callback function.

        ---@field Remove fun(id:string) Removes a timer with the given id.

        local Timer = {}

        Timer.__index = Timer


        local singleton ---@type Timer


        ---Returns a Timer instance

        ---@return Timer

        function Timer.Instance()
            if singleton then
                return singleton
            end

            local s = {}
            local functions = {}
            local toRemove = {} ---@type string[]
            local toAdd = {} ---@type {id:string, f:fun(), interval:number}

            function s.Add(id, func, interval)
                s.Remove(id)
                toAdd[#toAdd + 1] = { id = id, f = func, interval = interval }
                functions[id] = func
            end

            function s.Remove(id)
                if functions[id] ~= nil then
                    toRemove[#toRemove + 1] = id
                    functions[id] = nil
                end
            end

            ---@param tickId any
            local function run(tickId)
                local f = functions[tickId]
                if f ~= nil then
                    f()
                end
            end

            -- Can't call unit.stopTimer/startTimer from flush so to anbled that possibility,
            -- we do it via the update event. The timers are based on framerate anyhow so the
            -- delay this induces is of no consequence.
            system:onEvent("onUpdate", function()
                while #toRemove > 0 do
                    unit.stopTimer(table.remove(toRemove, 1))
                end
                while #toAdd > 0 do
                    local add = table.remove(toAdd, 1)
                    unit.setTimer(add.id, add.interval)
                end
            end)

            -- Register with du-luac event handler
            unit:onEvent("onTimer", function(unit, id)
                run(id)
            end)

            singleton = setmetatable(s, Timer)
            return singleton
        end


        return Timer


        end)

        package.preload['YFS:Singletons.lua']=(function()

        local s = {
            constants     = require('YFS:YFSConstants.lua'),
            log           = require('YFS:../e/lib/src/debug/Log.lua').Instance(),
            strUtil       = require('YFS:../e/lib/src/util/StringUtil.lua'),
            commandLine   = require('YFS:../e/lib/src/commandline/CommandLine.lua').Instance(),
            input         = require('YFS:../e/lib/src/input/Input.lua').Instance(),
            pub           = require('YFS:../e/lib/src/util/PubSub.lua').Instance(),
            calc          = require('YFS:../e/lib/src/util/Calc.lua'),
            brakes        = require('YFS:flight/Brakes.lua').Instance(),
            universe      = require('YFS:../e/lib/src/universe/Universe.lua').Instance(),
            keys          = require('YFS:../e/lib/src/input/Keys.lua'),
            gateCtrl      = require('YFS:controller/GateControl.lua').Instance(),
            radar         = require('YFS:../e/lib/src/element/Radar.lua').Instance(),
            floorDetector = require('YFS:controller/FloorDetector.lua').Instance(),
            timer         = require('YFS:../e/lib/src/system/Timer.lua').Instance()
        }


        return s


        end)

        package.preload['YFS:../e/lib/src/math/Plane.lua']=(function()

        require('YFS:../e/lib/src/abstraction/Vehicle.lua')

        local universe = require('YFS:../e/lib/src/universe/Universe.lua').Instance()


        ---@alias Fun3 fun():Vec3


        ---@class Plane

        ---@field Up fun():Vec3

        ---@field Right fun():Vec3

        ---@field Forward fun():Vec3

        ---@field NewByVertialReference fun():Plane

        ---@field New fun(f:Fun3):Plane


        local Plane = {}

        Plane.__index = Plane


        ---comment

        ---@param verticalFunc fun():Vec3

        ---@return Plane

        function Plane.New(verticalFunc)
            local s = {}
            local constructRight = Right

            s.Up = verticalFunc

            function s.Forward()
                return s.Up():Cross(constructRight())
            end

            function s.Right()
                -- Forward x Up instead of Up x Forward to get right instead of left dir
                return s.Forward():Cross(s.Up())
            end

            return setmetatable(s, Plane)
        end


        function Plane.NewByVertialReference()
            return Plane.New(function() return -universe.VerticalReferenceVector() end)
        end


        return Plane


        end)

        package.preload['YFS:flight/Waypoint.lua']=(function()

        require('YFS:../e/lib/src/abstraction/Vehicle.lua')

        local si                                = require('YFS:Singletons.lua')

        local Plane                             = require('YFS:../e/lib/src/math/Plane.lua')

        local calc, universe                    = si.calc, si.universe

        local Ternary, max, abs, BetweenOrEqual = calc.Ternary, math.max, math.abs, calc.BetweenOrEqual


        ---@enum WPReachMode

        WPReachMode                             = {
            ENTRY = 1,
            EXIT = 2
        }


        ---@class Waypoint

        ---@field New fun(destination:Vec3, finalSpeed:number, maxSpeed:number, margin:number):Waypoint

        ---@field Destination fun():Vec3

        ---@field DirectionMargin number

        ---@field DirectionTo fun():Vec3

        ---@field DistanceTo fun():number

        ---@field FinalSpeed fun():number

        ---@field IsLastInRoute fun():boolean

        ---@field IsYawLocked fun():boolean

        ---@field LockYawTo fun(direction:Vec3|nil, forced:boolean?)

        ---@field Margin fun():number

        ---@field MaxSpeed fun():number

        ---@field Pitch fun(prev:Waypoint):Vec3|nil

        ---@field Roll fun(prev:Waypoint):Vec3|nil

        ---@field SetAlignmentAngleLimit fun(limit:number)

        ---@field SetAlignmentDistanceLimit fun(limit:number)

        ---@field SetPitchAlignmentThrustLimiter fun(angle:number)

        ---@field SetLastInRoute fun(lastInRoute:boolean)

        ---@field WithinMargin fun(mode:WPReachMode):boolean

        ---@field Yaw fun(prev:Waypoint):Vec3|nil

        ---@field LockedYawDirection fun():Vec3|nil

        ---@field ForceUpAlongVerticalRef fun()

        ---@field PathAlignmentDistanceLimitFromSurface fun():number

        ---@field PreCalc fun(prev:Waypoint)

        ---@field SetAutoPitch fun(enabled:boolean)



        local Waypoint = {}

        Waypoint.__index = Waypoint


        -- Return a direction target point this far from the waypoint so that in case we overshoot

        -- we don't get the point behind us and start turning around and also reduces oscilliating yaw.

        local directionMargin = 1000

        Waypoint.DirectionMargin = directionMargin

        local pathAlignmentAngleLimit, pathAlignmentDistanceLimit, pitchAlignmentThrustLimiter, autoPitch, gravPlane =
            0, 0, 0, false, Plane.NewByVertialReference()

        ---@param angle number

        function Waypoint.SetAlignmentAngleLimit(angle)
            pathAlignmentAngleLimit = max(0, angle)
        end


        ---@param distance number

        function Waypoint.SetAlignmentDistanceLimit(distance)
            pathAlignmentDistanceLimit = max(0, distance)
        end


        function Waypoint.SetPitchAlignmentThrustLimiter(angle)
            pitchAlignmentThrustLimiter = angle
        end


        function Waypoint.SetAutoPitch(enable)
            autoPitch = enable
        end


        ---Creates a new Waypoint

        ---@param destination Vec3 The destination

        ---@param finalSpeed number The final speed to reach when at the waypoint (0 if stopping is intended).

        ---@param maxSpeed number The maximum speed to to travel at. Less than or equal to finalSpeed.

        ---@param margin number The number of meters to be within for the waypoint to be considered reached

        ---@param pathAlignmentDistanceLimitFromSurface number The minimum distance to the closest body where the construct will align topside along the path

        ---@return Waypoint

        function Waypoint.New(destination, finalSpeed, maxSpeed, margin, pathAlignmentDistanceLimitFromSurface)
            maxSpeed = Ternary(finalSpeed > maxSpeed and maxSpeed > 0, finalSpeed, maxSpeed) -- Guard against bad settings.
            local yawLockDir = nil ---@type Vec3|nil
            local lastInRoute, forceUpAlongVerticalRef, currentUp, useAutoPitch = false, false, Vec3.zero, autoPitch
            local upPlane = Plane.New(function()
                return currentUp
            end)
            local s = {}

            ---Gets the vertical up reference to use
            ---@param prev Waypoint Previous waypoint
            ---@return Vec3
            local function getCurrentUp(prev)
                -- When next waypoint is nearly aligned with -gravity, use the line between them as the vertical reference instead to make following the path more exact.
                local gravUp = gravPlane.Up()

                if forceUpAlongVerticalRef then
                    return gravUp
                end

                local selectedRef = gravUp

                local pathDirection = (destination - prev.Destination()):Normalize()
                local body = universe.ClosestBody(Current())
                local distanceToSurface = body.DistanceToHighestPossibleSurface(Current())
                local awayFromWaypoints = s.DistanceTo() > pathAlignmentDistanceLimit and
                    prev.DistanceTo() > pathAlignmentDistanceLimit

                if awayFromWaypoints then
                    local farOut = pathAlignmentDistanceLimitFromSurface > 0
                        and distanceToSurface > pathAlignmentDistanceLimitFromSurface

                    if farOut then
                        -- We're far out from the nearest body, allow aligning topside along path, even upside down
                        selectedRef = pathDirection
                        -- Disable auto pitch when tilting along the path
                        useAutoPitch = false
                    elseif pathAlignmentAngleLimit > 0 then           -- if zero, it means the alignment is disabled
                        local sameDir = gravUp:Dot(pathDirection) > 0 -- Same direction?
                        if sameDir and gravUp:AngleToDeg(pathDirection) < pathAlignmentAngleLimit then
                            -- If we're more aligned to the path than the threshold, then align to the path
                            selectedRef = pathDirection
                        elseif not sameDir and gravUp:AngleToDeg(-pathDirection) < pathAlignmentAngleLimit then
                            -- Don't flip upside down
                            selectedRef = -pathDirection
                        end
                    end
                end


                return selectedRef
            end

            ---Gets the destination
            ---@return Vec3
            function s.Destination()
                return destination
            end

            ---Gets the final speed for the waypoint
            ---@return number
            function s.FinalSpeed()
                return finalSpeed
            end

            ---Gets the max speed for the waypoint
            ---@return number
            function s.MaxSpeed()
                return maxSpeed
            end

            ---Gets the margin for the waypoint
            ---@return number
            function s.Margin()
                return margin
            end

            ---Indicates if the waypoint has been reached.
            ---@param mode WPReachMode
            ---@return boolean
            function s.WithinMargin(mode)
                local m = margin

                if mode == WPReachMode.ENTRY then
                    if m > 1 then
                        m = m / 2
                    end
                end

                return s.DistanceTo() <= m
            end

            ---Gets the distance to the waypoint
            ---@return number
            function s.DistanceTo()
                return (destination - Current()):Len()
            end

            ---Gets the direction to the waypoint
            ---@return Vec3
            function s.DirectionTo()
                return (destination - Current()):NormalizeInPlace()
            end

            function s.SetLastInRoute(last)
                lastInRoute = last
            end

            function s.IsLastInRoute()
                return lastInRoute
            end

            function s.PathAlignmentDistanceLimitFromSurface()
                return pathAlignmentDistanceLimitFromSurface
            end

            ---Locks the yaw direction to the given direction
            ---@param direction Vec3|nil
            ---@param forced boolean? If true, existing locks are overridden
            function s.LockYawTo(direction, forced)
                forced = forced or false
                if yawLockDir == nil or forced then
                    yawLockDir = direction
                end
            end

            function s.IsYawLocked()
                return yawLockDir ~= nil
            end

            function s.LockedYawDirection()
                return yawLockDir
            end

            ---@param prev Waypoint
            function s.PreCalc(prev)
                currentUp = getCurrentUp(prev)
            end

            function s.ForceUpAlongVerticalRef()
                forceUpAlongVerticalRef = true
            end

            local function pitchKeepOrtogonalToUp()
                return calc.ProjectPointOnPlane(upPlane.Right(), Current(), Current() + upPlane.Forward() * directionMargin)
            end

            ---@param prev Waypoint
            ---@return Vec3|nil
            function s.Roll(prev)
                return calc.ProjectPointOnPlane(upPlane.Forward(), Current(), Current() + upPlane.Up() * directionMargin)
            end

            ---@param prev Waypoint
            ---@return Vec3|nil
            function s.Pitch(prev)
                if useAutoPitch then
                    local moveDir, forward = Velocity():Normalize(), upPlane.Forward()

                    if s.DistanceTo() > 10 and Velocity():Len() > calc.Kph2Mps(50)
                        and BetweenOrEqual(moveDir:AngleToDeg(gravPlane.Up()), 40, 140) -- Prevent flipping backwards
                        -- Not going vertically
                        and BetweenOrEqual(gravPlane.Up():AngleToDeg(s.DirectionTo()), 15, 180 - 15)
                        -- Not reversing or strafing
                        and BetweenOrEqual(forward:AngleToDeg(s.DirectionTo()), 0, 75)
                    then
                        return Current() + moveDir * directionMargin
                    end
                end

                return pitchKeepOrtogonalToUp()
            end

            ---@param prev Waypoint
            ---@return Vec3|nil
            function s.Yaw(prev)
                local dir

                if yawLockDir then
                    dir = yawLockDir
                elseif s.DistanceTo() > 50 then
                    -- Point towards the next point. Use the previous point as a reference when we get close to prevent spinning.
                    dir = s.DirectionTo()
                else
                    dir = s.Destination() - prev.Destination()
                    dir:NormalizeInPlace()
                end

                -- To prevent spinning, lock yaw if we're aligning to vertical up
                if not yawLockDir and abs(dir:Dot(currentUp)) > 0.9 then
                    s.LockYawTo(Forward(), false)
                    dir = Forward()
                end

                return calc.ProjectPointOnPlane(currentUp, Current(), Current() + dir * directionMargin)
            end

            return setmetatable(s, Waypoint)
        end


        return Waypoint


        end)

        package.preload['YFS:GlobalTypes.lua']=(function()

        Criteria     = require('YFS:../e/lib/src/input/Criteria.lua')

        Vec3         = require('YFS:../e/lib/src/math/Vec3.lua')

        Task         = require('YFS:../e/lib/src/system/Task.lua')

        Point        = require('YFS:flight/route/Point.lua')

        PointOptions = require('YFS:flight/route/PointOptions.lua')

        Stopwatch    = require('YFS:../e/lib/src/system/Stopwatch.lua')

        Waypoint     = require('YFS:flight/Waypoint.lua')

        Plane        = require('YFS:../e/lib/src/math/Plane.lua')


        end)

        package.preload['YFS:../e/lib/src/element/Lock.lua']=(function()

        local SU = require('YFS:../e/lib/src/util/StringUtil.lua')

        local log = require('YFS:../e/lib/src/debug/Log.lua').Instance()


        ---@enum EngineType

        EngineType = {
            NOT_ENGINE = 0,
            ATMO = 1,
            SPACE = 2,
            ROCKET = 3
        }


        ---@enum EngineSize

        EngineSize = {
            XS = 1,
            S = 2,
            M = 3,
            L = 4,
            XL = 5
        }


        ---@alias EngineLimits table<EngineType, table<EngineSize, number>>



        ---@param lowerName string

        ---@return EngineSize

        local function getSize(lowerName)
            if SU.EndsWith(lowerName, " xs") then return EngineSize.XS end
            if SU.EndsWith(lowerName, " s") then return EngineSize.S end
            if SU.EndsWith(lowerName, " m") then return EngineSize.M end
            if SU.EndsWith(lowerName, " l") then return EngineSize.L end
            return EngineSize.XL
        end


        ---@param lowerName string

        ---@return EngineType

        local function getType(lowerName)
            if lowerName:match("atmospheric engine") then
                return EngineType.ATMO
            elseif lowerName:match("space engine") then
                return EngineType.SPACE
            elseif lowerName:match("rocket engine") then
                return EngineType.ROCKET
            end

            return EngineType.NOT_ENGINE
        end


        ---@param t EngineType

        local function typeStr(t)
            if t == EngineType.ATMO then return "Atmospheric" end
            if t == EngineType.ROCKET then return "Rocket" end
            return "Space"
        end


        ---@param s EngineSize

        ---@return string

        local function sizeStr(s)
            if s == EngineSize.XS then return "XS" end
            if s == EngineSize.S then return "S" end
            if s == EngineSize.M then return "M" end
            if s == EngineSize.L then return "L" end
            return "XL"
        end


        ---@class ElementLock

        ---@field New fun():ElementLock

        ---@field AddLimit fun(count:number, size:EngineSize, engineType:EngineType)

        ---@field ValidateCo fun():boolean

        ---@field NoLimit fun()


        local Lock = {}

        Lock.__index = Lock


        function Lock.New()
            local noLimit = math.mininteger
            local s = {}
            local limits = {} ---@type EngineLimits
            local atmo = {} ---@type table<EngineSize, number>
            limits[EngineType.ATMO] = atmo
            local space = {} ---@type table<EngineSize, number>
            limits[EngineType.SPACE] = space
            local rocket = {} ---@type table<EngineSize, number>
            limits[EngineType.ROCKET] = rocket

            -- Default with none allowed
            for i = EngineSize.XS, EngineSize.XL, 1 do
                atmo[i] = 0
                space[i] = 0
                rocket[i] = 0
            end

            ---Sets a limit for the number of engines allowed of the given type and size
            ---@param engineType EngineType
            ---@param size EngineSize
            ---@param count integer
            function s.AddLimit(engineType, size, count)
                limits[engineType][size] = count
            end

            ---@return boolean
            function s.ValidateCo()
                local res = true

                local core = library.getCoreUnit()
                for _, localId in ipairs(core.getElementIdList()) do
                    local id = core.getElementItemIdById(localId)
                    local item = system.getItem(id)
                    local withSize = item.displayNameWithSize:lower() ---@type string

                    local t = getType(withSize)
                    local size = getSize(withSize)

                    if t ~= EngineType.NOT_ENGINE then
                        local limit = limits[t]
                        if limit[size] ~= noLimit then
                            limit[size] = limit[size] - 1
                        end
                    end

                    coroutine.yield()
                end

                -- Any engine that has a count of less than 0 there are to many of
                for t = EngineType.ATMO, EngineType.ROCKET do
                    for size = EngineSize.XS, EngineSize.XL do
                        local count = limits[t][size]
                        if count ~= noLimit and count < 0 then
                            log.Error(math.abs(count), " too many engines of type: ", typeStr(t), " ", sizeStr(size))
                            res = false
                        end
                    end
                    coroutine.yield()
                end

                return res
            end

            return setmetatable(s, Lock)
        end


        return Lock


        end)

        package.preload['YFS:version_out.lua']=(function()

        local version =

        {
            APP_NAME = "Yoarii's Flight System",
            APP_VERSION = "850e7fe / 20231223 22:22"
        }


        return version


        end)

        package.preload['YFS:variants/CoreLinkCheck.lua']=(function()

        local s   = require('YFS:Singletons.lua')

        local log = s.log


        ---Ensures that the core is linked and returns true if the control unit is an ECU

        ---@return boolean

        ---@return boolean

        local function ensureCoreLink()
            local unitInfo = system.getItem(unit.getItemId())
            local isECU = unitInfo.displayNameWithSize:lower():match("emergency")

            local linked = library.getCoreUnit() ~= nil
            if not linked then
                log.Error(unitInfo.displayNameWithSize, " must be linked to the core.")
            end

            return linked, isECU
        end


        return ensureCoreLink


        end)

        package.preload['YFS:controller/ControlCommands.lua']=(function()

        ---@module "commandline/CommandLine"

        ---@module "input/Input"


        require('YFS:../e/lib/src/abstraction/Vehicle.lua')

        require('YFS:GlobalTypes.lua')

        local s                                                             = require('YFS:Singletons.lua')

        local log, brakes, calc, uni, keys, pub, constants, gateCtrl, radar = s.log, s.brakes, s.calc, s.universe, s.keys, s.pub,
            s.constants, s.gateCtrl, s.radar
        local VertRef, plane                                                = uni.VerticalReferenceVector,
            Plane.NewByVertialReference()

        ---@alias PointOptionArguments { commandValue:string, maxspeed:number, margin:number, lockdir:boolean}

        ---@alias ReturnData { g1:number[], g2:number[], g3:number[], fwd:number[] }


        ---@class ControlCommands

        ---@field New fun(input:Input, cmd:Command, flightCore:FlightCore)

        ---@field RegisterCommonCommands fun(isECU:boolean)

        ---@field RegisterRouteCommands fun()

        ---@field RegisterMoveCommands fun()


        local ControlCommands                                               = {}

        ControlCommands.__index                                             = ControlCommands


        ---Creates a new RouteModeController

        ---@param input Input

        ---@param cmd CommandLine

        ---@param flightCore FlightCore

        ---@param settings Settings

        ---@param screenCtrl ScreenController

        ---@param access Access

        ---@param routeDb BufferedDB

        ---@return ControlCommands

        function ControlCommands.New(input, cmd, flightCore, settings, screenCtrl, access, routeDb)
            local s = {}

            local rc = flightCore.GetRouteController()

            local function holdPosition()
                local r = rc.ActivateTempRoute().AddCurrentPos()
                r.Options().Set(PointOptions.LOCK_DIRECTION, { Forward():Unpack() })
                flightCore.StartFlight()
            end

            ---@param c Command
            local function addPointOptions(c)
                c.Option("-lockdir").AsEmptyBoolean().Default(false)
                c.Option("-maxspeed").AsNumber().Default(0)
                c.Option("-margin").AsNumber().Default(0.1)
                c.Option("-forceVerticalUp").AsBoolean().Default(true)
            end

            ---@param data PointOptionArguments
            ---@return PointOptions
            local function createOptions(data)
                local opt = PointOptions.New()
                opt.Set(PointOptions.MAX_SPEED, calc.Kph2Mps(data.maxspeed))
                opt.Set(PointOptions.MARGIN, data.margin)

                if data.lockdir then
                    opt.Set(PointOptions.LOCK_DIRECTION, { Forward():Unpack() })
                end
                return opt
            end

            ---@param isECU boolean
            function s.RegisterCommonCommands(isECU)
                -- Setup brakes
                if not isECU then
                    local function b(on)
                        -- Always allow forced mode to be turned off
                        if player.isFrozen() or not on then
                            brakes.Forced(on)
                        end
                    end

                    input.Register(keys.brake, Criteria.New().LCtrl().OnPress(), function() b(true) end)
                    input.Register(keys.brake, Criteria.New().LCtrl().OnRelease(), function() b(false) end)
                end

                cmd.Accept("idle", function()
                    log.Info("Going idle!")
                    flightCore.GoIdle()
                end)

                cmd.Accept("hold", function()
                    holdPosition()
                end)

                cmd.Accept("print-pos", function(_)
                    log.Info("Current pos:", uni.CreatePos(Current()):AsPosString())
                    log.Info("Alignment pos:",
                        uni.CreatePos(Current() + Forward() * Waypoint.DirectionMargin):AsPosString())
                end)

                local lastWidget = settings.Boolean("showWidgetsOnStart", false)

                input.Register(keys.option8, Criteria.New().LShift().OnPress(), function()
                    lastWidget = not lastWidget
                    pub.Publish("ShowInfoWidgets", lastWidget)
                end)

                input.Register(keys.option0, Criteria.New().LShift().OnPress(), function()
                    radar.Show(not radar.IsVisible())
                end)

                input.Register(keys.option0, Criteria.New().OnPress(), function()
                    radar.NextMethod()
                end)

                input.Register(keys.gear, Criteria.New().OnPress(), function()
                    if IsFrozen() then
                        flightCore.StartParking((Current() - uni.ClosestBody(Current()).Geography.Center):Len(), "Parking")
                    end
                end)

                ---@param p Point
                ---@param gate boolean
                ---@param direction Vec3|nil
                local setParkOpt = function(p, gate, direction)
                    local opt = p.Options()
                    opt.Set(PointOptions.MARGIN, settings.Number("parkMargin"))
                    opt.Set(PointOptions.GATE, gate)
                    if direction then
                        opt.Set(PointOptions.LOCK_DIRECTION, { direction:Unpack() })
                    end
                end

                ---@param r Route
                local function startReturnRoute(r)
                    r.AddTag("ReturnTag")
                    gateCtrl.Enable(true)
                    pub.Publish("ResetWSAD", true)
                    flightCore.StartFlight()
                end

                input.Register(keys.gear, Criteria.New().LCtrl().LShift().OnPress(), function()
                    if not IsFrozen() then return end

                    -- Park Pos
                    local c = Current()

                    -- Point above/below park pos
                    local g2 = c + plane.Up() * settings.Number("parkVertDist")

                    -- Entry point
                    local g3 = c + plane.Forward() * settings.Number("parkForwardDist") +
                        plane.Up() * settings.Number("parkVertDist")

                    local returnData = {
                        g1 = { c:Unpack() },
                        g2 = { g2:Unpack() },
                        g3 = { g3:Unpack() },
                        fwd = { plane.Forward():Unpack() }
                    }

                    routeDb.Put("returnData", returnData)

                    local r = rc.ActivateTempRoute("Undock")
                    setParkOpt(r.AddCoordinate(c), settings.Boolean("parkUseGates"), plane.Forward()) -- Point to open gates
                    setParkOpt(r.AddCoordinate(g2), false, plane.Forward())
                    setParkOpt(r.AddCoordinate(g3), false)
                    startReturnRoute(r)
                end)

                input.Register(keys.gear, Criteria.New().LShift().OnPress(), function()
                    if not IsFrozen() then return end

                    local d = routeDb.Get("returnData", {})
                    ---@cast d ReturnData

                    local g1 = Vec3.New(d.g1)
                    local g2 = Vec3.New(d.g2)
                    local g3 = Vec3.New(d.g3)
                    local fwd = Vec3.New(d.fwd)

                    if not (g1:IsZero() and g2:IsZero() and g3:IsZero() and fwd:IsZero()) then
                        local r = rc.ActivateTempRoute("Returning")
                        setParkOpt(r.AddCoordinate(g3), false)
                        setParkOpt(r.AddCoordinate(g2), false, fwd)
                        -- Move backwards to make return to actual start position
                        setParkOpt(r.AddCoordinate(g1), settings.Boolean("parkUseGates"), fwd)
                        startReturnRoute(r)
                    end
                end)
            end

            ---Get the route being edited
            ---@return Route|nil
            local function getEditRoute()
                local route = rc.CurrentEdit()
                if route == nil then
                    log.Error("No route being edited")
                end

                return route
            end

            function s.RegisterRouteCommands()
                cmd.Accept("route-list", function(data)
                    local routes = rc.GetRouteNames()
                    log.Info(#routes, " available routes")
                    for _, r in ipairs(routes) do
                        log.Info(r)
                    end
                end)

                cmd.Accept("route-edit",
                    ---@param data {commandValue:string}
                    function(data)
                        if rc.EditRoute(data.commandValue) then
                            log.Info("Route open for edit")
                        end
                    end).AsString()

                cmd.Accept("route-create",
                    ---@param data {commandValue:string}
                    function(data)
                        rc.CreateRoute(data.commandValue)
                    end).AsString().Must()

                cmd.Accept("route-save", function(data)
                    rc.SaveRoute()
                end).AsEmpty()

                cmd.Accept("route-discard", function(data)
                    rc.Discard()
                end)

                cmd.Accept("route-delete",
                    ---@param data {commandValue:string}
                    function(data)
                        rc.DeleteRoute(data.commandValue)
                    end).AsString().Must()

                local renameRoute = cmd.Accept("route-rename",
                    ---@param data {from:string, to:string}
                    function(data)
                        rc.RenameRoute(data.from, data.to)
                    end).AsEmpty()
                renameRoute.Option("from").AsString().Must()
                renameRoute.Option("to").AsString().Must()

                cmd.Accept("route-print", function(data)
                    local route = getEditRoute()
                    if route == nil then
                        return
                    end

                    for i, p in ipairs(route.Points()) do
                        log.Info(i, ":", calc.Ternary(p.HasWaypointRef(), p.WaypointRef(), p.Pos()))

                        local opts = p.Options()
                        for k, v in pairs(opts.Data()) do
                            log.Info("- ", k, ": ", v)
                        end
                    end
                end)

                cmd.Accept("route-activate",
                    ---@param data {commandValue:string, index:number}
                    function(data)
                        if not access.MayStartRoute(data.commandValue) then
                            return
                        end

                        if rc.ActivateRoute(data.commandValue, data.index,
                                settings.Number("routeStartDistanceLimit"),
                                settings.Number("gateControlDistance")) then
                            gateCtrl.Enable(true)
                            flightCore.StartFlight()
                            pub.Publish("ResetWSAD", true)
                            log.Info("Flight started")
                        end
                    end).AsString().Must()
                    .Option("index").AsNumber()

                local addCurrentToRoute = cmd.Accept("route-add-current-pos",
                    ---@param data PointOptionArguments
                    function(data)
                        local route = getEditRoute()
                        if route == nil then
                            return
                        end

                        local point = route.AddCurrentPos()
                        point.SetOptions(createOptions(data))
                        log.Info("Added current position to route")
                    end).AsEmpty()

                addPointOptions(addCurrentToRoute)

                local addNamed = cmd.Accept("route-add-named-pos",
                    ---@param data PointOptionArguments
                    function(data)
                        local ref = rc.LoadWaypoint(data.commandValue)

                        if ref then
                            local route = getEditRoute()
                            if route == nil then
                                return
                            end
                            local p = route.AddWaypointRef(data.commandValue, ref.Pos())
                            if p then
                                p.SetOptions(createOptions(data))
                                log.Info("Added position to route")
                            else
                                log.Error("Could not add postion")
                            end
                        end
                    end).AsString()
                addPointOptions(addNamed)

                cmd.Accept("route-delete-pos",
                    ---@param data {commandValue:number}
                    function(data)
                        local route = getEditRoute()
                        if route == nil then
                            return
                        end
                        if route.RemovePoint(data.commandValue) then
                            log.Info("Point removed")
                        else
                            log.Error("Could not remove point")
                        end
                    end).AsNumber().Must()

                ---@param from integer
                ---@param to integer
                local function movePoint(from, to)
                    local route = getEditRoute()
                    if route == nil then
                        return
                    end
                    if route.MovePoint(from, to) then
                        log.Info("Point moved:", from, " to ", to)
                    else
                        log.Error("Could not move point")
                    end
                end

                local movePos = cmd.Accept("route-move-pos",
                    ---@param data {from:number, to:number}
                    function(data)
                        movePoint(data.from, data.to)
                    end)
                movePos.Option("from").AsNumber().Must()
                movePos.Option("to").AsNumber().Must()

                cmd.Accept("route-move-pos-forward",
                    ---@param data {commandValue:number}
                    function(data)
                        local ix = data.commandValue
                        movePoint(ix, ix + 1)
                    end).AsNumber().Must()

                cmd.Accept("route-move-pos-back",
                    ---@param data {commandValue:number}
                    function(data)
                        local ix = data.commandValue
                        movePoint(ix, ix - 1)
                    end).AsNumber().Must()

                local cmdSetPosOption = cmd.Accept("route-set-pos-option",
                    ---@param data {ix:number, endIx:number, toggleSkippable:boolean, toggleSelectable:boolean, margin:boolean, finalSpeed:number, maxSpeed:number, toggleGate:boolean}
                    function(data)
                        local route = getEditRoute()
                        if route == nil then
                            return
                        end

                        if not data.endIx then
                            data.endIx = data.ix
                        end

                        if data.maxSpeed and data.maxSpeed < 0 then
                            log.Error("Max speed must be larger than 0")
                            return
                        end

                        if data.ix > data.endIx then
                            log.Error("Start index must be less or equal to end index")
                            return
                        end

                        if not (route.CheckBounds(data.ix) and route.CheckBounds(data.endIx)) then
                            log.Error("Index out of bounds")
                            return
                        end

                        if data.margin and data.margin < 0.1 then
                            log.Error("Margin must be larger or equal to 0.1m")
                            return
                        end

                        if data.finalSpeed and data.finalSpeed < 0 then
                            log.Error("Final speed must be >= 0")
                            return
                        end

                        log.Info("Setting point options for point indexes ", data.ix, " through ", data.endIx)

                        for i = data.ix, data.endIx, 1 do
                            if data.toggleSkippable then
                                local newValue = not route.GetPointOption(i, PointOptions.SKIPPABLE, false)
                                if route.SetPointOption(i, PointOptions.SKIPPABLE, newValue) then
                                    log.Info("Set skippable option to ", newValue)
                                end
                            end

                            if data.toggleSelectable then
                                local newValue = not route.GetPointOption(i, PointOptions.SELECTABLE, true)
                                if route.SetPointOption(i, PointOptions.SELECTABLE, newValue) then
                                    log.Info("Set selectable option to ", newValue)
                                end
                            end

                            if data.margin then
                                route.SetPointOption(i, PointOptions.MARGIN, data.margin)
                            end

                            if data.finalSpeed then
                                route.SetPointOption(i, PointOptions.FINAL_SPEED, calc.Kph2Mps(data.finalSpeed))
                            end

                            if data.maxSpeed then
                                route.SetPointOption(i, PointOptions.MAX_SPEED, calc.Kph2Mps(data.maxSpeed))
                            end

                            if data.toggleGate then
                                local newValue = not route.GetPointOption(i, PointOptions.GATE, false)
                                route.SetPointOption(i, PointOptions.GATE, newValue)
                                log.Info("Set gate option to ", newValue)
                            end
                        end
                    end).AsEmpty()
                cmdSetPosOption.Option("ix").AsNumber().Must()
                cmdSetPosOption.Option("endIx").AsNumber()
                cmdSetPosOption.Option("toggleSkippable").AsEmptyBoolean()
                cmdSetPosOption.Option("toggleSelectable").AsEmptyBoolean()
                cmdSetPosOption.Option("margin").AsNumber()
                cmdSetPosOption.Option("finalSpeed").AsNumber()
                cmdSetPosOption.Option("maxSpeed").AsNumber()
                cmdSetPosOption.Option("toggleGate").AsEmptyBoolean()

                cmd.Accept("route-print-pos-options",
                    ---@param data {commandValue:number}
                    function(data)
                        local route = getEditRoute()
                        if route == nil then
                            return
                        end

                        for i, k in ipairs(PointOptions.ALL) do
                            local val = route.GetPointOption(data.commandValue, k, nil)
                            if val ~= nil then
                                log.Info(k, ": ", val)
                            end
                        end
                    end).AsNumber()

                local saveCurrAs = cmd.Accept("pos-save-current-as",
                    ---@param data {name:string, auto:boolean}
                    function(data)
                        if data.auto then
                            local new = rc.FirstFreeWPName()
                            if not new then
                                log.Error("Could not find a free waypoint name")
                                return
                            end

                            data.name = new
                        elseif not data.name then
                            log.Error("No name provided")
                            return
                        end

                        local pos = uni.CreatePos(Current()).AsPosString()
                        if rc.StoreWaypoint(data.name, pos) then
                            log.Info("Current position saved as ", data.name)
                        end
                    end).AsEmpty()
                saveCurrAs.Option("name").AsString()
                saveCurrAs.Option("auto").AsEmptyBoolean()

                cmd.Accept("pos-save-as",
                    ---@param data {commandValue:string, pos:string}
                    function(data)
                        local p = uni.ParsePosition(data.pos)
                        if p then
                            rc.StoreWaypoint(data.commandValue, p.AsPosString())
                        end
                    end).AsString().Must().Option("pos").AsString().Must()

                cmd.Accept("pos-list", function(_)
                    for _, data in ipairs(rc.GetWaypoints()) do
                        log.Info(data.name, ": ", data.point:Pos())
                    end
                end)

                local rename = cmd.Accept("pos-rename",
                    ---@param data {old:string, new:string}
                    function(data)
                        rc.RenameWaypoint(data.old, data.new)
                    end)
                rename.Option("old").Must().AsString()
                rename.Option("new").Must().AsString()

                cmd.Accept("pos-delete",
                    ---@param data {commandValue:string}
                    function(data)
                        local deleted = rc.DeleteWaypoint(data.commandValue)
                        if deleted then
                            log.Info("Deleted waypoint: '", data.commandValue, "', position was ", deleted.pos)
                        end
                    end).AsString().Must()

                local alongGrav = cmd.Accept("pos-create-along-gravity",
                    ---@param data {commandValue:string, u:number}
                    function(data)
                        local pos = Current() - VertRef() * data.u
                        local posStr = uni.CreatePos(pos).AsPosString()
                        if rc.StoreWaypoint(data.commandValue, posStr) then
                            log.Info("Stored postion ", posStr, " as ", data.commandValue)
                        end
                    end).AsString().Must()
                alongGrav.Option("-u").AsNumber().Must()

                local relative = cmd.Accept("pos-create-relative",
                    ---@param data {commandValue:string, u:number, f:number, r:number}
                    function(data)
                        local f = data.f or 0
                        local u = data.u or 0
                        local r = data.r or 0
                        if f == 0 and u == 0 and r == 0 then
                            log.Error("Must provide atleast one direction distance")
                        else
                            local pos = Current() + Forward() * f + Right() * r + Up() * u
                            local posStr = uni.CreatePos(pos).AsPosString()
                            if rc.StoreWaypoint(data.commandValue, posStr) then
                                log.Info("Stored postion ", posStr, " as ", data.commandValue)
                            end
                        end
                    end).AsString().Must()
                relative.Option("u").AsNumber()
                relative.Option("f").AsNumber()
                relative.Option("r").AsNumber()

                local printRelative = cmd.Accept("pos-print-relative",
                    ---@param data {u:number, f:number, r:number}
                    function(data)
                        local f = data.f or 0
                        local u = data.u or 0
                        local r = data.r or 0
                        if f == 0 and u == 0 and r == 0 then
                            log.Error("Must provide atleast one direction distance")
                        else
                            local pos = Current() + Forward() * f + Right() * r + Up() * u
                            local posStr = uni.CreatePos(pos).AsPosString()
                            log.Info("Position is at: ", posStr)
                        end
                    end)
                printRelative.Option("u").AsNumber()
                printRelative.Option("f").AsNumber()
                printRelative.Option("r").AsNumber()


                ---@param data {x:number, y:number, z:number}
                ---@return number
                local function countProvidedVectorParts(data)
                    local count = 0

                    for _, value in ipairs({ "x", "y", "z" }) do
                        if data[value] ~= nil then count = count + 1 end
                    end

                    return count
                end

                local createVertRoute = cmd.Accept("create-vertical-route",
                    ---@param data {commandValue:string, distance:number, followGravInAtmo:boolean, extraPointMargin:number, x:number, y:number, z:number}
                    function(data)
                        local partCount = countProvidedVectorParts(data)
                        local dir ---type @Vec3

                        if partCount == 0 then
                            dir = -VertRef()
                        elseif partCount ~= 3 then
                            log.Error("Either none or all three vector components must be provided")
                            return
                        else
                            dir = Vec3.New(data.x, data.y, data.z)
                        end

                        local route = rc.CreateRoute(data.commandValue)
                        if route then
                            local startPos = route.AddCurrentPos()
                            local startOpt = startPos.Options()
                            startOpt.Set(PointOptions.LOCK_DIRECTION, Forward())
                            startOpt.Set(PointOptions.MARGIN, constants.flight.defaultStartEndMargin)

                            local targetPos = Current() + dir * data.distance

                            local startBody = uni.ClosestBody(Current())
                            local startInAtmo = startBody:IsInAtmo(Current())
                            local bodyClosestToEnd = uni.ClosestBody(targetPos)
                            local endInAtmo = bodyClosestToEnd:IsInAtmo(targetPos)

                            if data.followGravInAtmo then
                                if startInAtmo and endInAtmo then
                                    log.Warning(
                                        "Start and end point are in atmosphere, skipping additional gravity-aligned point in space.")
                                elseif endInAtmo and not startInAtmo then
                                    log.Error(
                                        "Cannot calculate extra gravity aligned point when start point is not within atmosphere")
                                    return
                                elseif startInAtmo and not endInAtmo then
                                    local pointInSpace = Current() -
                                        VertRef() * startBody:DistanceToAtmoEdge(Current())
                                    -- Add a precentage of the distance between target and atmosphere edge
                                    local diff = (pointInSpace - targetPos):Len() * 0.05
                                    pointInSpace = pointInSpace - VertRef() * diff
                                    local extra = route.AddCoordinate(pointInSpace)
                                    extra.Options().Set(PointOptions.LOCK_DIRECTION, Forward())
                                    extra.Options().Set(PointOptions.MARGIN, data.extraPointMargin)
                                    log.Info("Added extra gravity-aligned point in space at ",
                                        extra.Pos(), "with a margin of ", data.extraPointMargin, "m")
                                end
                            end

                            local endPos = route.AddCoordinate(targetPos)
                            local endOpt = endPos.Options()
                            endOpt.Set(PointOptions.LOCK_DIRECTION, Forward())
                            endOpt.Set(PointOptions.MARGIN, constants.flight.defaultStartEndMargin)

                            if rc.SaveRoute() then
                                log.Info("Created a route by name '", data.commandValue,
                                    "' with start at current position and direction with the endpoint at ", endPos.Pos())
                            else
                                log.Error("Could not create the route")
                            end
                        end
                    end).AsString().Must()
                createVertRoute.Option("distance").AsNumber().Must()
                createVertRoute.Option("followGravInAtmo").AsEmptyBoolean()
                createVertRoute.Option("extraPointMargin").AsNumber().Default(5)
                createVertRoute.Option("x").AsNumber()
                createVertRoute.Option("y").AsNumber()
                createVertRoute.Option("z").AsNumber()

                ---@param v Vec3
                local function formatVecParts(v)
                    return string.format("-x %0.14f -y %0.14f -z %0.14f", v.x, v.y, v.z)
                end

                cmd.Accept("print-vertical-up", function(_)
                    log.Info(formatVecParts(-VertRef()))
                end)

                local sub = cmd.Accept("sub-pos",
                    ---@param data  {commandValue:string, sub:string|nil}
                    function(data)
                        local sub
                        if data.sub then
                            local subPos = uni.ParsePosition(data.sub)
                            if not subPos then
                                return
                            end

                            sub = subPos.Coordinates()
                        else
                            log.Info("No subtrahend specified, using current position")
                            sub = Current()
                        end

                        local pos = uni.ParsePosition(data.commandValue)
                        if pos then
                            local diff = pos.Coordinates() - sub
                            local dir, dist = diff:NormalizeLen()
                            log.Info("-distance ", dist, " ", formatVecParts(dir))
                        end
                    end).AsString().Must()
                sub.Option("-sub").AsString()

                local closestOnLine = cmd.Accept("closest-on-line",
                    ---@param data {a:string, b:string}
                    function(data)
                        local p1 = uni.ParsePosition(data.a)
                        local p2 = uni.ParsePosition(data.b)

                        if not (p1 and p2) then
                            return
                        end

                        local p = calc.NearestPointOnLine(p1.Coordinates(),
                            (p1.Coordinates() - p2:Coordinates()):NormalizeInPlace(), Current())
                        local closest = uni.CreatePos(p)
                        log.Info("Closest point on the line passing through a and b is at ", closest.AsPosString())
                    end)
                closestOnLine.Option("a").AsString().Must()
                closestOnLine.Option("b").AsString().Must()

                cmd.Accept("get-parallel-from-route",
                    ---@param data {commandValue:string}
                    function(data)
                        local r = rc.LoadRoute(data.commandValue)
                        if not r then
                            return
                        end

                        local points = r.Points()
                        if #points < 2 then
                            log.Error("Only one point in route, can't make a parallel point from that.")
                        end

                        local second = uni.ParsePosition(points[2].Pos()):Coordinates()
                        local first = uni.ParsePosition(points[1].Pos()):Coordinates()
                        local diff = second - first

                        local dir, dist = diff:NormalizeLen()
                        log.Info("-distance ", dist, " ", formatVecParts(dir))
                    end).AsString().Must()


                cmd.Accept("floor",
                    ---@param data {commandValue:string}
                    function(data)
                        screenCtrl.ActivateFloorMode(data.commandValue)
                    end).AsString().Must()
            end

            ---@param userInput string
            ---@return {pos: string, coord:Vec3}|nil
            local function getPos(userInput)
                local target
                local point = rc.LoadWaypoint(userInput)
                if point then
                    target = { pos = point.Pos(), coord = uni.ParsePosition(point.Pos()).Coordinates() }
                else
                    local pos = uni.ParsePosition(userInput)
                    if pos then
                        target = { pos = pos.AsPosString(), coord = pos.Coordinates() }
                    end
                end

                if not target then
                    log.Error("Given input is not a :pos{} string or a named waypoint")
                end

                return target
            end

            ---@param target Vec3
            ---@param lockDir boolean
            ---@param maxSpeed number
            ---@param margin number
            ---@param forceVerticalUp boolean
            local function executeMove(target, lockDir, maxSpeed, margin, forceVerticalUp)
                if maxSpeed ~= 0 then
                    maxSpeed = calc.Kph2Mps(maxSpeed)
                end

                local lockToDir = Vec3.zero
                if lockDir then
                    lockToDir = Forward()
                end

                gateCtrl.Enable(false)
                flightCore.GotoTarget(target, lockToDir, margin, maxSpeed, 0, false, forceVerticalUp)
                pub.Publish("ResetWSAD", true)
                log.Info("Moving to ", uni.CreatePos(target).AsPosString())
            end

            function s.RegisterMoveCommands()
                ---@param data {commandValue:string, lockdir:boolean, maxspeed:number, margin:number, u:number, r:number, f:number, forceVerticalUp:boolean}
                local moveFunc = function(data)
                    local target = Current() + Forward() * data.f + Right() * data.r - VertRef() * data.u

                    executeMove(target, data.lockdir, data.maxspeed, data.margin, data.forceVerticalUp)
                end

                local moveCmd = cmd.Accept("move", moveFunc)
                moveCmd.Option("-u").AsNumber().Must().Default(0)
                moveCmd.Option("-r").AsNumber().Must().Default(0)
                moveCmd.Option("-f").AsNumber().Must().Default(0)
                addPointOptions(moveCmd)

                local gotoCmd = cmd.Accept("goto",
                    ---@param data {commandValue:string, lockdir:boolean, maxspeed:number, margin:number, offset:number, forceVerticalUp:boolean}
                    function(data)
                        local target = getPos(data.commandValue)

                        if target then
                            -- A negative offset means on the other side of the point
                            local direction, distance = (target.coord - Current()):NormalizeLen()
                            local remaining = distance - data.offset

                            if remaining > 0 then
                                executeMove(Current() + direction * remaining, data.lockdir, data.maxspeed, data.margin,
                                    data.forceVerticalUp)
                            else
                                log.Error("Offset larger than distance to target")
                            end
                        end
                    end).AsString().Must()
                addPointOptions(gotoCmd)
                gotoCmd.Option("offset").AsNumber().Default(0)

                local turnFunc = function(data)
                    -- Turn in the expected way, i.e. clockwise on positive values.
                    local angle = -data.commandValue
                    flightCore.Turn(angle, Up())
                end

                cmd.Accept("turn", turnFunc).AsNumber()

                local strafeFunc = function(data)
                    local route = rc.ActivateTempRoute()
                    local point = route.AddCoordinate(Current() +
                        Right() * data.commandValue)
                    local p = point.Options()
                    p.Set(PointOptions.LOCK_DIRECTION, { Forward():Unpack() })
                    p.Set(PointOptions.MAX_SPEED, data.maxspeed or MaxSpeed())

                    flightCore.StartFlight()
                end

                local strafeCmd = cmd.Accept("strafe", strafeFunc).AsNumber()
                strafeCmd.Option("-maxspeed").AsNumber()

                ---@param pos Position|nil
                local function alignTo(pos)
                    if pos then
                        local route = rc.ActivateTempRoute()
                        route.AddCurrentPos()
                        flightCore.StartFlight()
                        flightCore.AlignTo(pos.Coordinates())
                        log.Info("Aligning to ", pos.AsPosString())
                    end
                end

                cmd.Accept("align-to",
                    ---@param data {commandValue:string}
                    function(data)
                        local target = getPos(data.commandValue)
                        if target then
                            local pos = uni.ParsePosition(target.pos)
                            alignTo(pos)
                        end
                    end).AsString().Must()

                local alignToVector = cmd.Accept("align-to-vector",
                    ---@param data {x:number, y:number, z:number}
                    function(data)
                        local pos = uni.CreatePos(Current() + Vec3.New(data.x, data.y, data.z))
                        alignTo(pos)
                    end)

                alignToVector.Option("x").AsNumber().Must()
                alignToVector.Option("y").AsNumber().Must()
                alignToVector.Option("z").AsNumber().Must()

                cmd.Accept("set-waypoint",
                    ---@param data {commandValue:string, notify:boolean}
                    function(data)
                        system.setWaypoint(data.commandValue, data.notify)
                    end).AsString()
                    .Option("notify").AsEmptyBoolean()

                local posAbove = cmd.Accept("position-above",
                    ---@param data {cx:number, cy:number, cz:number, fx:number, fy:number, fz:number, heightMargin:number}
                    function(data)
                        local center = Vec3.New(data.cx, data.cy, data.cz)
                        local forward = Vec3.New(data.fx, data.fy, data.fz)
                        log.Info("Positioning above ", uni.CreatePos(center).AsPosString(), ", with forward direction to ",
                            uni.CreatePos(forward).AsPosString())

                        --[[

                        Create a route:
                        - From current position
                        - 5m up
                        - 5m above center, aligned towards the forward element
                        - On center-element, plus half vertical size of construct

                        ]]

                        local r = rc.ActivateTempRoute()
                        r.AddCurrentPos()
                        r.AddCoordinate(Current() - VertRef() * data.heightMargin)
                        local upAtCenter = (center - uni.ClosestBody(center).Geography.Center):Normalize()
                        forward = calc.ProjectPointOnPlane(upAtCenter, center, forward) -- Project on same plane as center
                        local dir = (forward - center):Normalize()
                        r.AddCoordinate(center + upAtCenter * data.heightMargin).Options().Set(PointOptions.LOCK_DIRECTION, dir)

                        r.AddCoordinate(center).Options().Set(PointOptions.LOCK_DIRECTION, dir)

                        flightCore.StartFlight()
                    end).AsEmpty()
                posAbove.Option("heightMargin").AsNumber().Must()
                posAbove.Option("cx").AsNumber().Must()
                posAbove.Option("cy").AsNumber().Must()
                posAbove.Option("cz").AsNumber().Must()
                posAbove.Option("fx").AsNumber().Must()
                posAbove.Option("fy").AsNumber().Must()
                posAbove.Option("fz").AsNumber().Must()
            end

            settings.Callback("dockingMode",
                ---@param mode number
                function(mode)
                    mode = calc.Clamp(mode, 1, 3)
                    construct.setDockingMode(mode)
                end)

            return setmetatable(s, ControlCommands)
        end


        return ControlCommands


        end)

        package.preload['YFS:../e/lib/src/util/Pagination.lua']=(function()

        --local calc = requ ire("util/Calc")

        local p = {}


        ---Paginates the list

        ---@generic T

        ---@param list T[]

        ---@param page integer

        ---@param perPage integer

        ---@return T[]

        function p.Paginate(list, page, perPage)
            if #list == 0 then return {} end

            local totalPages = p.GetPageCount(list, perPage)
            --page = calc.Clamp(page, 1, totalPages)
            page = math.min(totalPages, math.max(page, 1))

            local startIx = (page - 1) * perPage + 1
            local endIx = startIx + perPage - 1

            local res = {} ---@type string[]
            local ix = 1

            for i = startIx, endIx, 1 do
                res[ix] = list[i]
                ix = ix + 1
            end

            return res
        end


        ---Gets the number of pages we can make out of the list

        ---@generic T

        ---@param list T[]

        ---@param perPage integer

        ---@return integer

        function p.GetPageCount(list, perPage)
            return math.ceil(#list / perPage)
        end


        return p


        end)

        package.preload['YFS:flight/route/Route.lua']=(function()

        --[[
            A route holds a series of Point that each contains the data needed to create a Waypoint.
            When loaded, additional points may be inserted to to create a route that is smooth to fly
            and that doesn't pass through a planetary body. Extra points are not persisted.
        ]]



        require('YFS:../e/lib/src/abstraction/Vehicle.lua')

        require('YFS:GlobalTypes.lua')

        local s                               = require('YFS:Singletons.lua')

        local log, universe, calc, pagination = s.log, s.universe, s.calc, require('YFS:../e/lib/src/util/Pagination.lua')

        require('YFS:../e/lib/src/util/Table.lua')


        ---@module "Vec3"


        ---@alias RouteRemainingInfo {Legs:integer, TotalDistance:number}


        ---@class Route Represents a route

        ---@field New fun():Route

        ---@field Points fun():Point[]

        ---@field AddPos fun(positionString:string):Point

        ---@field AddCoordinate fun(coord:Vec3):Point

        ---@field AddWaypointRef fun(namedWaypoint:string, pos?:string):Point|nil

        ---@field AddCurrentPos fun():Point

        ---@field AddPoint fun(sp:Point)

        ---@field CheckBounds fun(ix:integer):boolean

        ---@field SetPointOption fun(pointIndex:number, optionName:string, value:string|boolean|number):boolean

        ---@field GetPointOption fun(pointIndex:number, optionName:string, default:string|boolean|nil):string|number|boolean|nil

        ---@field Clear fun()

        ---@field Next fun():Point|nil

        ---@field Peek fun():Point|nil

        ---@field LastPointReached fun():boolean

        ---@field AdjustRouteBasedOnTarget fun(startPos:Vec3, targetIndex:number, gateControlDistance:number)

        ---@field FindClosestLeg fun(coordinate:Vec3):number,number

        ---@field FindClosestPositionAlongRoute fun(coord:Vec3):Vec3

        ---@field RemovePoint fun(ix:number):boolean

        ---@field MovePoint fun(from:number, to:number)

        ---@field GetRemaining fun(fromPos:Vec3):RouteRemainingInfo

        ---@field GetPointPage fun(page:integer, perPage:integer):Point[]

        ---@field GetPageCount fun(perPage:integer):integer

        ---@field WaitForGate fun(current:Vec3, margin:number):boolean

        ---@field HasTag fun(t:string):boolean

        ---@field AddTag fun(t:string)

        local Route = {}

        Route.__index = Route


        ---Creates a new route

        ---@return Route

        function Route.New()
            local s = {}

            local points = {} ---@type Point[]
            local nextPointIx = 1
            local tags = {} ---@type table<string, boolean>

            ---@param ix number
            ---@return Vec3
            local function coordsFromPoint(ix)
                return universe.ParsePosition(points[ix]:Pos()):Coordinates()
            end

            ---Returns true if the index is within bounds
            ---@param ix integer
            ---@return boolean
            function s.CheckBounds(ix)
                return ix > 0 and ix <= #points
            end

            ---Returns all the points in the route
            ---@return Point[]
            function s.Points()
                return points
            end

            ---Adds a ::pos{} string
            ---@param positionString string
            ---@return Point|nil
            function s.AddPos(positionString)
                local pos = universe.ParsePosition(positionString)

                if pos == nil then
                    log.Error("Could not add position to route")
                    return nil
                end

                return s.AddPoint(Point.New(pos:AsPosString()))
            end

            ---Adds a coordinate to the route
            ---@param coord Vec3
            ---@return Point
            function s.AddCoordinate(coord)
                return s.AddPoint(Point.New(universe.CreatePos(coord):AsPosString()))
            end

            ---Adds a named waypoint to the route
            ---@param name string
            ---@param pos? string The ::pos{} string. This parameter is mainly used when editing routes to make the position available for the UI.
            ---@return Point|nil
            function s.AddWaypointRef(name, pos)
                if name == nil or #name == 0 then
                    return nil
                end
                return s.AddPoint(Point.New(pos or "", name))
            end

            ---Adds the current postion to the route
            ---@return Point
            function s.AddCurrentPos()
                return s.AddCoordinate(Current())
            end

            ---Adds a Point to the route
            ---@param point Point
            ---@return Point
            function s.AddPoint(point)
                points[#points + 1] = point
                return point
            end

            ---@param pointIndex integer
            ---@param optionName string
            ---@param value string|boolean|number
            ---@return boolean
            function s.SetPointOption(pointIndex, optionName, value)
                if s.CheckBounds(pointIndex) then
                    points[pointIndex].Options().Set(optionName, value)
                    return true
                else
                    log.Error("Point index outside bounds")
                    return false
                end
            end

            ---@param pointIndex number
            ---@param optionName string
            ---@param default string|number|boolean|nil
            ---@return string|number|boolean|nil
            function s.GetPointOption(pointIndex, optionName, default)
                if s.CheckBounds(pointIndex) then
                    local opt = points[pointIndex].Options()
                    return opt.Get(optionName, default)
                else
                    log.Error("Point index outside bounds")
                end

                return default
            end

            ---Clears the route
            function s.Clear()
                points = {}
                nextPointIx = 1
            end

            ---Returns the next point in the route or nil if the end has been reached
            ---@return Point|nil
            function s.Next()
                if s.LastPointReached() then return nil end

                local p = points[nextPointIx]
                nextPointIx = nextPointIx + 1

                return p
            end

            function s.LastPointReached()
                return nextPointIx > #points
            end

            local function reverse()
                -- To ensure that we hold the same direction going backwards as we did when going forward,
                -- we must shift the directions one step left before reversing.
                -- Note that this is a destructive operation as we loose the original direction on the first point.
                for i = 1, #points - 1 do
                    points[i].Options().Set(PointOptions.LOCK_DIRECTION, points[i + 1].Options().Get(PointOptions.LOCK_DIRECTION))
                end

                ReverseInplace(points)
            end

            ---Finds the closest point on the route
            ---@param probeCoord Vec3
            ---@param margin number
            ---@return Point[]
            function s.FindPointsWithin(probeCoord, margin)
                local found = {} ---@type Point[]

                for i, p in ipairs(points) do
                    local coords = coordsFromPoint(i)
                    if probeCoord:Dist(coords) <= margin then
                        found[#found + 1] = p
                    end
                end

                return found
            end

            ---@param coordinate Vec3
            ---@return number # Start index
            ---@return number # End index
            function s.FindClosestLeg(coordinate)
                local startIx = 1
                local endIx = 2

                local closest = math.maxinteger
                local prev = coordsFromPoint(1)

                for i = 2, #points, 1 do
                    local next = coordsFromPoint(i)

                    local dist = coordinate:Dist(calc.NearestOnLineBetweenPoints(prev, next, coordinate))

                    -- Find the first closest leg. If a second leg at the same distance is found, it will be ignored.
                    if dist < closest then
                        closest = dist
                        startIx = i - 1
                        endIx = i
                    end

                    prev = next
                end

                return startIx, endIx
            end

            ---@param coord Vec3
            ---@return Vec3
            function s.FindClosestPositionAlongRoute(coord)
                local startIx, endIx = s.FindClosestLeg(coord)
                return calc.NearestOnLineBetweenPoints(coordsFromPoint(startIx), coordsFromPoint(endIx), coord)
            end

            ---@param startIx number First index to keep
            ---@param endIx number Last index to keep
            ---@param currentLegStartIx number Start index of leg we're currently on
            ---@param currentLegEndIx number End index of the leg we're currently on
            local function keep(startIx, endIx, currentLegStartIx, currentLegEndIx)
                local toKeep = {}

                for i = startIx, endIx do
                    local skippable = points[i].Options().Get(PointOptions.SKIPPABLE, false)
                    if i == startIx
                        or i == endIx
                        or i == currentLegStartIx
                        or i == currentLegEndIx
                        or not skippable then
                        toKeep[#toKeep + 1] = points[i]
                    end
                end

                points = toKeep
            end

            ---Replaces a point in the route, keping options from original point
            ---@param currentPos Vec3 Current position
            ---@param gateControlDistance number
            local function replaceStartPoint(currentPos, gateControlDistance)
                local nearestPos = s.FindClosestPositionAlongRoute(currentPos)
                local opt = points[1].Options().Clone()
                opt.Set(PointOptions.GATE,
                    opt.Get(PointOptions.GATE, false) and coordsFromPoint(1):Dist(currentPos) < gateControlDistance)

                -- Also take direction of the next point, so that when moving to the path we orient in the direction we're going to travel.
                opt.Set(PointOptions.LOCK_DIRECTION, points[2].Options().Get(PointOptions.LOCK_DIRECTION))

                points[1] = Point.New(universe.CreatePos(nearestPos):AsPosString(), nil, opt)
            end

            ---Adjust the route so that it will be traveled in the correct direction.
            ---@param startPos Vec3
            ---@param targetIndex number
            ---@param gateControlDistance number
            function s.AdjustRouteBasedOnTarget(startPos, targetIndex, gateControlDistance)
                -- Determine if we are before or after the target point
                local legStartIx, legEndIx = s.FindClosestLeg(startPos)

                local adjChar
                local orgCount = #points

                if legEndIx <= targetIndex then
                    -- Our current pos is on an earlier or same leg as the one that has the target index
                    adjChar = "A"
                    keep(legStartIx, targetIndex, legStartIx, legEndIx)
                else
                    -- We're currently on a leg after the target index
                    adjChar = "B"
                    keep(targetIndex, legEndIx, legStartIx, legEndIx)
                    reverse()
                end

                replaceStartPoint(startPos, gateControlDistance)

                log.Info("Route adjusted (", adjChar, ": ", orgCount, " -> ", #points, ")")
            end

            ---Remove the point at index ix
            ---@param ix number
            function s.RemovePoint(ix)
                if not s.CheckBounds(ix) then return false end

                table.remove(points, ix)
                return true
            end

            ---Move a point from index 'from' to index 'to'
            ---@param from number
            ---@param to number
            function s.MovePoint(from, to)
                if not s.CheckBounds(from) or not s.CheckBounds(to) or to == from then return false end

                local v = table.remove(points, from)
                table.insert(points, to, v)

                return true
            end

            ---@param fromPos Vec3
            ---@return RouteRemainingInfo
            function s.GetRemaining(fromPos)
                local total = 0
                local prev

                for i = nextPointIx, #points, 1 do
                    local pos = universe.ParsePosition(points[i].Pos())
                    if pos then
                        if prev then
                            total = total + (prev - pos.Coordinates()):Len()
                        end

                        prev = pos.Coordinates()
                    end
                end

                -- Add distance to next point in route
                local ix = calc.Ternary(s.LastPointReached(), -1, 0)
                local next = coordsFromPoint(nextPointIx + ix)
                total = total + (fromPos - next):Len()

                return { Legs = #points - nextPointIx, TotalDistance = total }
            end

            ---@param page integer
            ---@param perPage integer
            ---@return Point[]
            function s.GetPointPage(page, perPage)
                return pagination.Paginate(s.Points(), page, perPage)
            end

            ---@param perPage integer
            ---@return integer
            function s.GetPageCount(perPage)
                return pagination.GetPageCount(s.Points(), perPage)
            end

            ---Determines if we should wait for gates at the current position.
            ---@param current Vec3
            ---@param margin number
            ---@return boolean
            function s.WaitForGate(current, margin)
                -- Find the points within margin
                local closest = s.FindPointsWithin(current, margin)

                -- If any point has gate option set then we should wait for the gate.
                for _, p in ipairs(closest) do
                    if p.Options().Get(PointOptions.GATE, false) then
                        return true
                    end
                end

                return false
            end

            ---@param t string
            function s.AddTag(t)
                tags[t] = true
            end

            ---@param t string
            ---@return boolean
            function s.HasTag(t)
                return tags[t] ~= nil
            end

            return setmetatable(s, Route)
        end


        return Route


        end)

        package.preload['YFS:../e/lib/src/util/DistanceFormat.lua']=(function()

        local oneSU = 200000

        local oneKm = 1000


        ---@param distance number

        ---@return {value:number, unit:string}

        function DistanceFormat(distance)
            if distance >= oneSU then
                return { value = distance / oneSU, unit = "su" }
            elseif distance >= oneKm then
                return { value = distance / oneKm, unit = "km" }
            else
                return { value = distance, unit = "m" }
            end
        end


        return DistanceFormat


        end)

        package.preload['YFS:flight/route/RouteController.lua']=(function()

        require('YFS:../e/lib/src/abstraction/Vehicle.lua')

        require('YFS:GlobalTypes.lua')

        local s                                 = require('YFS:Singletons.lua')

        local log, pub, universe, constants     = s.log, s.pub, s.universe, s.constants


        local Route, pagination, distanceFormat = require('YFS:flight/route/Route.lua'), require('YFS:../e/lib/src/util/Pagination.lua'),
            require('YFS:../e/lib/src/util/DistanceFormat.lua')
        require('YFS:../e/lib/src/util/Table.lua')


        ---@alias NamedWaypoint {name:string, point:Point}

        ---@alias WaypointMap table<string,PointPOD>

        ---@alias RouteData {points:PointPOD[], gateControl:{waitAtStart:boolean, waitAtEnd:boolean}}

        ---@alias SelectablePoint {visible:boolean, name:string, activate:string, index:number}

        ---@module "storage/BufferedDB"


        ---@class RouteController

        ---@field GetRouteNames fun():string[]

        ---@field GetPageCount fun(perPage:integer):integer

        ---@field GetRoutePage fun(page:integer, perPage:integer):string[]

        ---@field LoadRoute fun(name:string):Route|nil

        ---@field LoadFloorRoute fun(name:string):Route

        ---@field DeleteRoute fun(name:string)

        ---@field StoreRoute fun(name:string, route:Route):boolean

        ---@field RenameRoute fun(from:string, to:string)

        ---@field StoreWaypoint fun(name:string, pos:string):boolean

        ---@field GetWaypoints fun():NamedWaypoint[]

        ---@field LoadWaypoint fun(name:string, waypoints?:table<string,Point>):Point|nil

        ---@field DeleteWaypoint fun(name:string):PointPOD|nil

        ---@field CurrentRoute fun():Route|nil

        ---@field CurrentEdit fun():Route|nil

        ---@field CurrentEditName fun():string|nil

        ---@field ActivateRoute fun(name:string, destinationWayPointIndex?:number, startMargin?:number, gateControlDistance?:number):boolean

        ---@field ActivateTempRoute fun(name:string|nil):Route

        ---@field CreateRoute fun(name:string):Route|nil

        ---@field SaveRoute fun():boolean

        ---@field Discard fun()

        ---@field Count fun():integer

        ---@field ActiveRouteName fun():string|nil

        ---@field ActivateHoldRoute fun()

        ---@field GetWaypointPage fun(page:integer, perPage:integer):NamedWaypoint[]

        ---@field GetWaypointPages fun(perPage:integer):integer

        ---@field FloorRoute fun():Route

        ---@field FloorRouteName fun():string|nil

        ---@field EditRoute fun(name:string):Route|nil

        ---@field SelectableFloorPoints fun():SelectablePoint[]

        ---@field CalculateDistances fun(points:Point[]):number[]

        ---@field FirstFreeWPName fun():string|nil

        ---@field RenameWaypoint fun(old:string, new:string):boolean


        local RouteController = {}

        RouteController.__index = RouteController

        local singleton


        RouteController.NAMED_POINTS = "NamedPoints"

        RouteController.NAMED_ROUTES = "NamedRoutes"


        ---Create a new route controller instance

        ---@param bufferedDB BufferedDB

        ---@return RouteController

        function RouteController.Instance(bufferedDB)
            if singleton then
                return singleton
            end

            local s = {}

            local db = bufferedDB
            local current ---@type Route|nil
            local edit ---@type Route|nil
            local editName ---@type string|nil
            local activeRouteName ---@type string|nil
            local floorRoute ---@type Route|nil
            local floorRouteName ---@type string|nil

            ---Returns the the name of all routes, with "(editing)" appended to the one currently being edited.
            ---@return string[]
            function s.GetRouteNames()
                local routes = db.Get(RouteController.NAMED_ROUTES) or {}
                local res = {} ---@type string[]
                ---@cast routes table
                for name, _ in pairs(routes) do
                    if name == editName then
                        name = name .. " (editing)"
                    end
                    table.insert(res, name)
                end

                table.sort(res)

                return res
            end

            ---@param page integer
            ---@param perPage integer
            ---@return string[]
            function s.GetRoutePage(page, perPage)
                return pagination.Paginate(s.GetRouteNames(), page, perPage)
            end

            ---@param perPage integer
            ---@return integer
            function s.GetPageCount(perPage)
                return pagination.GetPageCount(s.GetRouteNames(), perPage)
            end

            ---@param page integer
            ---@param perPage integer
            ---@return NamedWaypoint[]
            function s.GetWaypointPage(page, perPage)
                return pagination.Paginate(s.GetWaypoints(), page, perPage)
            end

            ---@param perPage integer
            ---@return integer
            function s.GetWaypointPages(perPage)
                return pagination.GetPageCount(s.GetWaypoints(), perPage)
            end

            ---@return table<string, NamedWaypoint>
            local function makeWPLookup()
                -- Make a table for quick lookup
                local wps = {}
                for _, p in ipairs(s.GetWaypoints()) do
                    wps[p.name] = p
                end

                return wps
            end

            ---@return string|nil
            function s.FirstFreeWPName()
                local wps = makeWPLookup()

                for i = 1, 999 do
                    local new = string.format("WP%0.3d", i)
                    if wps[new] == nil then
                        return new
                    end
                end

                return nil
            end

            ---@param old string
            ---@param new string
            function s.RenameWaypoint(old, new)
                local wps = makeWPLookup()
                local oldFound = wps[old]
                local newFound = wps[new]

                if not oldFound then
                    log.Info("No waypoint by that name found")
                    return
                elseif newFound then
                    log.Info("A waypoint by that name already exists")
                end

                Task.New("RenameWaypoint", function()
                    if edit ~= nil then
                        log.Error("Can't rename a waypoint when a route is being edited")
                        return
                    end

                    s.StoreWaypoint(new, oldFound.point:Pos())

                    for _, name in pairs(s.GetRouteNames()) do
                        local r = s.LoadRoute(name)
                        if r then
                            local switched = false
                            for _, p in ipairs(r.Points()) do
                                if p.HasWaypointRef() and p.WaypointRef() == old then
                                    switched = true
                                    p.SetWaypointRef(new)
                                    log.Info("Waypoint ref. updated in route '", name, "': '", old, "' -> '", new, "'")
                                end
                            end

                            if switched then
                                s.StoreRoute(name, r)
                            end
                        end
                        coroutine.yield()
                    end

                    -- Delete last so that routes using it can be loaded.
                    s.DeleteWaypoint(old)
                end)
            end

            ---Returns the number of routes
            ---@return integer
            function s.Count()
                return TableLen(s.GetRouteNames())
            end

            ---Indicates if the route exists
            ---@param name string
            ---@return boolean
            function s.routeExists(name)
                local routes = db.Get(RouteController.NAMED_ROUTES) or {}
                return routes[name] ~= nil
            end

            ---Loads a named route
            ---@param name string The name of the route to load
            ---@return Route|nil
            function s.LoadRoute(name)
                local routes = db.Get(RouteController.NAMED_ROUTES) or {}
                local data = routes[name] ---@type RouteData

                if data == nil then
                    log.Error("No route by name '", name, "' found.")
                    return nil
                end

                local route = Route.New()

                -- For backwards compatibility, check if we have points as a sub property or not.
                -- This can be removed once all the development constructs have had their routes resaved.
                if not data.points then
                    log.Warning("Route is in an old format, please re-save it!")
                    data.points = data
                end

                for _, point in ipairs(data.points) do
                    local p = Point.LoadFromPOD(point)

                    if p.HasWaypointRef() then
                        local wpName = p.WaypointRef()
                        log.Debug("Loading waypoint reference '", wpName, "'")
                        local wp = s.LoadWaypoint(wpName)
                        if wp == nil then
                            log.Error("The referenced waypoint '", wpName, "' in route '", name, "' was not found")
                            return nil
                        end

                        -- Replace the point
                        p = Point.New(wp.Pos(), wpName, p.Options())
                    end

                    route.AddPoint(p)
                end

                log.Info("Route '", name, "' loaded")

                return route
            end

            ---@return Route|nil
            function s.LoadFloorRoute(name)
                floorRoute = s.LoadRoute(name)
                if s then
                    floorRouteName = name
                else
                    floorRouteName = nil
                end

                return floorRoute
            end

            ---@return Route|nil
            function s.FloorRoute()
                return floorRoute
            end

            ---@return string|nil
            function s.FloorRouteName()
                return floorRouteName
            end

            ---@return SelectablePoint[]
            function s.SelectableFloorPoints()
                local selectable = {} ---@type SelectablePoint[]

                if floorRoute then
                    local points = floorRoute.Points()
                    local distances = s.CalculateDistances(points)
                    for i, p in ipairs(points) do
                        if p.Options().Get(PointOptions.SELECTABLE, true) then
                            selectable[#selectable + 1] = {
                                visible = true,
                                name = (function()
                                    if p.HasWaypointRef() then
                                        -- Silence warning of string vs. nil, we've already checked if it has a waypoint reference
                                        return p.WaypointRef() or ""
                                    end
                                    local d = distanceFormat(distances[i])
                                    return string.format("%0.1f%s", d.value, d.unit)
                                end)(),
                                activate = string.format("route-activate '%s' -index %d", floorRouteName, i),
                                index = i
                            }
                        end
                    end
                end

                return selectable
            end

            ---Loads a named route and makes it available for editing
            ---@param name string The name of the route to load
            ---@return Route|nil
            function s.EditRoute(name)
                if edit ~= nil then
                    log.Error("A route is already being edited.")
                    return nil
                end

                edit = s.LoadRoute(name)

                if edit == nil then return end
                editName = name

                pub.Publish("RouteOpenedForEdit", true)

                return edit
            end

            ---Deletes the named route
            ---@param name string
            function s.DeleteRoute(name)
                local routes = db.Get(RouteController.NAMED_ROUTES) or {}
                local route = routes[name]

                if route == nil then
                    log.Error("No route by name '", name, "' found.")
                    return
                end

                routes[name] = nil
                db.Put(RouteController.NAMED_ROUTES, routes)
                log.Info("Route '", name, "' deleted")

                if name == editName then
                    edit = nil
                    editName = nil
                    log.Info("No route is currently being edited")
                end
            end

            ---Store the route under the given name
            ---@param name string The name to store the route as
            ---@param route Route The route to store
            ---@return boolean
            function s.StoreRoute(name, route)
                local routes = db.Get(RouteController.NAMED_ROUTES) or {}
                local data = { points = {} } ---@type RouteData

                for _, p in ipairs(route.Points()) do
                    data.points[#data.points + 1] = p.Persist()
                end

                routes[name] = data
                db.Put(RouteController.NAMED_ROUTES, routes)
                log.Info("Route '", name, "' saved.")
                return true
            end

            ---@param from string
            ---@param to string
            function s.RenameRoute(from, to)
                if s.routeExists(to) then
                    log.Error("Route already exists")
                else
                    local r = s.LoadRoute(from)
                    if r then
                        s.StoreRoute(to, r)
                        s.DeleteRoute(from)
                        log.Info("Route renamed from ", from, " to ", to)
                        return true
                    end
                end

                return false
            end

            ---Stores a waypoint under the given name
            ---@param name string The name of the waypoint
            ---@param pos string A ::pos string
            ---@return boolean
            function s.StoreWaypoint(name, pos)
                local p = universe.ParsePosition(pos)
                if p == nil then return false end

                if name == nil or string.len(name) == 0 then
                    log.Error("No name provided")
                    return false
                end

                local waypoints = db.Get(RouteController.NAMED_POINTS) or {}
                waypoints[name] = Point.New(pos).Persist()

                db.Put(RouteController.NAMED_POINTS, waypoints)
                log.Info("Waypoint saved as '", name, "'")
                return true
            end

            ---Gets the named waypoints
            ---@return WaypointMap
            local function getNamedPoints()
                local w = db.Get(RouteController.NAMED_POINTS) or {}
                ---@cast w WaypointMap
                return w
            end

            ---Returns a list of all waypoints
            ---@return NamedWaypoint[]
            function s.GetWaypoints()
                local namedPositions = getNamedPoints()

                local names = {}

                -- Create a list of the names
                for name, _ in pairs(namedPositions) do
                    table.insert(names, name)
                end

                table.sort(names)

                local res = {} ---@type NamedWaypoint[]
                for _, name in pairs(names) do
                    table.insert(res, { name = name, point = s.LoadWaypoint(name, namedPositions) })
                end

                return res
            end

            ---Loads a waypoint by the given name
            ---@param name string|nil Name of waypoint to load
            ---@param waypoints? WaypointMap An optional table to load from
            ---@return Point|nil
            function s.LoadWaypoint(name, waypoints)
                if not name then return nil end
                waypoints = waypoints or getNamedPoints()
                local pointData = waypoints[name]

                if pointData == nil then
                    return nil
                end

                return Point.LoadFromPOD(pointData)
            end

            ---Deletes a waypoint
            ---@param name string
            ---@return PointPOD|nil #The removed point
            function s.DeleteWaypoint(name)
                local waypoints = getNamedPoints()
                local found = waypoints[name]
                if found then
                    waypoints[name] = nil
                    db.Put(RouteController.NAMED_POINTS, waypoints)
                else
                    log.Error("No waypoint by name '", name, "' found.")
                end

                return found
            end

            ---Returns the current route or nil if none is active
            ---@return Route|nil
            function s.CurrentRoute()
                return current
            end

            ---Returns the route currently being edited or nil
            ---@return Route|nil
            function s.CurrentEdit()
                return edit
            end

            ---Returns the name of the route currently being edited, or nil
            ---@return string|nil
            function s.CurrentEditName()
                return editName
            end

            ---@param name string
            ---@param destinationWayPointIndex number
            ---@return Route|nil
            function s.doBasicCheckesOnActivation(name, destinationWayPointIndex)
                if not name or string.len(name) == 0 then
                    log.Error("No route name provided")
                    return nil
                end

                if editName ~= nil and name == editName and edit ~= nil then
                    log.Info("Cannot activate route currently being edited, please save first.")
                    return nil
                end

                local route = s.LoadRoute(name)

                if route == nil then
                    return nil
                elseif #route.Points() < 2 then
                    log.Error("Less than 2 points in route '", name, "'")
                    return nil
                end

                if destinationWayPointIndex < 1 or destinationWayPointIndex > #route.Points() then
                    log.Error("Destination index must be >= 1 and <= ", #route.Points(), " it was: ", destinationWayPointIndex)
                    return nil
                end

                return route
            end

            ---Activate the route by the given name
            ---@param name string
            ---@param destinationWayPointIndex? number The index of the waypoint we wish to move to. 0 means the last one in the route. This always counts in the original order of the route.
            ---@param startMargin? number The route will only be activated if within this distance.
            ---@param gateControlDistance? number Gate control will only be activated if this close to a controlled point in the route
            ---@return boolean
            function s.ActivateRoute(name, destinationWayPointIndex, startMargin, gateControlDistance)
                startMargin = startMargin or 0
                gateControlDistance = gateControlDistance or constants.route.gateControlDistance
                local candidate = s.doBasicCheckesOnActivation(name, destinationWayPointIndex or 1)

                if candidate == nil then
                    return false
                end

                local currentPos = Current()
                destinationWayPointIndex = destinationWayPointIndex or #candidate.Points()
                candidate.AdjustRouteBasedOnTarget(currentPos, destinationWayPointIndex, gateControlDistance)

                -- Check we're close enough to the closest point
                local closestPosInRoute = candidate.FindClosestPositionAlongRoute(currentPos)

                local distance = closestPosInRoute:Dist(currentPos)
                if startMargin > 0 and distance > startMargin then
                    log.Error(string.format(
                        "Currently %0.2fm from closest point in route. Please move within %0.2fm of %s and try again."
                        , distance, startMargin, universe.CreatePos(closestPosInRoute):AsPosString()))
                    return false
                end

                current = candidate
                activeRouteName = name

                log.Info("Route '", name, "' activated at index " .. destinationWayPointIndex)

                return true
            end

            ---Activate a temporary, empty, route
            ---@param name string|nil
            ---@return Route
            function s.ActivateTempRoute(name)
                current = Route.New()
                activeRouteName = name or "---"
                return current
            end

            ---Creates a route
            ---@param name string
            ---@return Route|nil
            function s.CreateRoute(name)
                if edit ~= nil then
                    log.Error("A route is being edited, can't create a new one.")
                    return nil
                end

                if name == nil or #name == 0 then
                    log.Error("No name provided for route")
                    return nil
                end

                if s.routeExists(name) then
                    log.Error("Route already exists")
                    return nil
                end

                edit = Route.New()
                editName = name
                s.SaveRoute()

                log.Info("Route '", name, "' created")
                edit = s.EditRoute(name)
                return edit
            end

            ---Saves the currently edited route
            ---@return boolean
            function s.SaveRoute()
                local res = false
                if edit and editName ~= nil then
                    res = s.StoreRoute(editName, edit)
                    editName = nil
                    edit = nil
                    log.Info("Route saved")
                    res = true
                else
                    log.Error("No route currently opened for edit.")
                end

                return res
            end

            ---Discards and currently made changes and closes the edited route
            function s.Discard()
                if edit and editName ~= nil then
                    edit = nil
                    editName = nil
                    log.Info("All changes discarded.")
                else
                    log.Error("No route currently opened for edit, nothing to discard.")
                end
            end

            ---Returns the current name
            ---@return string|nil
            function s.ActiveRouteName()
                return activeRouteName
            end

            ---Activates a route to hold position
            function s.ActivateHoldRoute()
                local route = s.ActivateTempRoute()
                local p = route.AddCurrentPos()
                local opt = p.Options()
                opt.Set(PointOptions.LOCK_DIRECTION, { Forward():Unpack() })
                opt.Set(PointOptions.FORCE_VERT, true)
            end

            ---Returns a list of point distances
            ---@param points Point[]
            function s.CalculateDistances(points)
                local d = {}

                if #points > 0 then
                    local prev = universe.ParsePosition(points[1].Pos()):Coordinates()
                    d[#d + 1] = 0
                    for i = 2, #points do
                        local curr = universe.ParsePosition(points[i].Pos()):Coordinates()
                        local diff = (curr - prev):Len()
                        d[#d + 1] = d[#d] + diff
                        prev = curr
                    end
                end

                return d
            end

            singleton = setmetatable(s, RouteController)
            return singleton
        end


        return RouteController


        end)

        package.preload['YFS:../e/lib/src/storage/DBStoredData.lua']=(function()

        local json = require("json")


        local function findAnyFunction(o)
            if type(o) ~= "table" then
                return nil
            end

            local found = nil

            for key, value in pairs(o) do
                local t = type(value)

                if t == "function" then
                    return key
                else
                    found = findAnyFunction(value)
                end

                if found then
                    return found
                end
            end

            return found
        end


        ---@class DBStoredData

        ---@field value string|number|table The data to save

        ---@field valueType string The type of data held

        ---@field dirty boolean True if it should be marked as dirty

        ---@field Persist fun():table Returns an opaque table to serialize for storage. Also marks the item as clean.

        local DBStoredData = {}

        DBStoredData.__index = DBStoredData


        function DBStoredData.New(value, dirty)
            local t = type(value)
            local foundFunctionName = findAnyFunction(value)
            if foundFunctionName then
                error(string.format("Functions not allowed in PODs: '%s'", foundFunctionName))
            end

            local s = {
                valueType = t,
                value = value,
                dirty = dirty or false
            }

            function s.Persist()
                s.dirty = false
                local str = json.encode(
                    {
                        t = s.valueType,
                        v = s.value
                    })
                return str
            end

            return setmetatable(s, DBStoredData)
        end


        ---Creates a new DBStoreData from data read from databank

        ---@param readData string

        ---@return DBStoredData|nil

        function DBStoredData.NewFromDB(readData)
            if readData ~= nil then
                local decoded

                -- Suppress decoding errors
                xpcall(function()
                    decoded = json.decode(readData)
                end, traceback)

                if decoded ~= nil
                    and type(decoded) == "table"
                    and decoded.t
                    and decoded.v ~= nil -- must check against nil, as v may be boolean 'false'
                then
                    return DBStoredData.New(decoded.v)
                end
            end

            return nil
        end


        return DBStoredData


        end)

        package.preload['YFS:../e/lib/src/storage/BufferedDB.lua']=(function()

        local Task = require('YFS:../e/lib/src/system/Task.lua')

        local log = require('YFS:../e/lib/src/debug/Log.lua').Instance()

        require('YFS:../e/lib/src/util/Table.lua')

        local DBStoredData = require('YFS:../e/lib/src/storage/DBStoredData.lua')


        ---@class BufferedDB

        ---@field BeginLoad fun() Starts loading keys into memory

        ---@field Clear fun() Clears the databank

        ---@field IsLoaded fun():boolean Returns true when all keys have been loaded.

        ---@field IsDirty fun():boolean Returns true when a key has not yet been persisted

        ---@field Get fun(key:string, default:any):number|string|boolean|table|nil Returns the value of the key, or the default value

        ---@field Number fun(key:string, default:number):number Returns the value, or default

        ---@field Boolean fun(key:string, default:boolean):boolean Returns the value, or default

        ---@field Put fun(key:string, data:number|string|boolean|table) Stores the data in key. data can be string, number or (plain data) table.

        ---@field Size fun():number Returns the number of keys


        local BufferedDB = {}

        BufferedDB.__index = BufferedDB


        ---Creates a new BufferedDB

        ---@param databank table|nil The link to the the databank element we're expecting to be connected to.

        ---@return BufferedDB

        function BufferedDB.New(databank)
            if type(databank) ~= "table" or not databank.getStringValue then
                error("databank parameter of BufferedDB.New must be a link to a databank")
            end

            local s = {}

            local buffer = {} ---@type {[string]:DBStoredData}
            local db = databank
            local loaded = false
            local dirtyCount = 0
            local task

            local function persist()
                loaded = true
                while true do
                    if s.IsDirty() then
                        for key, data in pairs(buffer) do
                            coroutine.yield()

                            if data.dirty then
                                db.setStringValue(key, data.Persist())
                                dirtyCount = dirtyCount - 1
                            end
                        end
                    end
                    coroutine.yield()
                end
            end

            ---Begins loading keys
            function s.BeginLoad()
                if task then
                    return
                end

                task = Task.New("BufferedDB", function()
                    local keys = db.getKeyList()
                    for i, k in ipairs(keys) do
                        local d = DBStoredData.NewFromDB(db.getStringValue(k))

                        if d then
                            buffer[k] = d
                        else
                            log.Error("Could not load key '", k, "'")
                        end

                        if i % 20 == 0 then
                            coroutine.yield()
                        end
                    end
                end).Then(persist).Catch(function(t)
                    log.Error("Error in BeginLoad:", t.Error())
                end)
            end

            function s.Clear()
                if loaded then
                    buffer = {}
                    dirtyCount = 0
                    db.clear()
                else
                    error("Call to Clear before loading is completed")
                end
            end

            ---Checks if all keys are loaded
            ---@return boolean
            function s.IsLoaded()
                return loaded
            end

            ---Checks if all data has been persisted
            ---@return boolean
            function s.IsDirty()
                return dirtyCount > 0
            end

            ---Gets data from key or default
            ---@param key string
            ---@param default number|string|boolean|table
            ---@return number|string|boolean|table|nil
            function s.Get(key, default)
                if loaded then
                    local entry = buffer[key]
                    if entry then
                        return entry.value
                    end
                else
                    error("Call to Get before loading is completed")
                end

                return default
            end

            ---@param key string
            ---@param default number
            function s.Number(key, default)
                return s.Get(key, default)
            end

            ---@param key string
            ---@param default boolean
            function s.Boolean(key, default)
                return s.Get(key, default)
            end

            ---Puts data in key
            ---@param key string
            ---@param data number|string|boolean|table|boolean
            function s.Put(key, data)
                if loaded then
                    buffer[key] = DBStoredData.New(data, true)
                    dirtyCount = dirtyCount + 1
                else
                    error("Call to Put before loading is completed")
                end
            end

            function s.Size()
                return TableLen(buffer)
            end

            return setmetatable(s, BufferedDB)
        end


        return BufferedDB


        end)

        package.preload['YFS:../e/lib/src/element/Container.lua']=(function()

        ---@module "element/ContainerTalents")


        ---@class Container

        ---@field New fun(itemId:integer):Container

        ---@field Name fun():string

        ---@field GetAll fun():Container[]

        ---@field FuelFillFactor fun(talents:ContainerTalents)

        ---@field ActualContentMass fun(talents:ContainerTalents)


        local core = library.getCoreUnit()

        local nitronMass = 4

        local kergonMass = 6

        local xeronMass = 0.8


        if core == nil then
            error("No core linked")
        end


        ---@alias ContainerData {Cap:number, Factor:number, FuelMass:number}

        local sizes = {} ---@type table<string,ContainerData>

        sizes["basic container xs"] = { Cap = 1000, Factor = 1 }

        sizes["uncommon optimised container xs"] = { Cap = 1300, Factor = 1 }

        sizes["advanced optimised container xs"] = { Cap = 1690, Factor = 1 }

        sizes["rare optimised container xs"] = { Cap = 2197, Factor = 1 }

        sizes["exotic optimised container xs"] = { Cap = 2856, Factor = 1 }

        sizes["uncommon gravity-inverted container xs"] = { Cap = 900, Factor = 0.9 }

        sizes["advanced gravity-inverted container xs"] = { Cap = 810, Factor = 0.81 }

        sizes["rare gravity-inverted container xs"] = { Cap = 729, Factor = 0.73 }

        sizes["exotic gravity-inverted container xs"] = { Cap = 656, Factor = 0.66 }


        sizes["basic container s"] = { Cap = 8000, Factor = 1 }

        sizes["uncommon optimised container s"] = { Cap = 10400, Factor = 1 }

        sizes["advanced optimised container s"] = { Cap = 13520, Factor = 1 }

        sizes["rare optimised container s"] = { Cap = 17576, Factor = 1 }

        sizes["exotic optimised container s"] = { Cap = 22849, Factor = 1 }

        sizes["uncommon gravity-inverted container s"] = { Cap = 7200, Factor = 0.9 }

        sizes["advanced gravity-inverted container s"] = { Cap = 6480, Factor = 0.81 }

        sizes["rare gravity-inverted container s"] = { Cap = 5832, Factor = 0.73 }

        sizes["exotic gravity-inverted container s"] = { Cap = 5249, Factor = 0.66 }


        sizes["basic container m"] = { Cap = 64000, Factor = 1 }

        sizes["uncommon optimised container m"] = { Cap = 83200, Factor = 1 }

        sizes["advanced optimised container m"] = { Cap = 108160, Factor = 1 }

        sizes["rare optimised container m"] = { Cap = 140608, Factor = 1 }

        sizes["exotic optimised container m"] = { Cap = 182790, Factor = 1 }

        sizes["uncommon gravity-inverted container m"] = { Cap = 57600, Factor = 0.9 }

        sizes["advanced gravity-inverted container m"] = { Cap = 51840, Factor = 0.81 }

        sizes["rare gravity-inverted container m"] = { Cap = 46656, Factor = 0.73 }

        sizes["exotic gravity-inverted container m"] = { Cap = 41990, Factor = 0.66 }


        sizes["basic container l"] = { Cap = 128000, Factor = 1 }

        sizes["uncommon optimised container l"] = { Cap = 166400, Factor = 1 }

        sizes["advanced optimised container l"] = { Cap = 216320, Factor = 1 }

        sizes["rare optimised container l"] = { Cap = 281216, Factor = 1 }

        sizes["exotic optimised container l"] = { Cap = 365581, Factor = 1 }

        sizes["uncommon gravity-inverted container l"] = { Cap = 115200, Factor = 0.9 }

        sizes["advanced gravity-inverted container l"] = { Cap = 103680, Factor = 0.81 }

        sizes["rare gravity-inverted container l"] = { Cap = 93312, Factor = 0.73 }

        sizes["exotic gravity-inverted container l"] = { Cap = 83981, Factor = 0.66 }


        sizes["basic container xl"] = { Cap = 256000, Factor = 1 }

        sizes["uncommon optimised container xl"] = { Cap = 332800, Factor = 1 }

        sizes["advanced optimised atmoFuelTankHandlingcontainer xl"] = { Cap = 432640, Factor = 1 }

        sizes["rare optimised container xl"] = { Cap = 562432, Factor = 1 }

        sizes["exotic optimised container xl"] = { Cap = 731162, Factor = 1 }

        sizes["uncommon gravity-inverted container xl"] = { Cap = 230400, Factor = 0.9 }

        sizes["advanced gravity-inverted container xl"] = { Cap = 207360, Factor = 0.81 }

        sizes["rare gravity-inverted container xl"] = { Cap = 186624, Factor = 0.73 }

        sizes["exotic gravity-inverted container xl"] = { Cap = 167962, Factor = 0.66 }


        sizes["expanded basic container xxl"] = { Cap = 512000, Factor = 1 }

        sizes["expanded uncommon optimised container xxl"] = { Cap = 665600, Factor = 1 }

        sizes["expanded advanced optimised container xxl"] = { Cap = 865280, Factor = 1 }

        sizes["expanded rare optimised container xxl"] = { Cap = 1124864, Factor = 1 }

        sizes["expanded exotic optimised container xxl"] = { Cap = 1462323, Factor = 1 }

        sizes["expanded uncommon gravity-inverted container xxl"] = { Cap = 460800, Factor = 0.9 }

        sizes["expanded advanced gravity-inverted container xxl"] = { Cap = 414720, Factor = 0.81 }

        sizes["expanded rare gravity-inverted container xxl"] = { Cap = 373248, Factor = 0.73 }

        sizes["expanded exotic gravity-inverted container xxl"] = { Cap = 335923, Factor = 0.66 }


        sizes["atmospheric fuel tank xs"] = { Cap = 100, Factor = 1, FuelMass = nitronMass }

        sizes["atmospheric fuel tank s"] = { Cap = 400, Factor = 1, FuelMass = nitronMass }

        sizes["atmospheric fuel tank m"] = { Cap = 1600, Factor = 1, FuelMass = nitronMass }

        sizes["atmospheric fuel tank l"] = { Cap = 12800, Factor = 1, FuelMass = nitronMass }


        sizes["space fuel tank xs"] = { Cap = 100, Factor = 1, FuelMass = kergonMass }

        sizes["space fuel tank s"] = { Cap = 400, Factor = 1, FuelMass = kergonMass }

        sizes["space fuel tank m"] = { Cap = 1600, Factor = 1, FuelMass = kergonMass }

        sizes["space fuel tank l"] = { Cap = 12800, Factor = 1, FuelMass = kergonMass }


        sizes["rocket fuel tank xs"] = { Cap = 400, Factor = 1, FuelMass = xeronMass }

        sizes["rocket fuel tank s"] = { Cap = 800, Factor = 1, FuelMass = xeronMass }

        sizes["rocket fuel tank m"] = { Cap = 6400, Factor = 1, FuelMass = xeronMass }

        sizes["rocket fuel tank l"] = { Cap = 50000, Factor = 1, FuelMass = xeronMass }


        ---Looksup the container data, or errors if not found

        ---@param name string

        ---@return ContainerData

        local function lookupContainerData(name)
            local d = sizes[name]
            if not d then
                error(string.format("Unknown container: %s", name))
            end

            return d
        end


        ---@enum ContainerType

        ContainerType = {
            Standard = 1,
            Atmospheric = 2,
            Space = 4,
            Rocket = 8,
            Fuel = 14,
            All = 15
        }


        local Container = {}

        Container.__index = Container

        local preFiltered ---@type table<ContainerType, Container[]>



        ---Creates a new container

        ---@param localId integer The local id of the container

        ---@param containerData ContainerData

        ---@return Container

        function Container.New(localId, unitMass, containerData)
            local s = {
                ---@type string
                name = core.getElementNameById(localId)
            }

            local function standardVolume(containerProficiency)
                return containerData.Cap * (1 + containerProficiency / 10) -- 10% per level
            end

            local function fuelVolume(containerProficiency)
                return containerData.Cap * (1 + containerProficiency / 5) -- 20% per level
            end

            local function rawContentMass()
                return core.getElementMassById(localId) - unitMass;
            end

            ---Returns to which factor (0...1) the container is filled, if it is a fuel tank; otherwise 0.
            ---@param talents ContainerTalents
            function s.FuelFillFactor(talents)
                if not containerData.FuelMass then return 0 end

                local reducedMass = rawContentMass()
                local actualMass = reducedMass

                if talents.FuelTankOptimization > 0 or talents.ContainerOptimization > 0 then
                    actualMass = reducedMass / (1 - (talents.FuelTankOptimization + talents.ContainerOptimization) * 0.05)
                end

                local volume
                if containerData.FuelMass == xeronMass then
                    volume = standardVolume(talents.RocketFuelTankHandling)
                elseif containerData.FuelMass == kergonMass then
                    volume = fuelVolume(talents.SpaceFuelTankHandling)
                else
                    volume = fuelVolume(talents.AtmoFuelTankHandling)
                end

                local currentLiters = actualMass / containerData.FuelMass
                local fillFactor = currentLiters / volume

                return fillFactor
            end

            ---@param talents ContainerTalents
            function s.ActualContentMass(talents)
                local reducedMass = rawContentMass()
                local actualMass = reducedMass
                if talents.ContainerOptimization > 0 then
                    actualMass = reducedMass / (1 - talents.ContainerOptimization * 0.05)
                end

                return actualMass
            end

            ---Gets the container name
            ---@return string
            function s.Name()
                return s.name
            end

            return setmetatable(s, Container)
        end


        ---@param localId number

        ---@return Container

        local function makeContainer(localId)
            local itemId = core.getElementItemIdById(localId)
            ---@type {name:string, unitMass:number, unitVolume:number, displayNameWithSize:string}
            local data = system.getItem(itemId)
            local lowerName = data.displayNameWithSize:lower()
            local containerData = lookupContainerData(lowerName)
            return Container.New(localId, data.unitMass, containerData)
        end


        ---@param input ContainerType

        ---@param wanted ContainerType

        local function hasBit(input, wanted)
            return (input & wanted) == wanted
        end


        ---Gets all containers. Only call from a coroutine

        ---@param filter ContainerType|integer

        ---@return Container[]

        function Container.GetAllCo(filter)
            local containers = {} ---@type Container[]

            if not preFiltered then
                preFiltered = {}
                preFiltered[ContainerType.Standard] = {}
                preFiltered[ContainerType.Atmospheric] = {}
                preFiltered[ContainerType.Space] = {}
                preFiltered[ContainerType.Rocket] = {}


                ---@diagnostic disable-next-line: undefined-field
                for i, localId in ipairs(core.getElementIdList()) do
                    local elementClass = core.getElementClassById(localId) ---@type string
                    elementClass = elementClass:lower()

                    if not elementClass:find("itemcontainer") then -- filter hubs
                        if elementClass:find("atmofuelcontainer") then
                            table.insert(preFiltered[ContainerType.Atmospheric], makeContainer(localId))
                        elseif elementClass:find("spacefuelcontainer") then
                            table.insert(preFiltered[ContainerType.Space], makeContainer(localId))
                        elseif elementClass:find("rocketfuelcontainer") then
                            table.insert(preFiltered[ContainerType.Rocket], makeContainer(localId))
                        elseif elementClass:find("container") and elementClass:find("fuel") then
                            table.insert(preFiltered[ContainerType.Standard], makeContainer(localId))
                        end
                    end

                    if i % 10 == 0 then
                        coroutine.yield()
                    end
                end
            end

            if (hasBit(filter, ContainerType.Atmospheric)) then
                CopyList(containers, preFiltered[ContainerType.Atmospheric])
            end

            if (hasBit(filter, ContainerType.Space)) then
                CopyList(containers, preFiltered[ContainerType.Space])
            end

            if (hasBit(filter, ContainerType.Rocket)) then
                CopyList(containers, preFiltered[ContainerType.Rocket])
            end

            if (hasBit(filter, ContainerType.Standard)) then
                CopyList(containers, preFiltered[ContainerType.Standard])
            end

            return containers
        end


        return Container


        end)

        package.preload['YFS:../e/lib/src/element/ContainerTalents.lua']=(function()

        ---@class ContainerTalents

        ---@field New fun(containerProficiency:integer, fuelTankOptimization:integer,containerOptimization:integer,atmoFuelTankHandling:integer,spaceFuelTankHandling:integer,rocketFuelTankHandling:integer):ContainerSkills

        ---@field ContainerProficiency integer

        ---@field FuelTankOptimization integer

        ---@field ContainerOptimization integer

        ---@field AtmoFuelTankHandling integer

        ---@field SpaceFuelTankHandling integer

        ---@field RocketFuelTankHandling integer


        local ContainerSkills = {}

        ContainerSkills.__index = ContainerSkills


        ---@param containerProficiency integer,

        ---@param fuelTankOptimization integer,

        ---@param containerOptimization integer,

        ---@param atmoFuelTankHandling integer,

        ---@param spaceFuelTankHandling integer,

        ---@param rocketFuelTankHandling integer

        ---@return ContainerTalents

        function ContainerSkills.New(containerProficiency, fuelTankOptimization, containerOptimization, atmoFuelTankHandling,
                                     spaceFuelTankHandling, rocketFuelTankHandling)
            local s = {
                ContainerProficiency = containerProficiency or 0,
                FuelTankOptimization = fuelTankOptimization or 0,
                ContainerOptimization = containerOptimization or 0,
                AtmoFuelTankHandling = atmoFuelTankHandling or 0,
                SpaceFuelTankHandling = spaceFuelTankHandling or 0,
                RocketFuelTankHandling = rocketFuelTankHandling or 0
            }

            return setmetatable(s, ContainerSkills)
        end


        return ContainerSkills


        end)

        package.preload['YFS:../e/render/src/native/Vec2.lua']=(function()

        --- A 2 component vector based on cpml/Vec2

        --- https://github.com/excessive/cpml/blob/master/modules/Vec2.lua


        local atan2 = math.atan

        local sqrt  = math.sqrt

        local cos   = math.cos

        local sin   = math.sin

        local abs   = math.abs


        ---@class Vec2

        ---@field x number

        ---@field y number

        ---@field New fun(x:number|{x:number,y:number}|number[], y:number|nil):Vec2

        ---@field unit_x Vec2 X axis of rotation

        ---@field unit_y Vec2 Y axis of rotation

        ---@field zero Vec2 Empty vector

        ---@field FromCartesian fun(radius:number, theta:number):Vec2

        ---@field Clone fun(v:Vec2):Vec2

        ---@field Add fun(a:Vec2, b:Vec2):Vec2 Add two vectors.

        ---@field Sub fun(a:Vec2, b:Vec2):Vec2 Subtract two vectors.

        ---@field Mul fun(a:Vec2, b:Vec2):Vec2 Multiply two vectors.

        ---@field Div fun(a:Vec2, b:Vec2):Vec2 Divide two vectors.

        ---@field Normalize fun(a:Vec2):Vec2

        ---@field Trim fun(a:Vec2, len:number):Vec2

        ---@field Cross fun(a:Vec2, b:Vec2):number

        ---@field Dot fun(a:Vec2, b:Vec2):number

        ---@field Len fun(a:Vec2):number

        ---@field Len2 fun(a:Vec2):number

        ---@field Dist fun(a:Vec2, b:Vec2):number

        ---@field Dist2 fun(a:Vec2, b:Vec2):number

        ---@field Scale fun(a:Vec2, b:number):Vec2

        ---@field Rotate fun(a:Vec2, phi:number)

        ---@field Perpendicular fun(a:Vec2):Vec2

        ---@field AngleTo fun(a:Vec2, b:Vec2):number

        ---@field Lerp fun(a:Vec2, b:Vec2, s:number):Vec2

        ---@field Unpack fun(a:Vec2):number, number

        ---@field ComponentMin fun(a:Vec2, b:Vec2):Vec2

        ---@field ComponentMax fun(a:Vec2, b:Vec2):Vec2

        ---@field IsVec2 fun(a:Vec2):boolean

        ---@field IsZero fun(a:Vec2):boolean

        ---@field ToPolar fun(a:Vec2):number, number

        ---@field FlipX fun(a:Vec2):Vec2

        ---@field FlipY fun(a:Vec2):Vec2

        ---@field Abs fun(a:Vec2):Vec2

        ---@field ToString fun(a:Vec2):string

        ---@operator add(Vec2):Vec2

        ---@operator sub(Vec2):Vec2

        ---@operator div(Vec2):Vec2

        ---@operator div(number):Vec2

        ---@operator mul(Vec2):Vec2

        ---@operator mul(number):Vec2

        ---@operator unm:Vec2


        local Vec2 = {}

        Vec2.__index = Vec2


        ---Create a new Vec2

        ---@param x number|{x:number,y:number}|number[]|nil

        ---@param y number|nil

        ---@return Vec2

        function Vec2.New(x, y)
            local s = {}

            if x and y then
                s.x = x
                s.y = y
                -- {x, y} or {x=x, y=y}
            elseif type(x) == "table" then
                s.x, s.y = x.x or x[1], x.y or x[2]
            elseif type(x) == "number" then
                s.x = x
                s.y = x
            else
                s.x = 0
                s.y = 0
            end

            return setmetatable(s, Vec2)
        end


        Vec2.unit_x = Vec2.New(1, 0)

        Vec2.unit_y = Vec2.New(0, 1)

        Vec2.zero   = Vec2.New(0, 0)


        ---Convert point from polar to cartesian.

        ---@param radius number Radius of the point

        ---@param theta number Angle of the point (in radians)

        ---@return Vec2

        function Vec2.FromCartesian(radius, theta)
            return Vec2.New(radius * cos(theta), radius * sin(theta))
        end


        ---Clone a vector.

        ---@param a Vec2 Vector to be cloned

        ---@return Vec2

        function Vec2.Clone(a)
            return Vec2.New(a.x, a.y)
        end


        ---Add two vectors.

        ---@param a Vec2 Left hand operand

        ---@param b Vec2 Right hand operand

        ---@return Vec2 out

        function Vec2.Add(a, b)
            return Vec2.New(
                a.x + b.x,
                a.y + b.y
            )
        end


        ---Subtract one vector from another.

        ---Order: If a and b are positions, computes the direction and distance from b

        ---to a.

        ---@param a Vec2 Left hand operand

        ---@param b Vec2 Right hand operand

        ---@return Vec2 out

        function Vec2.Sub(a, b)
            return Vec2.New(
                a.x - b.x,
                a.y - b.y
            )
        end


        --- Multiply a vector by another vector.

        -- Component-size multiplication not matrix multiplication.

        ---@param a Vec2  Left hand operand

        ---@param b Vec2  Right hand operand

        ---@return Vec2 out

        function Vec2.Mul(a, b)
            return Vec2.New(
                a.x * b.x,
                a.y * b.y
            )
        end


        --- Divide a vector by another vector.

        -- Component-size inv multiplication. Like a non-uniform scale().

        ---@param a Vec2  Left hand operand

        ---@param b Vec2  Right hand operand

        ---@return Vec2 out

        function Vec2.Div(a, b)
            return Vec2.New(
                a.x / b.x,
                a.y / b.y
            )
        end


        --- Get the normal of a vector.

        ---@param a Vec2  Vector to normalize

        ---@return Vec2 out

        function Vec2.Normalize(a)
            if a:IsZero() then
                return Vec2.New()
            end
            return a:Scale(1 / a:Len())
        end


        --- Trim a vector to a given length.

        ---@param a Vec2  Vector to be trimmed

        ---@param len number Length to trim the vector to

        ---@return Vec2

        function Vec2.Trim(a, len)
            return a:Normalize():Scale(math.min(a:Len(), len))
        end


        --- Get the cross product of two vectors.

        -- Order: Positive if a is clockwise from b. Magnitude is the area spanned by

        -- the parallelograms that a and b span.

        ---@param a Vec2  Left hand operand

        ---@param b Vec2  Right hand operand

        ---@return number

        function Vec2.Cross(a, b)
            return a.x * b.y - a.y * b.x
        end


        --- Get the dot product of two vectors.

        ---@param a Vec2  Left hand operand

        ---@param b Vec2  Right hand operand

        ---@return number

        function Vec2.Dot(a, b)
            return a.x * b.x + a.y * b.y
        end


        --- Get the length of a vector.

        ---@param a Vec2  Vector to get the length of

        ---@return number

        function Vec2.Len(a)
            return sqrt(a.x * a.x + a.y * a.y)
        end


        --- Get the squared length of a vector.

        ---@param a Vec2  Vector to get the squared length of

        ---@return number

        function Vec2.Len2(a)
            return a.x * a.x + a.y * a.y
        end


        --- Get the distance between two vectors.

        ---@param a Vec2  Left hand operand

        ---@param b Vec2  Right hand operand

        ---@return number

        function Vec2.Dist(a, b)
            local dx = a.x - b.x
            local dy = a.y - b.y
            return sqrt(dx * dx + dy * dy)
        end


        --- Get the squared distance between two vectors.

        ---@param a Vec2  Left hand operand

        ---@param b Vec2  Right hand operand

        ---@return number

        function Vec2.Dist2(a, b)
            local dx = a.x - b.x
            local dy = a.y - b.y
            return dx * dx + dy * dy
        end


        --- Scale a vector by a scalar.

        ---@param a Vec2  Left hand operand

        ---@param b number Right hand operand

        ---@return Vec2 out

        function Vec2.Scale(a, b)
            return Vec2.New(
                a.x * b,
                a.y * b
            )
        end


        --- Rotate a vector.

        ---@param a Vec2  Vector to rotate

        ---@param phi number Angle to rotate vector by (in radians)

        ---@return Vec2 out

        function Vec2.Rotate(a, phi)
            local c = cos(phi)
            local s = sin(phi)
            return Vec2.New(
                c * a.x - s * a.y,
                s * a.x + c * a.y
            )
        end


        --- Get the perpendicular vector of a vector.

        ---@param a Vec2  Vector to get perpendicular axes from

        ---@return Vec2 out

        function Vec2.Perpendicular(a)
            return Vec2.New(-a.y, a.x)
        end


        --- Signed angle from one vector to another.

        -- Rotations from +x to +y are positive.

        ---@param a Vec2  Vector

        ---@param b Vec2  Vector

        ---@return number angle in [-pi, pi]

        function Vec2.AngleTo(a, b)
            if b then
                local angle = atan2(b.y, b.x) - atan2(a.y, a.x)
                -- convert to (-pi, pi]
                if angle > math.pi then
                    angle = angle - 2 * math.pi
                elseif angle <= -math.pi then
                    angle = angle + 2 * math.pi
                end
                return angle
            end

            return atan2(a.y, a.x)
        end


        --- Lerp between two vectors.

        ---@param a Vec2  Left hand operand

        ---@param b Vec2  Right hand operand

        ---@param s number Step value

        ---@return Vec2

        function Vec2.Lerp(a, b, s)
            return a + (b - a) * s
        end


        --- Unpack a vector into individual components.

        ---@param a Vec2  Vector to unpack

        ---@return number x

        ---@return number y

        function Vec2.Unpack(a)
            return a.x, a.y
        end


        --- Return the component-wise minimum of two vectors.

        ---@param a Vec2  Left hand operand

        ---@param b Vec2  Right hand operand

        ---@return Vec2 A vector where each component is the lesser value for that component between the two given vectors.

        function Vec2.ComponentMin(a, b)
            return Vec2.New(math.min(a.x, b.x), math.min(a.y, b.y))
        end


        --- Return the component-wise maximum of two vectors.

        ---@param a Vec2  Left hand operand

        ---@param b Vec2  Right hand operand

        ---@return Vec2 A vector where each component is the lesser value for that component between the two given vectors.

        function Vec2.ComponentMax(a, b)
            return Vec2.New(math.max(a.x, b.x), math.max(a.y, b.y))
        end


        --- Return a boolean showing if a table is or is not a Vec2.

        ---@param a any  Vector to be tested

        ---@return boolean is_Vec2

        function Vec2.IsVec2(a)
            return type(a) == "table" and
                type(a.x) == "number" and
                type(a.y) == "number"
        end


        --- Return a boolean showing if a table is or is not a zero Vec2.

        ---@param a Vec2  Vector to be tested

        ---@return boolean is_zero

        function Vec2.IsZero(a)
            return a.x == 0 and a.y == 0
        end


        --- Convert point from cartesian to polar.

        ---@param a Vec2  Vector to convert

        ---@return number radius

        ---@return number theta

        function Vec2.ToPolar(a)
            local radius = sqrt(a.x ^ 2 + a.y ^ 2)
            local theta  = atan2(a.y, a.x)
            theta        = theta > 0 and theta or theta + 2 * math.pi
            return radius, theta
        end


        -- Negate x axis only of vector.

        ---@param a Vec2  Vector to x-flip.

        ---@return Vec2 x-flipped vector

        function Vec2.FlipX(a)
            return Vec2.New(-a.x, a.y)
        end


        -- Negate y axis only of vector.

        ---@param a Vec2  Vector to y-flip.

        ---@return Vec2 y-flipped vector

        function Vec2.FlipY(a)
            return Vec2.New(a.x, -a.y)
        end


        -- Returns the absolute value

        ---@param a Vec2  Vector to abs

        ---@return Vec2

        function Vec2.Abs(a)
            return Vec2.New(abs(a.x), abs(a.y))
        end


        --- Return a formatted string.

        ---@param a Vec2  Vector to be turned into a string

        ---@return string formatted

        function Vec2.ToString(a)
            return string.format("(%+0.3f,%+0.3f)", a.x, a.y)
        end


        function Vec2.__tostring(a)
            return a:ToString()
        end


        ---Negation operator

        ---@param a Vec2

        ---@return Vec2

        function Vec2.__unm(a)
            return Vec2.New(-a.x, -a.y)
        end


        ---Equality operator

        ---@param a Vec2|any

        ---@param b Vec2|any

        ---@return boolean

        function Vec2.__eq(a, b)
            if not Vec2.IsVec2(a) or not Vec2.IsVec2(b) then
                return false
            end
            return a.x == b.x and a.y == b.y
        end


        ---Addition operator

        ---@param a Vec2

        ---@param b Vec2

        ---@return Vec2

        function Vec2.__add(a, b)
            return a:Add(b)
        end


        ---Subtraction operator

        ---@param a Vec2

        ---@param b Vec2

        ---@return Vec2

        function Vec2.__sub(a, b)
            return a:Sub(b)
        end


        ---Multiplication operator

        ---@param a Vec2

        ---@param b Vec2|number

        ---@return Vec2

        function Vec2.__mul(a, b)
            if Vec2.IsVec2(b) then
                ---@cast b Vec2
                return a:Mul(b)
            end

            ---@cast b number
            return a:Scale(b)
        end


        ---Division operator

        ---@param a Vec2

        ---@param b Vec2|number

        ---@return Vec2

        function Vec2.__div(a, b)
            if Vec2.IsVec2(b) then
                ---@cast b Vec2
                return a:Div(b)
            end

            return a:Scale(1 / b)
        end


        ---Creates a Vec2 from a string

        ---@param s string

        ---@return Vec2|nil

        function Vec2.FromString(s)
            if s then
                local x, y = s:match("^%(%s?([+-]*%d*%.?%d+)%s?,%s?([+-]*%d*%.?%d+)%s?%)$")
                x = tonumber(x)
                y = tonumber(y)
                if x and y then
                    return Vec2.New(x, y)
                end
            end
            return nil
        end


        return Vec2


        end)

        package.preload['YFS:info/Fuel.lua']=(function()

        require('YFS:GlobalTypes.lua')

        local s                                       = require('YFS:Singletons.lua')

        local log, pub                                = s.log, s.pub


        local Container, ContainerTalents, Task, Vec2 = require('YFS:../e/lib/src/element/Container.lua'), require('YFS:../e/lib/src/element/ContainerTalents.lua'),
            require('YFS:../e/lib/src/system/Task.lua'), require('YFS:../e/render/src/native/Vec2.lua')
        require('YFS:../e/lib/src/util/Table.lua')


        ---@alias FuelTankInfo {name:string, factorBar:Vec2, percent:number, visible:boolean, type:string}


        ---@class Fuel

        ---@field Instance fun():Fuel


        local Fuel   = {}

        Fuel.__index = Fuel

        local instance


        ---@param settings Settings

        ---@return Fuel

        function Fuel.New(settings)
            if instance then
                return instance
            end

            local talents = ContainerTalents.New(
                settings.Number("containerProficiency", 0),
                settings.Number("fuelTankOptimization", 0),
                settings.Number("containerOptimization", 0),
                settings.Number("atmoFuelTankHandling", 0),
                settings.Number("spaceFuelTankHandling", 0),
                settings.Number("rocketFuelTankHandling", 0))

            local s = {}

            Task.New("FuelMonitor", function()
                local sw = Stopwatch.New()
                sw.Start()

                local fuelTanks = {
                    atmo = Container.GetAllCo(ContainerType.Atmospheric),
                    space = Container.GetAllCo(ContainerType.Space),
                    rocket = Container.GetAllCo(ContainerType.Rocket)
                }

                while true do
                    if sw.IsRunning() and sw.Elapsed() < 2 then
                        coroutine.yield()
                    else
                        local byType = {} ---@type table<string,FuelTankInfo[]>

                        for fuelType, tanks in pairs(fuelTanks) do
                            for _, tank in ipairs(tanks) do
                                local factor = tank.FuelFillFactor(talents)
                                local curr = {
                                    name = tank.Name(),
                                    factorBar = Vec2.New(1, factor),
                                    percent = factor * 100,
                                    visible = true,
                                    type = fuelType
                                }

                                local bt = byType[fuelType] or {}
                                bt[#bt + 1] = curr
                                byType[fuelType] = bt
                            end

                            -- Sort tanks for HUD in alphabetical order
                            if byType[fuelType] then
                                table.sort(byType[fuelType], function(a, b)
                                    return a.name < b.name
                                end)
                            end
                        end

                        pub.Publish("FuelByType", DeepCopy(byType))

                        sw.Restart()
                    end
                end
            end).Then(function(...)
                log.Info("No fuel tanks detected")
            end).Catch(function(t)
                log.Error(t.Name(), t.Error())
            end)

            settings.Callback("containerProficiency", function(value)
                talents.ContainerProficiency = value
            end)

            settings.Callback("fuelTankOptimization", function(value)
                talents.FuelTankOptimization = value
            end)

            settings.Callback("containerOptimization", function(value)
                talents.ContainerOptimization = value
            end)

            settings.Callback("atmoFuelTankHandling", function(value)
                talents.AtmoFuelTankHandling = value
            end)

            settings.Callback("spaceFuelTankHandling", function(value)
                talents.SpaceFuelTankHandling = value
            end)

            settings.Callback("rocketFuelTankHandling", function(value)
                talents.RocketFuelTankHandling = value
            end)

            instance = setmetatable(s, Fuel)
            return instance
        end


        return Fuel


        end)

        package.preload['YFS:Settings.lua']=(function()

        local log, cmd, constants = require('YFS:../e/lib/src/debug/Log.lua').Instance(),
            require('YFS:../e/lib/src/commandline/CommandLine.lua').Instance(),
            require('YFS:YFSConstants.lua')

        ---@module "storage/BufferedDB"


        ---@class Settings

        ---@field Create fun(db:BufferedDB):Settings

        ---@field Instance fun():Settings

        ---@field Callback fun(key:string, f:fun(any))

        ---@field Reload fun()

        ---@field Get fun(key:string, default?:any):string|number|table|nil

        ---@field Number fun(key:string, default?:number):number

        ---@field Boolean fun(key:string, default?:boolean):boolean

        ---@field String fun(key:string, default?:string):string


        local singleton

        local Settings            = {}

        Settings.__index          = Settings


        ---Creates a new Setting

        ---@param db BufferedDB

        ---@return Settings

        function Settings.Create(db)
            if singleton then
                return singleton
            end

            local s = {}

            local subscribers = {} ---@type table<string,fun(any)[]>

            local function publishToSubscribers(key, value)
                -- Notify subscribers for the key
                local subs = subscribers[key]
                if subs then
                    for _, f in pairs(subs) do
                        f(value)
                    end
                end
            end

            local containerSettings = {
                containerProficiency = { default = 0 },
                fuelTankOptimization = { default = 0 },
                containerOptimization = { default = 0 },
                atmoFuelTankHandling = { default = 0 },
                spaceFuelTankHandling = { default = 0 },
                rocketFuelTankHandling = { default = 0 },
            }

            local f = constants.flight
            local speedPid = f.speedPid
            local lightPid = f.axis.light
            local heavyPid = f.axis.heavy
            local routeDefaults = constants.route
            ---@type {default:string|number|boolean}
            local settings = {
                engineWarmup = { default = 1 },
                speedp = { default = speedPid.p },
                speedi = { default = speedPid.i },
                speedd = { default = speedPid.d },
                speeda = { default = speedPid.a },
                lightp = { default = lightPid.p },
                lighti = { default = lightPid.i },
                lightd = { default = lightPid.d },
                lighta = { default = lightPid.a },
                heavyp = { default = heavyPid.p },
                heavyi = { default = heavyPid.i },
                heavyd = { default = heavyPid.d },
                heavya = { default = heavyPid.a },
                autoShutdownFloorDistance = { default = routeDefaults.autoShutdownFloorDistance },
                autoBrakeDelay = { default = 1 },
                yawAlignmentThrustLimiter = { default = routeDefaults.yawAlignmentThrustLimiter },
                pitchAlignmentThrustLimiter = { default = routeDefaults.pitchAlignmentThrustLimiter },
                rollAlignmentThrustLimiter = { default = routeDefaults.rollAlignmentThrustLimiter },
                autoPitch = { default = false },
                routeStartDistanceLimit = { default = routeDefaults.routeStartDistanceLimit },
                showWidgetsOnStart = { default = constants.widgets.showOnStart },
                throttleStep = { default = constants.flight.throttleStep },
                manualControlOnStartup = { default = false },
                turnAngle = { default = constants.flight.defaultTurnAngle },
                minimumPathCheckOffset = { default = f.minimumPathCheckOffset },
                showFloor = { default = "-" },
                pathAlignmentAngleLimit = { default = f.pathAlignmentAngleLimit },
                pathAlignmentDistanceLimit = { default = f.pathAlignmentDistanceLimit },
                pathAlignmentDistanceLimitFromSurface = { default = 0 },
                setWaypointAlongRoute = { default = false },
                commChannel = { default = "" },
                shutdownDelayForGate = { default = 2 },
                openGateWaitDelay = { default = 3 },
                gateControlDistance = { default = routeDefaults.gateControlDistance },
                dockingMode = { default = 1 }, -- 1 = Manual, 2 = Automatic, 3 = Only own constructs,
                globalMaxSpeed = { default = 0 },
                showRadarOnStart = { default = false },
                defaultRadarMode = { default = 1 },
                allowForwardToggle = { default = false },
                autoBrakeAngle = { default = 45 },
                parkMaxSpeed = { default = 50 },
                parkMargin = { default = 0.5 },
                parkVertDist = { default = 0 },
                parkForwardDist = { default = 0 },
                parkUseGates = { default = false }
            }

            for k, v in pairs(containerSettings) do
                settings[k] = v
            end

            local set = cmd.Accept("set",
                ---@param data table
                function(data)
                    for key, _ in pairs(settings) do
                        local val = data[key]
                        if val ~= nil then
                            db.Put(key, val)
                            publishToSubscribers(key, val)
                            log.Info("Set '", key, "' to '", val, "'")
                        end
                    end
                end)

            for key, v in pairs(settings) do
                local opt = string.format("-%s", key)
                if type(v.default) == "number" then
                    set.Option(opt).AsNumber()
                elseif type(v.default) == "string" then
                    set.Option(opt).AsString()
                elseif type(v.default) == "boolean" then
                    set.Option(opt).AsBoolean()
                end
            end

            cmd.Accept("reset-settings", function(_)
                for key, value in pairs(settings) do
                    db.Put(key, value.default)
                    log.Info("Reset '", key, "' to '", value.default, "'")
                end

                s.Reload()
            end)


            local freeModeSettings = {
                autoBrakeDelay = 0,
                allowForwardToggle = true,
                manualControlOnStartup = true,
                minimumPathCheckOffset = 5000,
                turnAngle = 8,
                yawAlignmentThrustLimiter = 360,
                pitchAlignmentThrustLimiter = 360,
                rollAlignmentThrustLimiter = 360,
                pathAlignmentDistanceLimitFromSurface = 0,
                autoPitch = true
            }

            local function setModeOpts(useDefault)
                for k, v in pairs(freeModeSettings) do
                    if useDefault then
                        v = settings[k].default
                    end
                    db.Put(k, v)
                    log.Info("Set ", k, " to ", v)
                end
                s.Reload()
            end

            cmd.Accept("strict-mode", function()
                setModeOpts(true)
                log.Info("Settings adjusted for strict mode")
            end)

            cmd.Accept("free-mode", function()
                setModeOpts(false)
                log.Info("Settings adjusted for free mode")
            end)

            cmd.Accept("get",
                ---@param data {commandValue:string}
                function(data)
                    local setting = settings[data.commandValue]

                    if setting == nil then
                        log.Error("Unknown setting: ", data.commandValue)
                        return
                    end


                    log.Info(data.commandValue, ": ", s.Get(data.commandValue, setting.default))
                end).AsString().Must()

            cmd.Accept("get-all", function(_)
                local keys = {} ---@type string[]
                for key, _ in pairs(settings) do
                    keys[#keys + 1] = key
                end

                table.sort(keys)

                for _, key in pairs(keys) do
                    log.Info(key, ": ", s.Get(key))
                end
            end)

            cmd.Accept("set-full-container-boosts", function(_)
                for key, _ in pairs(containerSettings) do
                    cmd.Exec(string.format("set -%s %d", key, 5))
                end
            end)

            ---@param key string The key to get notified of
            ---@param func fun(any) A function with signature function(value)
            function s.Callback(key, func)
                if not subscribers[key] then
                    subscribers[key] = {}
                end

                table.insert(subscribers[key], func)
            end

            ---@param key string
            ---@param default? string|number|table|boolean|nil
            ---@return string|number|table|boolean|nil
            function s.Get(key, default)
                local setting = settings[key]

                -- If no default is provided, use the one in the definition
                if default == nil then
                    return db.Get(key, setting.default)
                end

                return db.Get(key, default)
            end

            ---@param key string
            ---@param default? boolean
            ---@return boolean
            function s.Boolean(key, default)
                local v = s.Get(key, default)
                ---@cast v boolean
                return v
            end

            ---@param key string
            ---@param default? number
            ---@return number
            function s.Number(key, default)
                local v = s.Get(key, default)
                ---@cast v number
                return v
            end

            ---@param key string
            ---@param default? string
            ---@return string
            function s.String(key, default)
                local v = s.Get(key, default)
                ---@cast v string
                return v
            end

            function s.Reload()
                for key, _ in pairs(settings) do
                    local stored = s.Get(key)
                    publishToSubscribers(key, stored)
                end
            end

            singleton = setmetatable(s, Settings)
            return singleton
        end


        ---@return Settings

        function Settings.Instance()
            if not singleton then
                error("Settings not yet created")
            end

            return singleton
        end


        return Settings


        end)

        package.preload['YFS:flight/AxisControl.lua']=(function()

        require('YFS:../e/lib/src/abstraction/Vehicle.lua')

        local si, Vec3, PID                     = require('YFS:Singletons.lua'), require('YFS:../e/lib/src/math/Vec3.lua'), require("cpml/pid")

        local yfsC, pub, calc                   = si.constants, si.pub, si.calc


        local SignLargestAxis, SignedRotationAngle, setEngineCommand,

        LightConstructMassThreshold, nullVec    =
            calc.SignLargestAxis,
            calc.SignedRotationAngle,
            unit.setEngineCommand,
            yfsC.flight.lightConstructMassThreshold,
            Vec3.zero

        local rad2deg                           = 180 / math.pi


        local control                           = {}

        control.__index                         = control


        ---@enum ControlledAxis

        ControlledAxis                          = {
            Pitch = 1,
            Roll = 2,
            Yaw = 3,
        }


        local finalAcceleration                 = {} ---@type Vec3[]

        finalAcceleration[ControlledAxis.Pitch] = nullVec

        finalAcceleration[ControlledAxis.Roll]  = nullVec

        finalAcceleration[ControlledAxis.Yaw]   = nullVec


        ---@class AxisControl

        ---@field ReceiveEvents fun()

        ---@field StopEvents fun()

        ---@field Disable fun()

        ---@field Speed fun():number

        ---@field Acceleration fun():number

        ---@field AxisFlush fun(deltaTime:number)

        ---@field Update fun()

        ---@field SetTarget fun(target:Vec3)

        ---@field OffsetDegrees fun():number

        ---@field Apply fun()


        local AxisControl                       = {}

        AxisControl.__index                     = AxisControl



        ---Creates a new AxisControl

        ---@param axis ControlledAxis

        ---@return AxisControl A new AxisControl

        function AxisControl.New(axis)
            local s = {}

            local reference = nil ---@type fun():Vec3
            local normal = nil ---@type fun():Vec3
            local localNormal = nil ---@type fun():Vec3

            local updateHandlerId = nil
            local targetCoordinate = nil ---@type Vec3|nil

            -- taylor local lightPid = PID(1, 10, 100, 0.1)

            local set, axisPids = require('YFS:Settings.lua').Instance(), yfsC.flight.axis
            local l = axisPids.light
            local h = axisPids.heavy

            local lightPid = PID(l.p, l.i, l.d, l.a)
            local heavyPid = PID(h.p, h.i, h.d, h.a)
            set.Callback("lightp", function(v) lightPid = PID(v, lightPid.i, lightPid.d, lightPid.amortization) end)
            set.Callback("lighti", function(v) lightPid = PID(lightPid.p, v, lightPid.d, lightPid.amortization) end)
            set.Callback("lightd", function(v) lightPid = PID(lightPid.p, lightPid.i, v, lightPid.amortization) end)
            set.Callback("lighta", function(v) lightPid = PID(lightPid.p, lightPid.i, lightPid.d, v) end)

            set.Callback("heavyp", function(v) heavyPid = PID(v, heavyPid.i, heavyPid.d, heavyPid.amortization) end)
            set.Callback("heavyi", function(v) heavyPid = PID(heavyPid.p, v, heavyPid.d, heavyPid.amortization) end)
            set.Callback("heavyd", function(v) heavyPid = PID(heavyPid.p, heavyPid.i, v, heavyPid.amortization) end)
            set.Callback("heavya", function(v) heavyPid = PID(heavyPid.p, heavyPid.i, heavyPid.d, v) end)

            local pubTopic
            local lastReadMass = TotalMass()

            local axisData = {
                speed = 0,
                acceleration = 0,
                offset = 0 -- in degrees
            }

            if axis == ControlledAxis.Pitch then
                reference = Forward
                normal = Right
                localNormal = LocalRight
                pubTopic = "PitchData"
            elseif axis == ControlledAxis.Roll then
                reference = Up
                normal = Forward
                localNormal = LocalForward
                pubTopic = "RollData"
            elseif axis == ControlledAxis.Yaw then
                reference = Forward
                normal = Up
                localNormal = LocalUp
                pubTopic = "YawData"
            end

            function s.ReceiveEvents()
                updateHandlerId = system:onEvent("onUpdate", s.Update, s)
            end

            function s.StopEvents()
                system:clearEvent("update", updateHandlerId)
            end

            ---Set the alignment target/point
            ---@param target Vec3
            function s.SetTarget(target)
                if target == nil then
                    s.Disable()
                else
                    targetCoordinate = target
                end
            end

            function s.Disable()
                targetCoordinate = nil
                finalAcceleration[axis] = nullVec
            end

            ---Returns the current signed angular velocity, in degrees per seconds.
            ---@return number
            function s.Speed()
                local vel = LocalAngVel() * rad2deg
                vel = vel * localNormal()

                -- The normal vector gives the correct x, y or z axis part of the speed
                -- We need the sign of the speed
                return vel:Len() * SignLargestAxis(vel)
            end

            function s.Acceleration()
                local vel = LocalAngAcc() * rad2deg
                -- The normal vector gives the correct x, y or z axis part of the acceleration
                return (vel * localNormal()):Len()
            end

            ---@param deltaTime number
            function s.AxisFlush(deltaTime)
                if targetCoordinate then
                    -- Positive offset means we're right of target, clock-wise
                    -- Positive acceleration turns counter-clockwise
                    -- Positive velocity means we're turning counter-clockwise

                    local vecToTarget = (targetCoordinate - Current()):Normalize()
                    local offset = SignedRotationAngle(normal(), reference(), vecToTarget)
                    axisData.offset = offset * rad2deg

                    lightPid:inject(offset)
                    heavyPid:inject(offset)

                    local v
                    if lastReadMass > LightConstructMassThreshold then
                        v = heavyPid:get()
                    else
                        v = lightPid:get()
                    end

                    finalAcceleration[axis] = normal() * v
                end
            end

            function s.Apply()
                local acc = finalAcceleration[ControlledAxis.Pitch] + finalAcceleration[ControlledAxis.Roll] +
                    finalAcceleration[ControlledAxis.Yaw]
                setEngineCommand("torque", { 0, 0, 0 }, { acc:Unpack() }, true, true, "", "", "", 0.1)
            end

            function s.Update()
                axisData.speed = s.Speed()
                axisData.acceleration = s.Acceleration()
                pub.Publish(pubTopic, axisData)
                lastReadMass = TotalMass()
            end

            ---Returns the current offset, in degrees
            ---@return number
            function s.OffsetDegrees()
                return axisData.offset
            end

            return setmetatable(s, control)
        end


        return AxisControl


        end)

        package.preload['YFS:flight/AxisManager.lua']=(function()

        local AxisControl = require('YFS:flight/AxisControl.lua')


        ---@class AxisManager

        ---@field Pitch fun():AxisControl

        ---@field Yaw fun():AxisControl

        ---@field Roll fun():AxisControl

        ---@field Flush fun(deltaTime:number)

        ---@field ReceiveEvents fun()

        ---@field StopEvents fun()

        ---@field SetYawTarget fun(target:Vec3?)

        ---@field SetPitchTarget fun(target:Vec3?)

        ---@field SetRollTarget fun(target:Vec3?)


        local AxisManager = {}

        AxisManager.__index = AxisManager

        local instance ---@type AxisManager


        ---@return AxisManager

        function AxisManager.Instance()
            if instance then return instance end

            local s = {}

            local pitch, roll, yaw = AxisControl.New(ControlledAxis.Pitch), AxisControl.New(ControlledAxis.Roll),
                AxisControl.New(ControlledAxis.Yaw)

            function s.ReceiveEvents()
                pitch.ReceiveEvents()
                roll.ReceiveEvents()
                yaw.ReceiveEvents()
            end

            function s.StopEvents()
                pitch.StopEvents()
                roll.StopEvents()
                yaw.StopEvents()
            end

            ---@param target Vec3?
            function s.SetYawTarget(target)
                if target then yaw.SetTarget(target) else yaw.Disable() end
            end

            ---@param target Vec3?
            function s.SetPitchTarget(target)
                if target then pitch.SetTarget(target) else pitch.Disable() end
            end

            ---@param target Vec3?
            function s.SetRollTarget(target)
                if target then roll.SetTarget(target) else roll.Disable() end
            end

            ---@param deltaTime number
            function s.Flush(deltaTime)
                -- Enabling this causes an uninteded roll when making hard turns.
                --if abs(yaw.OffsetDegrees()) > 20 then
                --roll.Disable()
                --end

                pitch.AxisFlush(deltaTime)
                roll.AxisFlush(deltaTime)
                yaw.AxisFlush(deltaTime)

                -- Can call apply on any of the axes, it doesn't matter
                yaw.Apply()
            end

            function s.Yaw() return yaw end

            function s.Pitch() return pitch end

            function s.Roll() return roll end

            instance = setmetatable(s, AxisManager)
            return instance
        end


        return AxisManager


        end)

        package.preload['YFS:flight/AdjustmentTracker.lua']=(function()

        local PID = require("cpml/pid")


        ---@class AdjustmentTracker

        ---@field Feed fun(distance:number):number

        ---@field LastDistance fun():number

        ---@field ResetPID fun()


        local AdjustmentTracker = {}

        AdjustmentTracker.__index = AdjustmentTracker


        ---@param lightConstruct boolean True if the construct is light

        ---@return AdjustmentTracker

        function AdjustmentTracker.New(lightConstruct)
            local s = {}
            local pid
            if lightConstruct then
                pid = PID(0.01, 0.1, 5, 0.5)
            else
                pid = PID(1, 0.5, 5, 0.5)
            end

            local lastDistance = 0

            ---@return number
            function s.LastDistance()
                return lastDistance
            end

            ---@param distance number
            ---@return number
            function s.Feed(distance)
                lastDistance = distance
                pid:inject(distance)
                return pid:get()
            end

            function s.ResetPID()
                pid:reset()
            end

            return setmetatable(s, AdjustmentTracker)
        end


        return AdjustmentTracker


        end)

        package.preload['YFS:../e/lib/src/abstraction/Constants.lua']=(function()

        local constants = {
            PHYSICS_INTERVAL = 1 / 60
        }


        return constants


        end)

        package.preload['YFS:../e/lib/src/abstraction/Engine.lua']=(function()

        require('YFS:../e/lib/src/abstraction/Vehicle.lua')

        local calc      = require('YFS:../e/lib/src/util/Calc.lua')

        local constants = require('YFS:../e/lib/src/abstraction/Constants.lua')

        local Ternary   = calc.Ternary

        local abs       = math.abs

        local min       = math.min

        local mtaa      = construct.getMaxThrustAlongAxis


        local function getLongitudinalForce()
            return mtaa(
                IsInAtmo() and "longitudinal atmospheric_engine" or "longitudinal space_engine",
                { LocalForward():Unpack() })
        end


        local function getLateralForce()
            return mtaa(IsInAtmo() and "lateral atmospheric_engine" or "lateral space_engine",
                { LocalRight():Unpack() })
        end


        local function getVerticalForce()
            return mtaa(IsInAtmo() and "vertical atmospheric_engine" or "vertical space_engine",
                { LocalUp():Unpack() })
        end


        local function getVerticalHoverForce()
            return mtaa("vertical hover_engine", { LocalUp():Unpack() })
        end


        local function getVerticalBoosterForce()
            return mtaa("vertical booster_engine", { LocalUp():Unpack() })
        end


        local atmoRangeFMaxPlus = 1

        local atmoRangeFMaxMinus = 2

        local spaceRangeFMaxPlus = 3

        local spaceRangeFMaxMinus = 4


        ---@alias rangeFunc fun():number[]

        ---@alias rangeFuncArr rangeFunc[]


        ---@param ranges rangeFunc[] The functions to call to get atmo and space forces. First one should be the regular engines, next hovers and vertical boosters

        ---@param positive boolean

        ---@return number

        local function getCurrent(ranges, positive)
            local plus, minus
            if IsInAtmo() then
                plus = atmoRangeFMaxPlus
                minus = atmoRangeFMaxMinus
            else
                plus = spaceRangeFMaxPlus
                minus = spaceRangeFMaxMinus
            end

            local r = { FMaxPlus = 0, FMaxMinus = 0 }

            for i, range in ipairs(ranges) do
                local curr = range()

                -- Only fallback to secondary ranges if first one doesn't have any force
                r.FMaxPlus = r.FMaxPlus == 0 and curr[plus] or r.FMaxPlus
                r.FMaxMinus = r.FMaxMinus == 0 and curr[minus] or r.FMaxMinus
            end

            return positive and r.FMaxPlus or r.FMaxMinus
        end


        ---@class EngineAbs

        ---@field Instance fun():EngineAbs

        ---@field GetAvailableThrust fun(reduceMode:boolean, direction:Vec3, considerAtmoDensity?:boolean):number


        local Engine = {}

        Engine.__index = Engine

        local s


        ---Gets the Engine instance

        ---@return EngineAbs

        function Engine.Instance()
            if s then
                return s
            end

            s = {}

            ---The maximum acceleration the construct can give without pushing itself more in one direction than the others.
            ---@param reduceMode boolean If true, returns the available thust while taking the weaker engines into account
            ---@param direction Vec3 Direction to move
            ---@param considerAtmoDensity? boolean If true, consider atmo influence on engine power
            ---@return number # Avaliable acceleration
            function s.GetAvailableThrust(reduceMode, direction, considerAtmoDensity)
                if direction:IsZero() then
                    return 0
                end

                direction = calc.WorldDirectionToLocal(direction)
                local totalMass = TotalMass()

                -- Add current gravity influence as force in Newtons

                local gravDir = calc.WorldDirectionToLocal(GravityDirection())

                local gravityForce = Vec3.zero
                if gravDir:Dot(direction) > 0 then
                    -- Moving along gravity, consider it as an engine.
                    -- Note to self: Don't add gravity if not travelling along it, that will reduce reported available engine force.
                    gravityForce = gravDir * G() * totalMass
                end

                -- Setup engines using the thrust for the direction they make the construct move (i.e. opposite to thrust direction)
                ---@alias ThrustAndDir { dir:Vec3, thrust:number }
                ---@type ThrustAndDir
                local engines = {
                    { dir = -LocalRight(),   thrust = abs(s:MaxLeftwardThrust()) },
                    { dir = LocalRight(),    thrust = abs(s:MaxRightwardThrust()) },
                    { dir = -LocalUp(),      thrust = abs(s:MaxDownwardThrust()) },
                    { dir = LocalUp(),       thrust = abs(s:MaxUpwardThrust()) },
                    { dir = -LocalForward(), thrust = abs(s:MaxBackwardThrust()) },
                    { dir = LocalForward(),  thrust = abs(s:MaxForwardThrust()) }
                }

                -- Find engines that contribute to the movement in the desired direction
                local minThrust = math.huge
                local mainEngine = nil ---@type ThrustAndDir|nil

                for _, engine in ipairs(engines) do
                    local dot = engine.dir:Dot(direction)

                    -- Add gravity before any use of the engine (or we'll think we can't move downward due to "no engine")
                    engine.thrust = engine.thrust + gravityForce:Dot(engine.dir)
                    -- Compare with a near-zero value for dot as we get values like 1e-11 which are still > 0 but too small to use.

                    if dot > 0.001 and engine.thrust > 0.01 then
                        -- Calculate the thrust this engine can give for the direction and add the gravity force
                        local thrust = engine.thrust
                        if thrust < minThrust then
                            minThrust = thrust
                        end

                        -- Find "main" engine closest to direction
                        if not mainEngine then
                            mainEngine = engine
                        elseif engine.dir:AngleTo(direction) < mainEngine.dir:AngleTo(direction) then
                            mainEngine = engine
                        end
                    end
                end

                -- No engine?
                if not mainEngine then
                    return 0
                end

                local availableForce = mainEngine.thrust

                -- Should we limit thrust to weaker engine?
                if reduceMode and mainEngine.dir:AngleToDeg(direction) > 10 then
                    -- Closest engine is outside limit so limit to weakest
                    availableForce = minThrust
                end

                local availableThrust = direction * availableForce

                -- When space engines kick in, don't consider atmospheric density.
                if considerAtmoDensity and IsInAtmo() then
                    availableThrust = availableThrust * AtmoDensity()
                end

                -- Remember that this value is the acceleration, m/s2, not how many g:s we can give. To get that, divide by the current world gravity.
                return availableThrust:Len() / totalMass
            end

            function s:MaxForwardThrust()
                return getCurrent({ getLongitudinalForce }, true)
            end

            function s:MaxBackwardThrust()
                return getCurrent({ getLongitudinalForce }, false)
            end

            function s:MaxRightwardThrust()
                return getCurrent({ getLateralForce }, true)
            end

            function s:MaxLeftwardThrust()
                return getCurrent({ getLateralForce }, false)
            end

            function s:MaxUpwardThrust()
                return getCurrent({ getVerticalForce, getVerticalHoverForce, getVerticalBoosterForce }, true)
            end

            function s:MaxDownwardThrust()
                return getCurrent({ getVerticalForce }, false)
            end

            return setmetatable(s, Engine)
        end


        return Engine


        end)

        package.preload['YFS:../e/lib/src/util/Ray.lua']=(function()

        local Vec3 = require('YFS:../e/lib/src/math/Vec3.lua')


        ---@class Ray

        ---@field New fun(start:Vec3, direction:Vec3):Ray

        ---@field Start Vec3 The start point of the ray

        ---@field Dir Vec3 The direction the ray points


        local Ray = {}

        Ray.__index = Ray

        function Ray.New(start, direction)
            local s = {
                Start = start,
                Dir = direction
            }

            return setmetatable(s, Ray)
        end


        return Ray


        end)

        package.preload['YFS:flight/state/Hold.lua']=(function()

        ---@module "flight/state/Travel"

        ---@module "element/Telemeter"


        require('YFS:../e/lib/src/abstraction/Vehicle.lua')

        local s                            = require('YFS:Singletons.lua')

        local log, pub, gateControl, timer = s.log, s.pub, s.gateCtrl, s.timer



        ---@class Hold

        ---@field New fun(fsm:FlightFSM):FlightState

        ---@field Enter fun()

        ---@field Leave fun()

        ---@field Flush fun(deltaTime:number, next:Waypoint, previous:Waypoint, nearestPointOnPath:Vec3)

        ---@field AtWaypoint fun(isLastWaypoint:boolean, next:Waypoint, previous:Waypoint)

        ---@field Update fun()

        ---@field Name fun():string


        local Hold = {}

        Hold.__index = Hold


        local name = "Hold"


        ---Creates a new Hold state

        ---@param fsm FlightFSM

        ---@return FlightState

        function Hold.New(fsm)
            local s = {}
            local isLastWaypoint = false
            local settings = fsm.GetSettings()
            local rc = fsm.GetRouteController()

            local function waitForGatesToClose()
                if fsm.GetFlightCore().WaitForGate() then
                    timer.Add("WaitForGatesToClose", function()
                            unit.exit()
                        end,
                        settings.Number("shutdownDelayForGate"))
                else
                    unit.exit()
                end
            end

            function s.Enter()
                pub.RegisterTable("FloorMonitor", s.floorMonitor)
                if fsm.GetFlightCore().WaitForGate() then
                    gateControl.Close()
                end
            end

            function s.Leave()
                pub.Unregister("FloorMonitor", s.floorMonitor)
            end

            ---@param deltaTime number
            ---@param next Waypoint
            ---@param previous Waypoint
            ---@param nearestPointOnPath Vec3
            function s.Flush(deltaTime, next, previous, nearestPointOnPath)
                if not next.WithinMargin(WPReachMode.EXIT) then
                    fsm.SetState(Travel.New(fsm))
                end
            end

            function s.Update()
            end

            function s.AtWaypoint(lastWaypoint, next, previous)
                isLastWaypoint = lastWaypoint
            end

            function s.Name()
                return name
            end

            ---@param topic string
            ---@param hit TelemeterResult
            function s.floorMonitor(topic, hit)
                local r = rc.CurrentRoute()
                local hasTag = true

                if r then
                    hasTag = r.HasTag("ReturnTag") or r.HasTag("RegularParkingTag")
                end

                if (not IsFrozen() or hasTag) -- hasTag overrides frozen
                    and isLastWaypoint
                    and hit.Hit
                    and hit.Distance <= settings.Get("autoShutdownFloorDistance")
                then
                    log.Info("Floor detected at last waypoint, going idle.")
                    fsm.SetState(Idle.New(fsm))
                    waitForGatesToClose()
                end
            end

            function s.DisablesAllThrust()
                return false
            end

            function s.PreventNextWp()
                return false
            end

            setmetatable(s, Hold)
            return s
        end


        return Hold


        end)

        package.preload['YFS:flight/state/Idle.lua']=(function()

        local s        = require('YFS:Singletons.lua')

        local log, pub = s.log, s.pub


        ---@class Idle

        ---@field New fun(fsm:FlightFSM):FlightState

        ---@field Enter fun()

        ---@field Leave fun()

        ---@field Flush fun(deltaTime:number, next:Waypoint, previous:Waypoint, nearestPointOnPath:Vec3)

        ---@field AtWaypoint fun(isLastWaypoint:boolean, next:Waypoint, previous:Waypoint)

        ---@field Update fun()

        ---@field Name fun():string


        local Idle     = {}

        Idle.__index   = Idle


        local name     = "Idle"


        ---Creates a new Idle state

        ---@param fsm FlightFSM

        ---@return FlightState

        function Idle.New(fsm)
            local s = {}

            local settings = fsm.GetSettings()

            function s.Enter()
                pub.RegisterTable("FloorMonitor", s.floorMonitor)
            end

            function s.Leave()
                pub.Unregister("FloorMonitor", s.floorMonitor)
            end

            ---@param deltaTime number
            ---@param next Waypoint
            ---@param previous Waypoint
            ---@param nearestPointOnPath Vec3
            function s.Flush(deltaTime, next, previous, nearestPointOnPath)

            end

            function s.Update()
            end

            function s.AtWaypoint(isLastWaypoint, next, previous)
            end

            function s.Name()
                return name
            end

            function s.DisablesAllThrust()
                return true
            end

            ---@param topic string
            ---@param hit TelemeterResult
            function s.floorMonitor(topic, hit)
                if not hit.Hit or hit.Distance > settings.Get("autoShutdownFloorDistance") then
                    log.Info("Floor not detected, holding position.")
                    fsm.GetRouteController().ActivateHoldRoute()
                    fsm.GetFlightCore().StartFlight()
                end
            end

            function s.PreventNextWp()
                return false
            end

            return setmetatable(s, Idle)
        end


        return Idle


        end)

        package.preload['YFS:flight/state/Travel.lua']=(function()

        require('YFS:../e/lib/src/abstraction/Vehicle.lua')

        local s        = require('YFS:Singletons.lua')

        local floor    = s.floorDetector


        ---@class Travel

        ---@field New fun(fsm:FlightFSM):FlightState


        local Travel   = {}

        Travel.__index = Travel


        local name     = "Travel"


        ---Creates a new Travel state

        ---@param fsm FlightFSM

        ---@return FlightState

        function Travel.New(fsm)
            local s = {}
            local rc = fsm.GetRouteController()
            local route ---@type Route|nil

            function s.Enter()
                route = rc.CurrentRoute()
            end

            function s.Leave()
            end

            ---Flush
            ---@param deltaTime number
            ---@param next Waypoint
            ---@param previous Waypoint
            ---@param nearestPointOnPath Vec3
            function s.Flush(deltaTime, next, previous, nearestPointOnPath)
                -- Are we on the the desired path?
                if not fsm.CheckPathAlignment(Current(), nearestPointOnPath, previous, next) then
                    fsm.SetState(ReturnToPath.New(fsm, nearestPointOnPath))
                end
            end

            function s.Update()
                if route and route.HasTag("RegularParkingTag") then
                    local m = floor.Measure()
                    if m.Hit then
                        fsm.GetFlightCore().StartParking(m.Distance, "Settling")
                    end
                end
            end

            function s.AtWaypoint(isLastWaypoint, next, previous)
                if isLastWaypoint then
                    fsm.SetState(Hold.New(fsm))
                end
            end

            function s.Name()
                return name
            end

            function s.DisablesAllThrust()
                return false
            end

            function s.PreventNextWp()
                return false
            end

            return setmetatable(s, Travel)
        end


        return Travel


        end)

        package.preload['YFS:flight/state/ReturnToPath.lua']=(function()

        require('YFS:GlobalTypes.lua')


        ---@class ReturnToPath

        ---@field New fun(fsm:FlightFSM, returnPoint:Vec3):FlightState

        ---@field Enter fun()

        ---@field Leave fun()

        ---@field Flush fun(deltaTime:number, next:Waypoint, previous:Waypoint, nearestPointOnPath:Vec3)

        ---@field Update fun()

        ---@field Name fun():string


        local ReturnToPath = {}

        ReturnToPath.__index = ReturnToPath

        local name = "ReturnToPath"


        ---Creates a new ReturnPath

        ---@param fsm FlightFSM

        ---@param returnPoint Vec3

        ---@return FlightState

        function ReturnToPath.New(fsm, returnPoint)
            local s = {}
            local temporaryWP = nil ---@type Waypoint|nil

            function s.Enter()
            end

            function s.Leave()
                fsm.SetTemporaryWaypoint()
            end

            ---Flush
            ---@param deltaTime number
            ---@param next Waypoint
            ---@param previous Waypoint
            ---@param nearestPointOnPath Vec3
            function s.Flush(deltaTime, next, previous, nearestPointOnPath)
                if not temporaryWP then
                    temporaryWP = Waypoint.New(returnPoint, 0, 0, fsm.GetSettings().Number("minimumPathCheckOffset", 2), 0)
                    temporaryWP.LockYawTo(next.LockedYawDirection() or Plane.NewByVertialReference().Forward())
                    temporaryWP.ForceUpAlongVerticalRef()
                    fsm.SetTemporaryWaypoint(temporaryWP)
                end

                if temporaryWP.WithinMargin(WPReachMode.ENTRY) then
                    fsm.SetState(Travel.New(fsm))
                end
            end

            function s.Update()
            end

            function s.AtWaypoint(isLastWaypoint, next, previous)
            end

            function s.Name()
                return name
            end

            function s.DisablesAllThrust()
                return false
            end

            function s.PreventNextWp()
                return false
            end

            return setmetatable(s, ReturnToPath)
        end


        return ReturnToPath


        end)

        package.preload['YFS:flight/state/OpenGates.lua']=(function()

        require('YFS:GlobalTypes.lua')

        local s                       = require('YFS:Singletons.lua')

        local log, gateControl, timer = s.log, s.gateCtrl, s.timer


        ---@class OpenGates

        ---@field New fun(fsm:FlightFSM, holdPoint:Vec3, holdDir:Vec3):FlightState


        local OpenGates               = {}

        OpenGates.__index             = OpenGates


        local name                    = "OpenGates"


        ---Creates a new OpenGates state

        ---@param fsm FlightFSM

        ---@param holdPoint Vec3

        ---@param holdDir Vec3

        ---@return FlightState

        function OpenGates.New(fsm, holdPoint, holdDir)
            local s = {}
            local temporaryWP = nil ---@type Waypoint|nil
            local commEnabled = fsm.GetSettings().String("commChannel") ~= ""
            local timeToWaitForOpen = fsm.GetSettings().Number("openGateWaitDelay")
            local waitToOpen = Stopwatch.New()

            function s.Enter()
                if commEnabled then
                    gateControl.Open()
                    log.Info("Requesting gates to open.")
                    timer.Add("WaitOnGate", function() log.Info("Waiting on gates to open") end, 2)
                end
            end

            function s.Leave()
                timer.Remove("WaitOnGate")
                fsm.SetTemporaryWaypoint()
            end

            ---Flush
            ---@param deltaTime number
            ---@param next Waypoint
            ---@param previous Waypoint
            ---@param nearestPointOnPath Vec3
            function s.Flush(deltaTime, next, previous, nearestPointOnPath)
                if not temporaryWP then
                    temporaryWP = Waypoint.New(holdPoint, 0, 0, next.Margin(), 0)
                    temporaryWP.LockYawTo(holdDir)
                    fsm.SetTemporaryWaypoint(temporaryWP)
                end
            end

            function s.Update()
                if commEnabled then
                    if gateControl.AreInDesiredState() then
                        if waitToOpen.Elapsed() > timeToWaitForOpen then
                            fsm.SetState(Travel.New(fsm))
                        elseif not waitToOpen.IsRunning() then
                            waitToOpen.Start()
                            log.Info("Giving gates ", timeToWaitForOpen, " seconds to be fully open")
                        end
                    end
                else
                    fsm.SetState(Travel.New(fsm))
                end
            end

            function s.AtWaypoint(isLastWaypoint, next, previous)

            end

            function s.Name()
                return name
            end

            function s.DisablesAllThrust()
                return false
            end

            function s.PreventNextWp()
                return true
            end

            return setmetatable(s, OpenGates)
        end


        return OpenGates


        end)

        package.preload['YFS:flight/state/Require.lua']=(function()

        -- Make states globally available so they can all reference each other without creating require-loops

        if not FLIGHT_STATES_INCLUDED then
            FLIGHT_STATES_INCLUDED = true
            Hold = require('YFS:flight/state/Hold.lua') ---@type Hold
            Idle = require('YFS:flight/state/Idle.lua') ---@type Idle
            Travel = require('YFS:flight/state/Travel.lua') ---@type Travel
            ReturnToPath = require('YFS:flight/state/ReturnToPath.lua') ---@type ReturnToPath
            OpenGates = require('YFS:flight/state/OpenGates.lua') ---@type OpenGates
        end


        end)

        package.preload['YFS:flight/FlightFSM.lua']=(function()

        require('YFS:../e/lib/src/abstraction/Vehicle.lua')

        require('YFS:GlobalTypes.lua')


        local Vec3, AxisManager, AdjustmentTracker, engine, PID, Ray, s                                                    =
            require('YFS:../e/lib/src/math/Vec3.lua'), require('YFS:flight/AxisManager.lua'), require('YFS:flight/AdjustmentTracker.lua'),
            require('YFS:../e/lib/src/abstraction/Engine.lua').Instance(), require("cpml/pid"),
            require('YFS:../e/lib/src/util/Ray.lua'), require('YFS:Singletons.lua')
        local log, universe, calc, yfsConstants, pub, input, brakes                                                        = s
            .log, s.universe, s.calc, s.constants, s.pub,
            s.input,
            s.brakes

        local AirFrictionAcc, LightConstructMassThreshold, DefaultMargin, Sign, nullVec, SetEngineCommand, SetEngineThrust =
            AirFrictionAcceleration,
            yfsConstants.flight.lightConstructMassThreshold, yfsConstants.flight.defaultMargin, calc.Sign, Vec3.zero,
            unit.setEngineCommand, unit.setEngineThrust

        require('YFS:flight/state/Require.lua')


        local Clamp               = calc.Clamp

        local abs                 = math.abs

        local min                 = math.min

        local max                 = math.max

        local MAX_INT             = math.maxinteger

        local adjustmentThreshold = calc.AngleToDot(45)


        local brakeDegradeSpeed   = calc.Kph2Mps(360)


        local deadZoneFactor      = 0.8 -- Consider the inner edge of the dead zone where we can't brake to start at this percentage of the atmosphere.


        ---@class FlightFSM

        ---@field New fun(settings:Settings):FlightFSM

        ---@field FsmFlush fun(deltaTime:number, next:Waypoint, previous:Waypoint)

        ---@field SetState fun(newState:FlightState)

        ---@field SetEngineWarmupTime fun(t50:number)

        ---@field CheckPathAlignment fun(currentPos:Vec3, nearestPointOnPath:Vec3, previousWaypoint:Waypoint, nextWaypoint:Waypoint)

        ---@field SetTemporaryWaypoint fun(wpNext:Waypoint|nil)

        ---@field Update fun()

        ---@field AtWaypoint fun(isLastWaypoint:boolean, next:Waypoint, previous:Waypoint)

        ---@field GetSettings fun():Settings

        ---@field GetRouteController fun():RouteController

        ---@field SetFlightCore fun(fc:FlightCore)

        ---@field GetFlightCore fun():FlightCore

        ---@field DisablesAllThrust fun():boolean

        ---@field PreventNextWp fun():boolean

        ---@field SelectWP fun(orgNext:Waypoint):Waypoint, boolean

        ---@field ToggleBoster fun()

        ---@field SetBooster fun(activate:boolean)


        local FlightFSM           = {}

        FlightFSM.__index         = FlightFSM


        ---Creates a new FligtFSM

        ---@param settings Settings

        ---@param routeController RouteController

        --- @param geo GeoFence

        ---@return FlightFSM

        function FlightFSM.New(settings, routeController, geo)
            local minimumPathCheckOffset = settings.Number("minimumPathCheckOffset")
            settings.Callback("minimumPathCheckOffset", function(number)
                minimumPathCheckOffset = number
            end)

            local globalMaxSpeed = calc.Kph2Mps(settings.Number("globalMaxSpeed"))
            settings.Callback("globalMaxSpeed", function(gMax)
                globalMaxSpeed = calc.Kph2Mps(gMax)
            end)

            settings.Callback("pathAlignmentAngleLimit", Waypoint.SetAlignmentAngleLimit)
            settings.Callback("pathAlignmentDistanceLimit", Waypoint.SetAlignmentDistanceLimit)
            settings.Callback("pitchAlignmentThrustLimiter", Waypoint.SetPitchAlignmentThrustLimiter)
            settings.Callback("autoPitch", Waypoint.SetAutoPitch)
            settings.Callback("autoBrakeAngle", brakes.SetAutoBrakeAngle)
            settings.Callback("autoBrakeDelay", brakes.SetAutoBrakeDelay)

            local warmupTime                  = 1
            local lastReadMass                = TotalMass()
            local axisMgr                     = AxisManager.Instance()
            local yaw                         = axisMgr.Yaw()
            local roll                        = axisMgr.Roll()
            local pitch                       = axisMgr.Pitch()
            local yawAlignmentThrustLimiter   = 1
            local rollAlignmentThrustLimiter  = 1
            local pitchAlignmentThrustLimiter = 1
            local boosterActive               = false
            local boosterStateChanged         = false
            local isFrozen                    = false

            local longAdjData                 = AdjustmentTracker.New(lastReadMass < LightConstructMassThreshold)
            local latAdjData                  = AdjustmentTracker.New(lastReadMass < LightConstructMassThreshold)
            local vertAdjData                 = AdjustmentTracker.New(lastReadMass < LightConstructMassThreshold)

            ---@type FlightData
            local flightData                  = {
                targetSpeed = 0,
                targetSpeedReason = "",
                finalSpeed = 0,
                finalSpeedDistance = 0,
                distanceToAtmo = -1,
                atmoDistance = 0,
                brakeMaxSpeed = 0,
                waypointDist = 0,
                speedDiff = 0,
                pid = 0,
                fsmState = "No state",
                acceleration = 0,
                controlAcc = 0,
                absSpeed = 0
            }

            local adjustData                  = {
                long = 0,
                lat = 0,
                ver = 0
            }


            local currentState ---@type FlightState
            local temporaryWaypoint ---@type Waypoint|nil
            local pidValues = yfsConstants.flight.speedPid
            local speedPid = PID(pidValues.p, pidValues.i, pidValues.d, pidValues.a)

            local s = {}

            ---@param active boolean
            function s.SetBooster(active)
                if active ~= boosterActive then
                    boosterActive = active
                    boosterStateChanged = true
                    log.Info("Boosters ", boosterActive and "activated" or "deactivated")
                end
            end

            ---Selects the waypoint to go to
            ---@param orgNext Waypoint
            ---@return Waypoint
            ---@return boolean
            function s.SelectWP(orgNext)
                if temporaryWaypoint then
                    return temporaryWaypoint, true
                end

                return orgNext, false
            end

            ---Calculates the width of the dead zone
            ---@param body Body
            local function deadZoneThickness(body)
                local atmo = body.Atmosphere
                local thickness = atmo.Present and (atmo.Thickness * (1 - deadZoneFactor)) or 0
                return thickness
            end

            ---Indicates if the coordinate is within the atmospheric dead zone of the body
            ---@param coordinate Vec3
            ---@param body Body
            ---@return boolean
            local function isWithinDeadZone(coordinate, body)
                if not body.Atmosphere.Present then return false end

                -- If the point is within the atmospheric radius and outside the inner radius, then it is within the dead zone.
                local outerBorder = body.Atmosphere.Radius
                local innerBorder = outerBorder - deadZoneThickness(body)
                local distanceToCenter = (coordinate - body.Geography.Center):Len()

                return distanceToCenter < outerBorder and distanceToCenter >= innerBorder
            end

            ---Determines if the construct will enter atmo if continuing on the current path
            ---If already in atmo it returns false
            ---@param waypoint Waypoint
            ---@param body Body
            ---@return boolean, Vec3, number
            local function willEnterAtmo(waypoint, body)
                local pos = Current()
                local center = body.Geography.Center
                local intersects, point, dist = calc.LineIntersectSphere(Ray.New(pos, waypoint.DirectionTo()), center,
                    body.Atmosphere.Radius)
                intersects = intersects and not body:IsInAtmo(pos)
                return intersects, point, dist
            end

            ---Evaluates the new speed limit and sets that, if lower than the current one
            ---@param currentLimit number Current speed limit
            ---@param newLimit number New speed limit
            ---@param reason string Text to display in the widget
            ---@return number
            local function evaluateNewLimit(currentLimit, newLimit, reason)
                if newLimit >= 0 and newLimit < currentLimit then
                    flightData.targetSpeed = newLimit
                    flightData.targetSpeedReason = reason
                    return newLimit
                end

                return currentLimit
            end

            ---@param remainingDistance number Remaining distance
            local function linearSpeed(remainingDistance)
                -- 1000m -> 1000km/h, 500m -> 500km/h etc.
                local speed = calc.Kph2Mps(remainingDistance)

                if remainingDistance < 2 then
                    speed = speed * 2
                end

                return speed
            end

            ---Adjust the speed to be linear based on the remaining distance
            ---@param currentTargetSpeed number Current target speed
            ---@param remainingDistance number Remaining distance
            ---@return number Speed
            local function linearApproach(currentTargetSpeed, remainingDistance)
                local startDist
                local stopDist

                if IsInAtmo() then
                    if lastReadMass > LightConstructMassThreshold then
                        startDist = 20
                        stopDist = 0.3
                    else
                        startDist = 0.5
                        stopDist = 0
                    end
                else
                    startDist = 20
                    stopDist = 0.0 -- This used to be 0.5, but that caused problems holding position.
                end

                if remainingDistance > startDist
                    or remainingDistance <= stopDist then -- To not make it painfully slow in reaching the final position we let it go when it is this close from the target
                    return currentTargetSpeed
                end

                return evaluateNewLimit(currentTargetSpeed, linearSpeed(remainingDistance), "Approaching")
            end


            ---@param waypoint Waypoint
            ---@return boolean
            local function outsideAdjustmentMargin(waypoint)
                local margin = waypoint.Margin()
                return longAdjData.LastDistance() > margin
                    or latAdjData.LastDistance() > margin
                    or vertAdjData.LastDistance() > margin
            end

            local function burnSpeed()
                return construct.getFrictionBurnSpeed() * 0.98
            end

            ---Gets the maximum speed we may have and still be able to stop
            ---@param deltaTime number Time since last tick, seconds
            ---@param velocity Vec3 Current velocity
            ---@param waypoint Waypoint Current waypoint
            ---@param previousWaypoint Waypoint Previous waypoint
            ---@return number
            local function getSpeedLimit(deltaTime, velocity, waypoint, previousWaypoint)
                local currentSpeed = velocity:Len()
                -- Look ahead at how much there is left at the next tick. If we're decelerating, don't allow values less than 0
                -- This is inaccurate if acceleration isn't in the same direction as our movement vector, but it is gives a safe value.
                local remainingDistance = max(0,
                    waypoint.DistanceTo() - (currentSpeed * deltaTime + 0.5 * Acceleration():Len() * deltaTime * deltaTime))

                -- Calculate max speed we may have with available brake force to to reach the final speed.
                local pos = Current()
                local firstBody = universe.CurrentGalaxy():BodiesInPath(Ray.New(pos, velocity:Normalize()))[1]
                local inAtmo = false
                local willLeaveAtmo = false
                local atmoDensity = AtmoDensity()

                flightData.finalSpeed = waypoint.FinalSpeed()
                flightData.finalSpeedDistance = remainingDistance

                local willHitAtmo = false
                local distanceToAtmo = -1

                local targetSpeed = evaluateNewLimit(MAX_INT, construct.getMaxSpeed(), "Construct max")

                if firstBody then
                    willHitAtmo, _, distanceToAtmo = willEnterAtmo(waypoint, firstBody)
                    inAtmo = firstBody:IsInAtmo(pos)
                    willLeaveAtmo = inAtmo and not firstBody:IsInAtmo(waypoint.Destination())
                    flightData.distanceToAtmo = distanceToAtmo
                end

                if waypoint.MaxSpeed() > 0 then
                    targetSpeed = evaluateNewLimit(targetSpeed, waypoint.MaxSpeed(), "Route")
                end

                --- Don't allow us to burn
                if atmoDensity > 0 then
                    targetSpeed = evaluateNewLimit(targetSpeed, burnSpeed(), "Burn speed")
                end

                local inDeadZone = firstBody and isWithinDeadZone(pos, firstBody)
                local fallingInDeadZone = inDeadZone and waypoint.DirectionTo():Dot(GravityDirection()) > 0.7
                if fallingInDeadZone then
                    remainingDistance = max(remainingDistance, remainingDistance - deadZoneThickness(firstBody))
                end

                -- Ensure slowdown before we hit atmo and assume we're going to fall through the dead zone.
                local atmosphericEntrySpeed = burnSpeed()
                if willHitAtmo then
                    flightData.finalSpeed = atmosphericEntrySpeed
                    flightData.finalSpeedDistance = distanceToAtmo

                    -- Are actually intending to enter atmo?
                    if distanceToAtmo <= waypoint.DistanceTo() then
                        local entrySpeed = brakes.CalcMaxAllowedSpeed(distanceToAtmo, atmosphericEntrySpeed)
                        targetSpeed = evaluateNewLimit(targetSpeed, entrySpeed, "Atmo entry")
                    end
                elseif fallingInDeadZone then
                    targetSpeed = evaluateNewLimit(targetSpeed, atmosphericEntrySpeed, "Dead Zone")
                end

                -- Ensure that we have a speed at which we can come to a stop with 10% of the brake force when we hit 360km/h, which is the speed at which brakes start to degrade down to 10% at 36km/h.
                if inAtmo and not willLeaveAtmo and waypoint.FinalSpeed() <= brakeDegradeSpeed then
                    local tenPercent = brakes.MaxSeenGravityInfluencedAvailableAtmoDeceleration() * 0.1
                    if tenPercent > 0 then
                        local endSpeed = waypoint.FinalSpeed()

                        local finalApproachDistance = calc.CalcBrakeDistance(brakeDegradeSpeed, tenPercent)
                        local toBrakePoint = remainingDistance - finalApproachDistance

                        if toBrakePoint > 0 then
                            -- Not yet reached the break point
                            targetSpeed = evaluateNewLimit(targetSpeed,
                                brakes.CalcMaxAllowedSpeed(toBrakePoint, brakeDegradeSpeed, -tenPercent), "Appr. fin.")
                            flightData.finalSpeed = brakeDegradeSpeed
                            flightData.finalSpeedDistance = toBrakePoint
                        else
                            -- Within
                            targetSpeed = evaluateNewLimit(targetSpeed,
                                brakes.CalcMaxAllowedSpeed(remainingDistance, endSpeed, -tenPercent), "Final atmo")
                        end
                    end
                end

                if inAtmo and abs(brakes.EffectiveBrakeDeceleration()) <= G() then
                    -- Brakes have become so inefficient at the current altitude or speed they are useless, use linear speed
                    -- This state can be seen when entering atmo for example.
                    targetSpeed = evaluateNewLimit(targetSpeed, linearSpeed(remainingDistance), "Brake/ineff")
                    -- Does final speed override?
                    local finalSpeed = waypoint.FinalSpeed()
                    if targetSpeed < finalSpeed and finalSpeed > 0 then
                        targetSpeed = evaluateNewLimit(finalSpeed + 1, finalSpeed, "Final spd")
                    end
                elseif inAtmo and willLeaveAtmo then
                    -- No need to further reduce
                else
                    local brakeMaxSpeed = brakes.CalcMaxAllowedSpeed(remainingDistance, waypoint.FinalSpeed())
                    targetSpeed = evaluateNewLimit(targetSpeed, brakeMaxSpeed, "Brake")
                    flightData.brakeMaxSpeed = brakeMaxSpeed
                end

                if not inAtmo then
                    -- Braking in space
                    -- Space engines take a while to turn off so if we'd reach the end point within that time, adjust speed
                    -- so we brake earlier, but only if we're coming to a stop (finalSpeed == 0)
                    if currentSpeed > 0 and waypoint.FinalSpeed() == 0 then
                        local timeToStarget = remainingDistance / currentSpeed
                        -- These 10 seconds are totally arbitrary, but seems safe enough.
                        if timeToStarget <= 10 then
                            targetSpeed = evaluateNewLimit(targetSpeed, targetSpeed * 0.5, "Brake/red")
                        end
                    end
                end

                flightData.waypointDist = remainingDistance

                if waypoint.FinalSpeed() == 0 then
                    targetSpeed = linearApproach(targetSpeed, remainingDistance)

                    local dirBetweenWP = (waypoint.Destination() - previousWaypoint.Destination()):Normalize()
                    local ver = universe.VerticalReferenceVector()
                    -- Both up up and down
                    local approachingVertically = dirBetweenWP:AngleToDeg(ver) < 5 or
                        dirBetweenWP:AngleToDeg(-ver) < 5

                    -- When approching the final parking position vertically, move extra slow so that there is enough time to adjust sideways.
                    if waypoint.IsLastInRoute()
                        and outsideAdjustmentMargin(waypoint)
                        and approachingVertically -- within this angle
                        and remainingDistance < 400 then
                        targetSpeed = evaluateNewLimit(targetSpeed, targetSpeed * 0.5, "Adj. apr.")
                    end
                end

                if globalMaxSpeed > 0 then
                    targetSpeed = evaluateNewLimit(targetSpeed, globalMaxSpeed, "Global max")
                end

                if geo.Limited(waypoint.DirectionTo()) then
                    targetSpeed = evaluateNewLimit(targetSpeed, 0, "Geofence")
                end

                return targetSpeed
            end

            ---@param axis Vec3
            ---@param currentPos Vec3
            ---@param nextWaypoint Waypoint
            ---@param previousWaypoint Waypoint
            ---@param t number Time interval in seconds
            ---@return Vec3 direction
            ---@return number length
            local function getAdjustmentDataInFuture(axis, currentPos, nextWaypoint, previousWaypoint, t)
                -- Don't make adjustments in the travel direction.
                if abs(axis:Dot(nextWaypoint:DirectionTo())) < adjustmentThreshold then
                    local posInFuture = currentPos + Velocity() * t + 0.5 * Acceleration() * t * t
                    local targetFuture = calc.NearestOnLineBetweenPoints(previousWaypoint.Destination(),
                        nextWaypoint.Destination(),
                        posInFuture)
                    local toTargetFuture = (targetFuture - posInFuture):ProjectOn(axis)
                    return toTargetFuture:NormalizeLen()
                else
                    return Vec3.zero, 0
                end
            end

            ---@param axis Vec3
            ---@param currentPos Vec3
            ---@param data AdjustmentTracker
            ---@param nextWaypoint Waypoint
            ---@param previousWaypoint Waypoint
            ---@return Vec3 acceleration
            ---@return number distance
            ---@return integer Sign Positive if we need to move in the axis direction
            local function calcAdjustAcceleration(axis, data, currentPos, nextWaypoint, previousWaypoint)
                local directionNow, distanceNow = getAdjustmentDataInFuture(axis, currentPos, nextWaypoint, previousWaypoint, 0)
                local directionFuture, distanceFuture = getAdjustmentDataInFuture(axis, currentPos, nextWaypoint,
                    previousWaypoint, 4)

                local acc = Vec3.zero

                if directionNow:Dot(directionFuture) < 0 then
                    -- Will have passed the path, break if we'll be outside the margin;
                    -- we check this so that we don't prevent ourselves from moving sideways etc.
                    if distanceFuture > DefaultMargin
                        and lastReadMass > LightConstructMassThreshold -- Don't do the braking on light constructs, it causes jitter.
                    then
                        acc = directionFuture * calc.CalcBrakeAcceleration(Velocity():Dot(axis), distanceNow)
                    end
                else
                    local mul = Clamp(data.Feed(distanceNow), 0, 1)
                    acc = directionNow * mul * engine.GetAvailableThrust(false, directionNow)
                end

                return acc, distanceNow, Sign(directionNow:Dot(axis))
            end

            ---Adjust for deviation from the desired path
            ---@param currentPos Vec3
            ---@param nextWaypoint Waypoint
            ---@param previousWaypoint Waypoint
            ---@return Vec3
            local function adjustForDeviation(currentPos, nextWaypoint, previousWaypoint)
                local vertAcc, vertDist, vertDistSign = calcAdjustAcceleration(Up(), vertAdjData, currentPos, nextWaypoint,
                    previousWaypoint)
                local latAcc, latDist, latDistSign = calcAdjustAcceleration(Right(), latAdjData, currentPos, nextWaypoint,
                    previousWaypoint)
                local longAcc, longDist, longDistSign = calcAdjustAcceleration(Forward(), longAdjData, currentPos, nextWaypoint,
                    previousWaypoint)

                adjustData.lat = latDist * latDistSign
                adjustData.long = longDist * longDistSign
                adjustData.ver = vertDist * vertDistSign

                return vertAcc + latAcc + longAcc
            end

            ---Applies the acceleration to the engines
            ---@param acceleration Vec3|nil
            ---@param adjustmentAcc Vec3
            local function applyAcceleration(acceleration, adjustmentAcc)
                if acceleration == nil then
                    SetEngineCommand("thrust", { 0, 0, 0 }, { 0, 0, 0 }, true, true, "", "", "", 1)
                    return
                end

                -- Counter gravity pull and air friction
                local acc = adjustmentAcc - universe:VerticalReferenceVector() * G() - AirFrictionAcc()

                if abs(yaw.OffsetDegrees()) < yawAlignmentThrustLimiter
                    and abs(pitch.OffsetDegrees()) < pitchAlignmentThrustLimiter
                    and abs(roll.OffsetDegrees()) < rollAlignmentThrustLimiter then
                    acc = acc + acceleration * input.Throttle() -- throttle also affects brake acceleration using engines
                end

                -- Make sure that engine tags only include the absolute minimum number of engines as it
                -- is the first command to the engine that takes effect, not the last one. For example,
                -- lateral engines must be adressed with 'lateran AND analog' or a lateral rocket engine
                -- also gets the command.

                -- You can mix space (AND) and comma (OR), AND groups will be evaluated first so you can do
                -- "A B, C D", meaning (A and B) or (C and D)

                -- Vertical AND analog.
                SetEngineCommand("vertical analog", { acc:ProjectOn(Up()):Unpack() }, { 0, 0, 0 }, true, true, "airfoil",
                    "ground", "analog", 0.1)

                -- longitudinal AND analog
                SetEngineCommand("longitudinal analog", { acc:ProjectOn(Forward()):Unpack() }, { 0, 0, 0 }, true, true, "",
                    "", "", 0.1)

                -- When in manual mode we want to counter lateral drift by the same amount of force as air friction.
                -- Note the two-multiplier to counter it already being subtracted above
                local driftComp = AirFrictionAcc():ProjectOn(Right()) * ((isFrozen and IsInAtmo()) and 2 or 0)

                -- Lateral AND analog
                SetEngineCommand("lateral analog", { (acc:ProjectOn(Right()) + driftComp):Unpack() }, { 0, 0, 0 }, true,
                    true, "", "", "", 0.1)

                if boosterStateChanged then
                    boosterStateChanged = false
                    SetEngineThrust("rocket_engine", boosterActive and 1 or 0)
                end
            end

            ---@param deltaTime number The time since last Flush
            ---@param waypoint Waypoint The next waypoint
            ---@param previousWaypoint Waypoint The next waypoint
            ---@return Vec3 #The acceleration
            ---@return number #The speed limit
            local function move(deltaTime, waypoint, previousWaypoint)
                local direction = waypoint.DirectionTo()
                local velocity = Velocity()
                local currentSpeed = velocity:Len()

                local speedLimit = getSpeedLimit(deltaTime, velocity, waypoint, previousWaypoint)

                local diff = speedLimit - currentSpeed
                flightData.speedDiff = diff

                -- Only feed speed pid when not going fast enough to avoid accelerating when speed is too high
                if diff >= 0 then
                    -- Feed the pid with 1/100:th to give it a wider working range.
                    speedPid:inject(diff / 100)
                else
                    speedPid:reset()
                end

                -- Don't let the pid value go outside 0 ... 1 - that would cause the calculated thrust to get
                -- skewed outside its intended values and push us off the path, or make us fall when holding position (if pid gets <0)
                local pidValue = Clamp(speedPid:get(), 0, 1)

                flightData.pid = pidValue

                local acceleration
                if waypoint.DistanceTo() <= DefaultMargin then
                    -- At this point we let the adjustment code control
                    acceleration = Vec3.zero
                else
                    acceleration = direction * pidValue * engine.GetAvailableThrust(not isFrozen, direction)
                end

                flightData.controlAcc = acceleration:Len()
                return acceleration, speedLimit
            end

            ---Flush method for the FSM
            ---@param deltaTime number
            ---@param next Waypoint
            ---@param previous Waypoint
            function s.FsmFlush(deltaTime, next, previous)
                if currentState.DisablesAllThrust() then
                    applyAcceleration(nil, nullVec)
                    brakes.Feed(nullVec, nullVec, 0)
                else
                    local pos = Current()
                    local nearest = calc.NearestOnLineBetweenPoints(previous.Destination(), next.Destination(), pos)

                    currentState.Flush(deltaTime, next, previous, nearest)

                    if brakes.Active() then
                        s.SetBooster(false)
                    end

                    local acceleration, speedLimit = move(deltaTime, next, previous)
                    local adjustmentAcc = adjustForDeviation(pos, next, previous)

                    -- Feed the break the acceleration vector only, not including the adjustments - we might not be accelerating at all but still adjusting for gravity pull.
                    brakes.Feed(next.DirectionTo(), acceleration:Normalize(), speedLimit)

                    applyAcceleration(acceleration, adjustmentAcc)
                end
            end

            ---Sets a new state
            ---@param state FlightState
            function s.SetState(state)
                if currentState ~= nil then
                    currentState.Leave()
                end

                if state == nil then
                    flightData.fsmState = "No state"
                    return
                else
                    flightData.fsmState = state:Name()
                    state.Enter()
                end

                currentState = state
            end

            ---Sets the engine warmup time
            ---@param time number
            function s.SetEngineWarmupTime(time)
                warmupTime = time * 2 -- Warmup time is to T50, so double it for full engine effect
            end

            ---Checks if we're still on the path
            ---@param currentPos Vec3
            ---@param nearestPointOnPath Vec3
            ---@param previousWaypoint Waypoint
            ---@param nextWaypoint Waypoint
            ---@return boolean
            function s.CheckPathAlignment(currentPos, nearestPointOnPath, previousWaypoint, nextWaypoint)
                --[[ As waypoints can have large margins, we need to ensure that we allow for offsets as large as the margins, at each end.
                    The outer edges are a straight line between the edges of the start and end point spheres so allowed offset can be calculated linearly.
                ]]
                local startPos = previousWaypoint.Destination()
                local startMargin = previousWaypoint.Margin()
                local endPos = nextWaypoint.Destination()
                local endMargin = nextWaypoint.Margin()

                local dist = (endPos - startPos):Len()
                local diff = endMargin - startMargin
                local koeff = 0
                if dist ~= 0 then
                    koeff = diff / dist
                end

                local travelDist = min(dist, (startPos - Current()):Len())
                local allowedOffset = startMargin + koeff * travelDist
                local toNearest = (nearestPointOnPath - currentPos):Len()

                return toNearest <= max(minimumPathCheckOffset, allowedOffset)
            end

            ---Sets a temporary waypoint, or removes the current one
            ---@param wp Waypoint|nil
            function s.SetTemporaryWaypoint(wp)
                temporaryWaypoint = wp
            end

            function s.Update()
                if currentState ~= nil then
                    flightData.acceleration = Acceleration():Len()
                    flightData.absSpeed = Velocity():Len()
                    currentState.Update()
                    pub.Publish("FlightData", flightData)
                    pub.Publish("AdjustmentData", adjustData)
                end
                lastReadMass = TotalMass()
                isFrozen = IsFrozen()
            end

            function s.AtWaypoint(isLastWaypoint, next, previous)
                if currentState ~= nil then
                    currentState.AtWaypoint(isLastWaypoint, next, previous)
                end
            end

            settings.Callback("engineWarmup", function(value)
                s.SetEngineWarmupTime(value)
            end)

            settings.Callback("speedp", function(value)
                speedPid = PID(value, speedPid.i, speedPid.d, speedPid.amortization)
            end)

            settings.Callback("speedi", function(value)
                speedPid = PID(speedPid.p, value, speedPid.d, speedPid.amortization)
            end)

            settings.Callback("speedd", function(value)
                speedPid = PID(speedPid.p, speedPid.i, value, speedPid.amortization)
            end)

            settings.Callback("speeda", function(value)
                speedPid = PID(speedPid.p, speedPid.i, speedPid.d, value)
            end)

            settings.Callback("yawAlignmentThrustLimiter", function(value)
                yawAlignmentThrustLimiter = value
            end)

            settings.Callback("pitchAlignmentThrustLimiter", function(value)
                pitchAlignmentThrustLimiter = value
            end)

            settings.Callback("rollAlignmentThrustLimiter", function(value)
                rollAlignmentThrustLimiter = value
            end)

            ---@return Settings
            function s.GetSettings()
                return settings
            end

            ---@return RouteController
            function s.GetRouteController()
                return routeController
            end

            local fc ---@type FlightCore

            function s.SetFlightCore(core)
                fc = core
            end

            function s.GetFlightCore()
                return fc
            end

            function s.DisablesAllThrust()
                return currentState and currentState.DisablesAllThrust() or false
            end

            function s.PreventNextWp()
                return currentState and currentState.PreventNextWp() or false
            end

            s.SetState(Idle.New(s))

            return setmetatable(s, FlightFSM)
        end


        return FlightFSM


        end)

        package.preload['YFS:flight/FlightCore.lua']=(function()

        require('YFS:../e/lib/src/abstraction/Vehicle.lua')

        require('YFS:GlobalTypes.lua')

        local s                                                               = require('YFS:Singletons.lua')

        local log, gateControl, pub, universe, calc, constants, brakes, floor = s.log, s.gateCtrl, s.pub, s.universe, s.calc,
            s.constants, s.brakes, s.floorDetector
        local VertRef                                                         = s.universe.VerticalReferenceVector


        local AxisManager, Ternary, plane, abs, delta                         = require('YFS:flight/AxisManager.lua'), calc.Ternary,
            Plane.NewByVertialReference(), math.abs, Stopwatch.New()

        require('YFS:flight/state/Require.lua')


        ---@module "flight/route/RouteController"


        ---@class FlightCore

        ---@field ReceiveEvents fun()

        ---@field GetRouteController fun():RouteController

        ---@field NextWP fun()

        ---@field StartFlight fun()

        ---@field Turn fun(degrees:number, axis:Vec3):Vec3

        ---@field AlignTo fun(point:Vec3)

        ---@field StopEvents fun()

        ---@field CreateWPFromPoint fun(p:Point, lastInRoute:boolean, pathAlignmentDistanceLimitFromSurface:number):Waypoint

        ---@field GoIdle fun()

        ---@field GotoTarget fun(target:Vec3, lockdir:Vec3, margin:number, maxSpeed:number, finalSpeed:number, ignoreLastInRoute:boolean, forceVerticalUp:boolean, routeName:string|nil)

        ---@field WaitForGate fun():boolean

        ---@field StartParking fun(distance:number, routeName:string)


        local FlightCore = {}

        FlightCore.__index = FlightCore

        local singleton


        local defaultFinalSpeed = 0

        local defaultMargin = constants.flight.defaultMargin


        ---Creates a waypoint from a point

        ---@param point Point

        ---@param lastInRoute boolean

        ---@param pathAlignmentDistanceLimitFromSurface number

        ---@return Waypoint

        function FlightCore.CreateWPFromPoint(point, lastInRoute, pathAlignmentDistanceLimitFromSurface)
            local opt = point.Options()
            local lockDir = Vec3.New(opt.Get(PointOptions.LOCK_DIRECTION, Vec3.zero))
            local margin = opt.Get(PointOptions.MARGIN, defaultMargin)
            local finalSpeed
            if opt.Get(PointOptions.FORCE_FINAL_SPEED) then
                finalSpeed = opt.Get(PointOptions.FINAL_SPEED, defaultFinalSpeed)
            else
                finalSpeed = Ternary(lastInRoute, 0, opt.Get(PointOptions.FINAL_SPEED, defaultFinalSpeed))
            end
            local maxSpeed = opt.Get(PointOptions.MAX_SPEED, 0) -- 0 = ignored/max speed.

            local coordinate = universe.ParsePosition(point.Pos()).Coordinates()

            local wp = Waypoint.New(coordinate, finalSpeed, maxSpeed, margin, pathAlignmentDistanceLimitFromSurface)
            wp.SetLastInRoute(lastInRoute)

            if lockDir ~= Vec3.zero then
                wp.LockYawTo(lockDir, true)
            end

            if opt.Get(PointOptions.FORCE_VERT, false) then
                wp.ForceUpAlongVerticalRef()
            end

            return wp
        end


        ---Creates a new FlightCore

        ---@param routeController RouteController

        ---@param flightFSM FlightFSM

        ---@return FlightCore

        function FlightCore.New(routeController, flightFSM)
            local s = {}

            local flushHandlerId = 0
            local updateHandlerId = 0
            local axes = AxisManager.Instance()
            local settings = flightFSM.GetSettings()

            local routePublishTimer = Stopwatch.New()

            local function createDefaultWP()
                return Waypoint.New(Current(), 0, 0, defaultMargin, 0)
            end

            -- Setup start waypoints to prevent nil values
            local currentWaypoint = createDefaultWP() -- The positions we want to move to
            local previousWaypoint = currentWaypoint  -- Previous waypoint
            local route = nil ---@type Route|nil

            ---Gets the route controller
            ---@return RouteController
            function s.GetRouteController()
                return routeController
            end

            ---Selects the next waypoint
            function s.NextWP()
                if route == nil then
                    return
                end

                local nextPoint = route.Next()
                if nextPoint == nil then
                    return
                end

                previousWaypoint = currentWaypoint
                currentWaypoint = FlightCore.CreateWPFromPoint(nextPoint, route.LastPointReached(),
                    settings.Number("pathAlignmentDistanceLimitFromSurface"))

                -- When the next waypoint is nearly above or below us, lock yaw
                local dir = (currentWaypoint.Destination() - previousWaypoint.Destination()):NormalizeInPlace()
                if abs(dir:Dot(plane.Up())) > 0.9 then
                    currentWaypoint.LockYawTo(plane.Forward(), false)
                end
            end

            function s.WaitForGate()
                return route and gateControl.Enabled() and route.WaitForGate(Current(), settings.Number("gateControlDistance"))
            end

            ---@param distance number
            ---@param routeName string
            function s.StartParking(distance, routeName)
                if not floor.Present() then
                    log.Error("No floor detector present")
                    return
                end

                gateControl.Enable(true)
                local target = Current() + VertRef() * distance
                pub.Publish("ResetWSAD", true)
                s.GotoTarget(target, plane.Forward(), 1, calc.Kph2Mps(settings.Number("parkMaxSpeed")), 0, false, true, routeName)
                routeController.CurrentRoute().AddTag("RegularParkingTag")
            end

            ---Starts the flight
            function s.StartFlight()
                route = routeController.CurrentRoute()
                if not route then
                    log.Error("Can't start a flight without a route")
                    return
                end

                routePublishTimer.Start()

                -- Setup waypoint that will be the previous waypoint
                currentWaypoint = createDefaultWP()
                s.NextWP()

                if s.WaitForGate() then
                    flightFSM.SetState(OpenGates.New(flightFSM, Current(), plane.Forward()))
                else
                    flightFSM.SetState(Travel.New(flightFSM))
                end
            end

            function s.GoIdle()
                flightFSM.SetState(Idle.New(flightFSM))
            end

            ---Rotates current waypoint with the given angle
            ---@param degrees number The angle to turn
            ---@param axis Vec3
            ---@return Vec3 # The alignment direction
            function s.Turn(degrees, axis)
                local current = Current()
                local forwardPointOnPlane = calc.ProjectPointOnPlane(axis, current,
                    current + Forward() * Waypoint.DirectionMargin)
                forwardPointOnPlane = calc.RotateAroundAxis(forwardPointOnPlane, current, degrees, axis)
                local dir = (forwardPointOnPlane - Current()):NormalizeInPlace()
                currentWaypoint.LockYawTo(dir, true)
                pub.Publish("ForwardDirectionChanged", dir)
                return dir
            end

            ---Aligns to the point
            ---@param point Vec3
            function s.AlignTo(point)
                if currentWaypoint then
                    local current = Current()
                    local pointOnPlane = calc.ProjectPointOnPlane(-universe.VerticalReferenceVector(), current, point)
                    local dir = (pointOnPlane - current):NormalizeInPlace()
                    ---QQQ Just (point - curr):NormalizeInPlace() ???
                    currentWaypoint.LockYawTo(dir, true)
                    pub.Publish("ForwardDirectionChanged", dir)
                end
            end

            ---Hooks up the events needed for flight
            function s.ReceiveEvents()
                ---@diagnostic disable-next-line: undefined-field
                flushHandlerId = system:onEvent("onFlush", s.fcFlush)
                ---@diagnostic disable-next-line: undefined-field
                updateHandlerId = system:onEvent("onUpdate", s.fcUpdate)
                axes.ReceiveEvents()
            end

            ---Disconnects events
            function s.StopEvents()
                ---@diagnostic disable-next-line: undefined-field
                system:clearEvent("flush", flushHandlerId)
                ---@diagnostic disable-next-line: undefined-field
                system:clearEvent("update", updateHandlerId)
                axes.StopEvents()
            end

            ---Starts a movement towards the given coordinate.
            ---@param target Vec3
            ---@param lockDir Vec3 If not zero, direction is locked to this direction
            ---@param margin number meter
            ---@param maxSpeed number m/s
            ---@param finalSpeed number m/s
            ---@param forceFinalSpeed boolean If true, the construct will not slow down to come to a stop if the point is last in the route (used for manual control)
            ---@param forceVerticalUp boolean If true, forces up to align to vertical up
            ---@param routeName string|nil Name of route
            function s.GotoTarget(target, lockDir, margin, maxSpeed, finalSpeed, forceFinalSpeed, forceVerticalUp, routeName)
                local temp = routeController.ActivateTempRoute(routeName)
                local targetPoint = temp.AddCoordinate(target)
                local opt = targetPoint.Options()
                opt.Set(PointOptions.MAX_SPEED, maxSpeed)
                opt.Set(PointOptions.MARGIN, margin)
                opt.Set(PointOptions.FINAL_SPEED, finalSpeed)
                opt.Set(PointOptions.FORCE_FINAL_SPEED, forceFinalSpeed)
                opt.Set(PointOptions.FORCE_VERT, forceVerticalUp)

                if not lockDir:IsZero() then
                    opt.Set(PointOptions.LOCK_DIRECTION, { lockDir:Unpack() })
                end

                s.StartFlight()
            end

            function s.fcUpdate()
                local status, err, _ = xpcall(
                    function()
                        flightFSM.Update()
                        brakes.BrakeUpdate()

                        if route and routePublishTimer.Elapsed() > 0.5 then
                            routePublishTimer.Restart()
                            pub.Publish("RouteData", {
                                remaining = route.GetRemaining(Current()),
                                activeRouteName = routeController.ActiveRouteName()
                            })
                        end

                        if currentWaypoint ~= nil then
                            pub.Publish("WaypointData", currentWaypoint)

                            if settings.Boolean("setWaypointAlongRoute", false) then
                                system.setWaypoint(universe.CreatePos(currentWaypoint.Destination()).AsPosString(), false)
                            end
                        end
                    end,
                    traceback
                )

                if not status then
                    system.print(err)
                    unit.exit()
                end
            end

            function s.fcFlush()
                local status, err, _ = xpcall(
                    function()
                        local deltaTime = 0
                        if not delta.IsRunning() then
                            delta.Start()
                        end

                        deltaTime = delta.Elapsed()
                        delta.Restart()

                        if currentWaypoint and route then
                            -- A state can set temporary waypoints so we switch before calling the FSM (and the states) so
                            -- that from this point eveything works with the same WPs without having to know to switch.
                            local prevWP = previousWaypoint
                            local nextWP, switched = flightFSM.SelectWP(currentWaypoint)

                            if switched then
                                prevWP = Waypoint.New(Current(), 0, 0, currentWaypoint.Margin(),
                                    currentWaypoint.PathAlignmentDistanceLimitFromSurface())
                            end

                            flightFSM.FsmFlush(deltaTime, nextWP, prevWP)

                            nextWP.PreCalc(prevWP)
                            axes.SetYawTarget(nextWP.Yaw(prevWP))
                            axes.SetPitchTarget(nextWP.Pitch(prevWP))
                            axes.SetRollTarget(nextWP.Roll(prevWP))

                            if nextWP.WithinMargin(WPReachMode.ENTRY) then
                                flightFSM.AtWaypoint(route.LastPointReached(), nextWP, prevWP)

                                -- Lock direction when WP is reached, but don't override existing locks, such as is in place when strafing.
                                local lockDir = (nextWP.Destination() - prevWP.Destination())
                                    :NormalizeInPlace()
                                nextWP.LockYawTo(lockDir, false)

                                if not flightFSM.PreventNextWp() then
                                    -- Switch to next waypoint
                                    s.NextWP()
                                end
                            end
                        else
                            --- This is a workaround for engines remembering their states from a previous session; shut down all engines.
                            unit.setEngineCommand("all", { 0, 0, 0 }, { 0, 0, 0 }, true, true, "", "", "", 1)
                        end

                        if not flightFSM.DisablesAllThrust() then
                            axes.Flush(deltaTime)
                        end

                        brakes:BrakeFlush()
                    end,
                    traceback
                )

                if not status then
                    system.print(err)
                    unit.exit()
                end
            end

            singleton = setmetatable(s, FlightCore)
            return singleton
        end


        -- The module

        return FlightCore


        end)

        package.preload['YFS:../e/lib/src/util/ValueTree.lua']=(function()

        ---A ValueTree works a bit like Json; it allows you to set values in a tree structure.

        ---@class ValueTree

        ---@field Set fun(topicPath:string, value:string|number|boolean|table|nil)

        ---@field Pick fun():table

        ---@field Peek fun():table


        local ValueTree = {}

        ValueTree.__index = ValueTree


        ---Creates a new ValueTree

        ---@return ValueTree

        function ValueTree.New()
            local s = {}
            local tree = {}

            ---Sets the value in tree
            ---@param topicPath string A path or just a name, such as a/b or just myValue.
            ---@param value string|number|boolean|table|nil
            function s.Set(topicPath, value)
                -- Build a tree for the path
                local parts = {}

                for nodeName in string.gmatch(topicPath, "[a-zA-Z0-9_]+") do
                    table.insert(parts, nodeName)
                end

                if not tree then
                    tree = {}
                end

                local curr = tree
                for i, nodeName in ipairs(parts) do
                    if i == #parts then
                        -- Save the name for the value
                        break
                    end
                    if not curr[nodeName] then
                        curr[nodeName] = {}
                    end
                    curr = curr[nodeName]
                end

                curr[parts[#parts]] = value
            end

            ---Picks the current tree, or returns nil if no data is available.
            ---@return table|nil
            function s.Pick()
                local old = tree
                tree = nil
                return old
            end

            ---Returns the current tree or nil if no data is available
            ---@return table
            function s.Peek()
                return tree
            end

            return setmetatable(s, ValueTree)
        end


        return ValueTree


        end)

        package.preload['YFS:screen/layout_out.lua']=(function()

        local layout = {
            fonts = {
                p14 = {
                    font = "Play",
                    size = 14
                },
                p18 = {
                    font = "Play",
                    size = 18
                },
                p24 = {
                    font = "Play",
                    size = 24
                },
                p36 = {
                    font = "Play",
                    size = 36
                },
            },
            styles = {
                bkgDark = {
                    fill = "#000000ff"
                },
                bkgLight = {
                    fill = "#111111ff",
                },
                icon = {
                    fill = "#ffffffff",
                },
                headerText = {
                    fill = "#555555ff",
                    align = "h0,v3"
                },
                headerTextRight = {
                    fill = "#555555ff",
                    align = "h2,v3"
                },
                info = {
                    fill = "#ffffffff",
                    align = "h2,v3"
                },
                units = {
                    fill = "#ffffffff",
                    align = "h2,v3"
                },
                routeButton = {
                    align = "h1,v2",
                    fill = "#546263ff",
                },
                routeButtonHover = {
                    fill = "#2f6fd0ff"
                },
                routeCover = {
                    fill = "#111111ff",
                    stroke = {
                        color = "#111111ff",
                        distance = 1
                    }
                },
                routeEndpointText = {
                    fill = "#000000ff",
                    align = "h1,v2"
                },
                routeName = {
                    fill = "#ffffffff",
                    align = "h1,v3"
                },
                ---- Route editor -----
                routeEditTableHeader = {
                    fill = "#888888ff",
                    align = "h0, v3"
                },
                routeEditTableData = {
                    fill = "#ffffffff",
                    align = "h0,v3"
                },
                routeEditTableDataCentered = {
                    fill = "#ffffffff",
                    align = "h1,v3"
                },
                routeEditTableDataRight = {
                    fill = "#ffffffff",
                    align = "h2,v3"
                },
                routeEditHover = {
                    fill = "#2f6fd0ff",
                    align = "h0,v3"
                },
                routeEditHoverRight = {
                    fill = "#2f6fd0ff",
                    align = "h2,v3"
                },
                routeEditHoverRed = {
                    fill = "#ff0000ff",
                    align = "h0,v3"
                },
                routeEditTableDataCenteredHover = {
                    fill = "#2f6fd0ff",
                    align = "h1,v3"
                },
                editRouteRouteName = {
                    fill = "#ffffffff",
                    align = "h0,v3"
                },
                split = {
                    stroke = {
                        distance = 2,
                        color = "#181818FF"
                    }
                }
            },
            pages = {
                status = {
                    components = {
                        {
                            type = "box",
                            layer = 1,
                            style = "bkgDark",
                            pos1 = "(0,0)",
                            pos2 = "(1024,240)"
                        },
                        {
                            type = "box",
                            layer = 1,
                            style = "icon",
                            pos1 = "(40,20)",
                            pos2 = "(60,40)",
                            replicate = {
                                x_count = 2,
                                y_count = 2,
                                x_step = 40,
                                y_step = 40
                            }
                        },
                        {
                            type = "box",
                            layer = 1,
                            style = "icon",
                            pos1 = "(60,40)",
                            pos2 = "(80,60)"
                        },
                        {
                            type = "text",
                            layer = 1,
                            style = "headerText",
                            pos1 = "(120,20)",
                            text = "Total mass",
                            font = "p18"
                        },
                        {
                            type = "text",
                            layer = 1,
                            style = "info",
                            pos1 = "(280,50)",
                            font = "p36",
                            text = "$num(path{mass:total}:init{0}:format{%0.2f}:interval{0.5})"
                        },
                        {
                            type = "text",
                            layer = 1,
                            style = "units",
                            pos1 = "(260,70)",
                            font = "p14",
                            text = "$str(path{mass:totalUnit}:init{kg}:interval{0.5})"
                        },
                        {
                            type = "text",
                            layer = 1,
                            style = "headerText",
                            pos1 = "(300,20)",
                            text = "Current speed",
                            font = "p18"
                        },
                        {
                            type = "text",
                            layer = 1,
                            style = "info",
                            pos1 = "(460,50)",
                            font = "p36",
                            text = "$num(path{flightData:absSpeed}:init{0}:format{%0.2f}:interval{0.5})"
                        },
                        {
                            type = "text",
                            layer = 1,
                            style = "units",
                            pos1 = "(440,70)",
                            font = "p14",
                            text = "$str(path{flightData:speedUnit}:init{km/h}:interval{0.5})"
                        },
                        {
                            type = "text",
                            layer = 1,
                            style = "headerText",
                            pos1 = "(480,20)",
                            text = "Current route",
                            font = "p18"
                        },
                        {
                            type = "text",
                            layer = 1,
                            style = "info",
                            pos1 = "(640,50)",
                            font = "p36",
                            text = "$str(path{route/current:name}:init{-}:interval{0.5})"
                        },
                        {
                            type = "box",
                            layer = 1,
                            style = "icon",
                            pos1 = "(60,140)",
                            pos2 = "(80,160)",
                            replicate = {
                                x_count = 1,
                                y_count = 2,
                                y_step = 40
                            }
                        },
                        {
                            type = "box",
                            layer = 1,
                            style = "icon",
                            pos1 = "(40,160)",
                            pos2 = "(60,180)",
                            replicate = {
                                x_count = 2,
                                y_count = 1,
                                x_step = 40
                            }
                        },
                        {
                            type = "text",
                            layer = 1,
                            style = "headerText",
                            pos1 = "(120,140)",
                            text = "Remaining distance",
                            font = "p18"
                        },
                        {
                            type = "text",
                            layer = 1,
                            style = "info",
                            pos1 = "(280,170)",
                            font = "p36",
                            text = "$num(path{finalWp:distance}:init{0}:format{%0.2f}:interval{0.5})"
                        },
                        {
                            type = "text",
                            layer = 1,
                            style = "units",
                            pos1 = "(260,190)",
                            font = "p14",
                            text = "$str(path{finalWp:distanceUnit}:init{km}:interval{0.5})"
                        },
                        {
                            type = "text",
                            layer = 1,
                            style = "headerText",
                            pos1 = "(300,140)",
                            text = "Next WP distance",
                            font = "p18"
                        },
                        {
                            type = "text",
                            layer = 1,
                            style = "info",
                            pos1 = "(460,170)",
                            font = "p36",
                            text = "$num(path{nextWp:distance}:init{0}:format{%0.2f}:interval{0.5})"
                        },
                        {
                            type = "text",
                            layer = 1,
                            style = "units",
                            pos1 = "(440,190)",
                            font = "p14",
                            text = "$str(path{nextWp:distanceUnit}:init{km}:interval{0.5})"
                        },
                        {
                            type = "text",
                            layer = 1,
                            style = "headerText",
                            pos1 = "(480,140)",
                            text = "Deviation",
                            font = "p18"
                        },
                        {
                            type = "text",
                            layer = 1,
                            style = "info",
                            pos1 = "(640,170)",
                            font = "p36",
                            text = "$str(path{deviation:distance}:init{}:interval{0.5})"
                        },
                        {
                            type = "text",
                            layer = 1,
                            style = "units",
                            pos1 = "(620,190)",
                            font = "p14",
                            text = "m"
                        }
                    }
                },
                floor = {
                    components = {
                        {
                            type = "box",
                            layer = 1,
                            style = "bkgLight",
                            pos1 = "(0,241)",
                            pos2 = "(1024,613)"
                        },
                        {
                            type = "box",
                            layer = 1,
                            visible = true,
                            pos1 = "(40,280)",
                            pos2 = "(160,320)",
                            style = "routeButton",
                            mouse = {
                                inside = {
                                    set_style = "routeButtonHover"
                                },
                                click = {
                                    command = "$str(path{floorSelection:routeName}:init{}:format{route-activate '%s'})"
                                }
                            }
                        },
                        {
                            type = "box",
                            layer = 1,
                            visible = true,
                            pos1 = "(40,300)",
                            pos2 = "(60,320)",
                            style = "routeCover",
                            replicate = {
                                x_count = 2,
                                x_step = 160
                            }
                        },
                        {
                            type = "box",
                            layer = 1,
                            visible = true,
                            pos1 = "(140,300)",
                            pos2 = "(160,320)",
                            style = "routeCover",
                            replicate = {
                                x_count = 2,
                                x_step = 160
                            }
                        },
                        {
                            type = "text",
                            layer = 1,
                            visible = true,
                            pos1 = "(100,300)",
                            text = "End",
                            style = "routeEndpointText",
                            font = "p14",
                            hitable = false
                        },
                        {
                            type = "box",
                            layer = 1,
                            visible = true,
                            pos1 = "(40,380)",
                            pos2 = "(160,420)",
                            style = "routeButton",
                            mouse = {
                                inside = {
                                    set_style = "routeButtonHover"
                                },
                                click = {
                                    command =
                                    "$str(path{floorSelection:routeName}:init{}:format{route-activate '%s' -index 1})"
                                }
                            }
                        },
                        {
                            type = "text",
                            layer = 1,
                            pos1 = "(100, 360)",
                            visible = true,
                            style = "routeName",
                            font = "p24",
                            text = "$str(path{floorSelection:routeName}:init{})"
                        },
                        {
                            type = "box",
                            layer = 1,
                            visible = true,
                            pos1 = "(40,380)",
                            pos2 = "(60,400)",
                            style = "routeCover"
                        },
                        {
                            type = "box",
                            layer = 1,
                            visible = true,
                            pos1 = "(140,380)",
                            pos2 = "(160,400)",
                            style = "routeCover"
                        },
                        {
                            type = "text",
                            layer = 1,
                            visible = true,
                            pos1 = "(100,400)",
                            text = "Start",
                            style = "routeEndpointText",
                            font = "p14",
                            hitable = false
                        },
                        {
                            type = "text",
                            layer = 1,
                            style = "routeEditTableData",
                            font = "p24",
                            pos1 = "(180, 300)",
                            text = "$num(path{floorSelection/points/[#]:index}:init{0})",
                            visible = "$bool(path{floorSelection/points/[#]:visible}:init{false})",
                            replicate = {
                                y_count = 8,
                                y_step = 30,
                                x_count = 3,
                                x_step = 260,
                                column_mode = true
                            }
                        },
                        {
                            type = "text",
                            layer = 1,
                            style = "routeEditTableData",
                            font = "p24",
                            pos1 = "(220, 300)",
                            text = "$str(path{floorSelection/points/[#]:name}:init{})",
                            visible = "$bool(path{floorSelection/points/[#]:visible}:init{false})",
                            mouse = {
                                click = {
                                    command =
                                    "$str(path{floorSelection/points/[#]:activate}:init{}:format{%s})"
                                },
                                inside = {
                                    set_style = "routeEditHover"
                                }
                            },
                            replicate = {
                                y_count = 8,
                                y_step = 30,
                                x_count = 3,
                                x_step = 260,
                                column_mode = true
                            }
                        },
                        {
                            type = "text",
                            layer = 1,
                            font = "p24",
                            style = "routeEditTableData",
                            pos1 = "(20,600)",
                            text = "$num(path{floorSelection:currentPage}:init{1}:format{< %0.0f})",
                            mouse = {
                                click = {
                                    command = "#fl-prev-floor-page"
                                },
                                inside = {
                                    set_style = "routeEditHover"
                                }
                            }
                        },
                        {
                            type = "text",
                            layer = 1,
                            font = "p24",
                            style = "routeEditTableDataRight",
                            pos1 = "(120,600)",
                            text = "$num(path{floorSelection:pageCount}:init{1}:format{ / %0.0f >})",
                            mouse = {
                                click = {
                                    command = "#fl-next-floor-page"
                                },
                                inside = {
                                    set_style = "routeEditHoverRight"
                                }
                            }
                        },
                        {
                            type = "image",
                            layer = 2,
                            pos1 = "(935,580)",
                            dimensions = "(20,20)",
                            sub = "(0,480)",
                            subDimensions = "(20,20)",
                            style = "icon",
                            url = "assets.prod.novaquark.com/94617/4158c26e-9db3-4a28-9468-b84207e44eec.png",
                            mouse = {
                                click = {
                                    command = "activatepage{status,routeSelection}"
                                },
                                inside = {
                                    set_style = "routeEditHover"
                                }
                            }
                        },
                        {
                            type = "text",
                            layer = 1,
                            font = "p24",
                            style = "routeEditTableData",
                            pos1 = "(960,600)",
                            text = "Exit",
                            mouse = {
                                click = {
                                    command = "activatepage{status,routeSelection}"
                                },
                                inside = {
                                    set_style = "routeEditHover"
                                }
                            }
                        }
                    }
                },
                routeSelection = {
                    components = {
                        {
                            type = "box",
                            layer = 1,
                            style = "bkgLight",
                            pos1 = "(0,241)",
                            pos2 = "(1024,613)"
                        },
                        {
                            type = "box",
                            layer = 1,
                            visible = "$bool(path{routeSelection/routes/[#]:visible}:init{false})",
                            pos1 = "(40,280)",
                            pos2 = "(160,320)",
                            style = "routeButton",
                            mouse = {
                                inside = {
                                    set_style = "routeButtonHover"
                                },
                                click = {
                                    command = "$str(path{routeSelection/routes/[#]:name}:init{}:format{route-activate '%s'})"
                                }
                            },
                            replicate = {
                                x_count = 6,
                                x_step = 160
                            }
                        },
                        {
                            type = "box",
                            layer = 1,
                            visible = "$bool(path{routeSelection/routes/[#]:visible}:init{false})",
                            pos1 = "(40,300)",
                            pos2 = "(60,320)",
                            style = "routeCover",
                            replicate = {
                                x_count = 6,
                                x_step = 160
                            }
                        },
                        {
                            type = "box",
                            layer = 1,
                            visible = "$bool(path{routeSelection/routes/[#]:visible}:init{false})",
                            pos1 = "(140,300)",
                            pos2 = "(160,320)",
                            style = "routeCover",
                            replicate = {
                                x_count = 6,
                                x_step = 160
                            }
                        },
                        {
                            type = "text",
                            layer = 1,
                            visible = "$bool(path{routeSelection/routes/[#]:visible}:init{false})",
                            pos1 = "(100,300)",
                            text = "End",
                            style = "routeEndpointText",
                            font = "p14",
                            hitable = false,
                            replicate = {
                                x_count = 6,
                                x_step = 160
                            }
                        },
                        {
                            type = "box",
                            layer = 1,
                            visible = "$bool(path{routeSelection/routes/[#]:visible}:init{false})",
                            pos1 = "(40,380)",
                            pos2 = "(160,420)",
                            style = "routeButton",
                            mouse = {
                                inside = {
                                    set_style = "routeButtonHover"
                                },
                                click = {
                                    command =
                                    "$str(path{routeSelection/routes/[#]:name}:init{}:format{route-activate '%s' -index 1})"
                                }
                            },
                            replicate = {
                                x_count = 6,
                                x_step = 160
                            }
                        },
                        {
                            type = "text",
                            layer = 1,
                            pos1 = "(100, 360)",
                            visible = "$bool(path{routeSelection/routes/[#]:visible}:init{false})",
                            style = "routeName",
                            font = "p24",
                            text = "$str(path{routeSelection/routes/[#]:name}:init{})",
                            replicate = {
                                x_count = 6,
                                x_step = 160
                            }
                        },
                        {
                            type = "box",
                            layer = 1,
                            visible = "$bool(path{routeSelection/routes/[#]:visible}:init{false})",
                            pos1 = "(40,380)",
                            pos2 = "(60,400)",
                            style = "routeCover",
                            replicate = {
                                x_count = 6,
                                x_step = 160
                            }
                        },
                        {
                            type = "box",
                            layer = 1,
                            visible = "$bool(path{routeSelection/routes/[#]:visible}:init{false})",
                            pos1 = "(140,380)",
                            pos2 = "(160,400)",
                            style = "routeCover",
                            replicate = {
                                x_count = 6,
                                x_step = 160
                            }
                        },
                        {
                            type = "text",
                            layer = 1,
                            visible = "$bool(path{routeSelection/routes/[#]:visible}:init{false})",
                            pos1 = "(100,400)",
                            text = "Start",
                            style = "routeEndpointText",
                            font = "p14",
                            hitable = false,
                            replicate = {
                                x_count = 6,
                                x_step = 160
                            }
                        },
                        {
                            type = "box",
                            layer = 1,
                            visible = "$bool(path{routeSelection/routes/[#]:visible}:init{false})",
                            pos1 = "(40,440)",
                            pos2 = "(160,460)",
                            style = "routeButton",
                            mouse = {
                                inside = {
                                    set_style = "routeButtonHover"
                                },
                                click = {
                                    command =
                                    "$str(path{routeSelection/routes/[#]:name}:init{}:format{floor '%s'})"
                                }
                            },
                            replicate = {
                                x_count = 6,
                                x_step = 160
                            }
                        },
                        {
                            type = "text",
                            layer = 1,
                            visible = "$bool(path{routeSelection/routes/[#]:visible}:init{false})",
                            pos1 = "(100,450)",
                            text = "Waypoints",
                            style = "routeEndpointText",
                            font = "p14",
                            hitable = false,
                            replicate = {
                                x_count = 6,
                                x_step = 160
                            }
                        },
                        {
                            type = "text",
                            layer = 1,
                            font = "p24",
                            style = "routeEditTableData",
                            pos1 = "(20,600)",
                            text = "$num(path{routeSelection:routePage}:init{1}:format{< %0.0f})",
                            mouse = {
                                click = {
                                    command = "#rsel-prev-route-page"
                                },
                                inside = {
                                    set_style = "routeEditHover"
                                }
                            }
                        },
                        {
                            type = "text",
                            layer = 1,
                            font = "p24",
                            style = "routeEditTableDataRight",
                            pos1 = "(120,600)",
                            text = "$num(path{routeSelection:pageCount}:init{1}:format{ / %0.0f >})",
                            mouse = {
                                click = {
                                    command = "#rsel-next-route-page"
                                },
                                inside = {
                                    set_style = "routeEditHoverRight"
                                }
                            }
                        },
                        {
                            type = "image",
                            layer = 2,
                            pos1 = "(800,580)",
                            dimensions = "(20,20)",
                            sub = "(0,460)",
                            subDimensions = "(20,20)",
                            style = "icon",
                            url = "assets.prod.novaquark.com/94617/4158c26e-9db3-4a28-9468-b84207e44eec.png",
                            mouse = {
                                click = {
                                    command = "activatepage{routeEdit}"
                                },
                                inside = {
                                    set_style = "routeEditHover"
                                }
                            }
                        },
                        {
                            type = "text",
                            layer = 1,
                            pos1 = "(825,600)",
                            text = "Edit",
                            style = "routeEditTableData",
                            font = "p24",
                            mouse = {
                                click = {
                                    command = "activatepage{routeEdit}"
                                },
                                inside = {
                                    set_style = "routeEditHover"
                                }
                            }
                        },
                        {
                            type = "image",
                            layer = 2,
                            pos1 = "(880,580)",
                            dimensions = "(20,20)",
                            sub = "(0,0)",
                            subDimensions = "(20,20)",
                            style = "icon",
                            url = "assets.prod.novaquark.com/94617/4158c26e-9db3-4a28-9468-b84207e44eec.png",
                            mouse = {
                                click = {
                                    command = "activatepage{details}"
                                },
                                inside = {
                                    set_style = "routeEditHover"
                                }
                            }
                        },
                        {
                            type = "text",
                            layer = 1,
                            pos1 = "(905,600)",
                            text = "Details",
                            style = "routeEditTableData",
                            font = "p24",
                            mouse = {
                                click = {
                                    command = "activatepage{details}"
                                },
                                inside = {
                                    set_style = "routeEditHover"
                                }
                            }
                        }
                    }
                },
                routeEdit = {
                    components = {
                        {
                            type = "box",
                            layer = 1,
                            style = "bkgDark",
                            pos1 = "(0,0)",
                            pos2 = "(1024,613)"
                        },
                        {
                            type = "text",
                            layer = 1,
                            style = "headerText",
                            font = "p36",
                            pos1 = "(30,50)",
                            text = "Waypoints"
                        },
                        {
                            type = "text",
                            layer = 1,
                            style = "routeEditTableHeader",
                            font = "p14",
                            pos1 = "(30,110)",
                            text = "Waypoint name"
                        },
                        {
                            type = "text",
                            layer = 1,
                            style = "routeEditTableHeader",
                            font = "p14",
                            pos1 = "(300,110)",
                            text = "Delete"
                        },
                        {
                            type = "text",
                            layer = 1,
                            style = "routeEditTableHeader",
                            font = "p14",
                            pos1 = "(370,110)",
                            text = "Insert"
                        },
                        {
                            type = "text",
                            layer = 1,
                            style = "routeEditTableHeader",
                            font = "p14",
                            pos1 = "(430,110)",
                            text = "Ins + facing"
                        },
                        {
                            type = "text",
                            layer = 1,
                            style = "routeEditTableData",
                            font = "p24",
                            pos1 = "(30, 140)",
                            text = "$str(path{availableWaypoints/wayPoints/[#]:name}:init{})",
                            visible = "$bool(path{availableWaypoints/wayPoints/[#]:visible}:init{false})",
                            mouse = {
                                click = {
                                    command =
                                    "$str(path{availableWaypoints/wayPoints/[#]:pos}:init{}:format{set-waypoint -notify %s})"
                                },
                                inside = {
                                    set_style = "routeEditHover"
                                }
                            },
                            replicate = {
                                y_count = 10,
                                y_step = 30
                            }
                        },
                        {
                            type = "text",
                            layer = 1,
                            style = "routeEditTableData",
                            font = "p24",
                            pos1 = "(300, 140)",
                            text = "X",
                            visible = "$bool(path{availableWaypoints/wayPoints/[#]:visible}:init{false})",
                            mouse = {
                                click = {
                                    command = "$str(path{availableWaypoints/wayPoints/[#]:name}:init{}:format{pos-delete '%s'})"
                                },
                                inside = {
                                    set_style = "routeEditHoverRed"
                                }
                            },
                            replicate = {
                                y_count = 10,
                                y_step = 30
                            }
                        },
                        {
                            type = "text",
                            layer = 1,
                            style = "routeEditTableData",
                            font = "p24",
                            pos1 = "(370, 140)",
                            text = ">>",
                            visible = "$bool(path{availableWaypoints/wayPoints/[#]:visible}:init{false})",
                            mouse = {
                                click = {
                                    command =
                                    "$str(path{availableWaypoints/wayPoints/[#]:name}:init{}:format{route-add-named-pos '%s'})"
                                },
                                inside = {
                                    set_style = "routeEditHover"
                                }
                            },
                            replicate = {
                                y_count = 10,
                                y_step = 30
                            }
                        },
                        {
                            type = "text",
                            layer = 1,
                            style = "routeEditTableData",
                            font = "p24",
                            pos1 = "(430, 140)",
                            text = ">>",
                            visible = "$bool(path{availableWaypoints/wayPoints/[#]:visible}:init{false})",
                            mouse = {
                                click = {
                                    command =
                                    "$str(path{availableWaypoints/wayPoints/[#]:name}:init{}:format{route-add-named-pos '%s' -lockdir})"
                                },
                                inside = {
                                    set_style = "routeEditHover"
                                }
                            },
                            replicate = {
                                y_count = 10,
                                y_step = 30
                            }
                        },
                        {
                            type = "image",
                            layer = 2,
                            pos1 = "(165,540)",
                            dimensions = "(20,20)",
                            sub = "(0,1040)",
                            subDimensions = "(20,20)",
                            style = "icon",
                            url = "assets.prod.novaquark.com/94617/4158c26e-9db3-4a28-9468-b84207e44eec.png",
                            mouse = {
                                click = {
                                    command = "pos-save-current-as -auto"
                                },
                                inside = {
                                    set_style = "routeEditHover"
                                }
                            }
                        },
                        {
                            type = "text",
                            layer = 1,
                            style = "routeEditTableDataCentered",
                            font = "p24",
                            pos1 = "(256, 560)",
                            text = "Add Current",
                            visible = true,
                            mouse = {
                                click = {
                                    command = "pos-save-current-as -auto"
                                },
                                inside = {
                                    set_style = "routeEditTableDataCenteredHover"
                                }
                            }
                        },
                        {
                            type = "text",
                            layer = 1,
                            font = "p24",
                            style = "routeEditTableData",
                            pos1 = "(20,520)",
                            text = "$num(path{availableWaypoints:currentPage}:init{1}:format{< %0.0f})",
                            mouse = {
                                click = {
                                    command = "#re-prev-wp-page"
                                },
                                inside = {
                                    set_style = "routeEditHover"
                                }
                            }
                        },
                        {
                            type = "text",
                            layer = 1,
                            font = "p24",
                            style = "routeEditTableDataRight",
                            pos1 = "(120,520)",
                            text = "$num(path{availableWaypoints:pageCount}:init{1}:format{/ %0.0f >})",
                            mouse = {
                                click = {
                                    command = "#re-next-wp-page"
                                },
                                inside = {
                                    set_style = "routeEditHoverRight"
                                }
                            }
                        },

                        {
                            type = "line",
                            layer = 1,
                            pos1 = "(512,50)",
                            pos2 = "(512,563)",
                            style = "split"
                        },

                        ------- Routes -------
                        {
                            type = "text",
                            layer = 1,
                            style = "headerTextRight",
                            font = "p36",
                            pos1 = "(994,50)",
                            text = "Routes"
                        },

                        {
                            type = "text",
                            layer = 1,
                            font = "p24",
                            style = "editRouteRouteName",
                            pos1 = "(530,50)",
                            text = "$str(path{editRoute:selectRouteName}:init{})"
                        },

                        {
                            type = "text",
                            layer = 1,
                            style = "routeEditTableData",
                            font = "p24",
                            text = "$num(path{editRoute:ix}:init{1}:format{< %0.0f})",
                            pos1 = "(530,100)",
                            mouse = {
                                click = {
                                    command = "#re-previous-route"
                                },
                                inside = {
                                    set_style = "routeEditHover"
                                }
                            }
                        },
                        {
                            type = "text",
                            layer = 1,
                            style = "routeEditTableDataRight",
                            font = "p24",
                            text = "$num(path{editRoute:count}:init{1}:format{/ %0.0f >})",
                            pos1 = "(630,100)",
                            mouse = {
                                click = {
                                    command = "#re-next-route"
                                },
                                inside = {
                                    set_style = "routeEditHoverRight"
                                }
                            }
                        },
                        {
                            type = "image",
                            layer = 2,
                            pos1 = "(815,84)",
                            dimensions = "(20,20)",
                            sub = "(0,20)",
                            subDimensions = "(20,20)",
                            style = "icon",
                            url = "assets.prod.novaquark.com/94617/4158c26e-9db3-4a28-9468-b84207e44eec.png",
                            mouse = {
                                click = {
                                    command = "$str(path{editRoute:selectRouteName}:format{route-edit '%s'}:init{})"
                                },
                                inside = {
                                    set_style = "routeEditHover"
                                }
                            }
                        },
                        {
                            type = "text",
                            layer = 1,
                            font = "p24",
                            style = "routeEditTableData",
                            pos1 = "(840,100)",
                            text = "Edit",
                            mouse = {
                                click = {
                                    command = "$str(path{editRoute:selectRouteName}:format{route-edit '%s'}:init{})"
                                },
                                inside = {
                                    set_style = "routeEditHover"
                                }
                            }
                        },
                        {
                            type = "image",
                            layer = 2,
                            pos1 = "(895,84)",
                            dimensions = "(20,20)",
                            sub = "(0,120)",
                            subDimensions = "(20,20)",
                            style = "icon",
                            url = "assets.prod.novaquark.com/94617/4158c26e-9db3-4a28-9468-b84207e44eec.png",
                            mouse = {
                                click = {
                                    command = "$str(path{editRoute:selectRouteName}:format{route-delete '%s'}:init{})"
                                },
                                inside = {
                                    set_style = "routeEditHoverRed"
                                }
                            }
                        },
                        {
                            type = "text",
                            layer = 1,
                            font = "p24",
                            style = "routeEditTableData",
                            pos1 = "(920,100)",
                            text = "Delete",
                            mouse = {
                                click = {
                                    command = "$str(path{editRoute:selectRouteName}:format{route-delete '%s'}:init{})"
                                },
                                inside = {
                                    set_style = "routeEditHoverRed"
                                }
                            }
                        },

                        ----- Waypoints in route -----
                        {
                            type = "text",
                            layer = 1,
                            style = "routeEditTableHeader",
                            font = "p14",
                            pos1 = "(530,170)",
                            text = "Waypoint name"
                        },
                        {
                            type = "text",
                            layer = 1,
                            style = "routeEditTableHeader",
                            font = "p14",
                            pos1 = "(720,170)",
                            text = "Gate"
                        },
                        {
                            type = "text",
                            layer = 1,
                            style = "routeEditTableHeader",
                            font = "p14",
                            pos1 = "(770,170)",
                            text = "Skip"
                        },
                        {
                            type = "text",
                            layer = 1,
                            style = "routeEditTableHeader",
                            font = "p14",
                            pos1 = "(820,170)",
                            text = "Sel"
                        },
                        {
                            type = "text",
                            layer = 1,
                            style = "routeEditTableHeader",
                            font = "p14",
                            pos1 = "(870,170)",
                            text = "Up"
                        },
                        {
                            type = "text",
                            layer = 1,
                            style = "routeEditTableHeader",
                            font = "p14",
                            pos1 = "(900,170)",
                            text = "Down"
                        },
                        {
                            type = "text",
                            layer = 1,
                            style = "routeEditTableHeader",
                            font = "p14",
                            pos1 = "(950,170)",
                            text = "Remove"
                        },
                        {
                            type = "text",
                            layer = 1,
                            style = "routeEditTableDataRight",
                            font = "p24",
                            pos1 = "(545, 200)",
                            text = "$num(path{editRoute/points/[#]:index}:init{0}:format{%0.f})",
                            visible = "$bool(path{editRoute/points/[#]:visible}:init{false})",
                            replicate = {
                                y_count = 10,
                                y_step = 30
                            }
                        },
                        {
                            type = "text",
                            layer = 1,
                            style = "routeEditTableData",
                            font = "p24",
                            pos1 = "(570, 200)",
                            text = "$str(path{editRoute/points/[#]:pointName}:init{})",
                            visible = "$bool(path{editRoute/points/[#]:visible}:init{false})",
                            mouse = {
                                click = {
                                    command =
                                    "$str(path{editRoute/points/[#]:position}:init{}:format{set-waypoint -notify %s})"
                                },
                                inside = {
                                    set_style = "routeEditHover"
                                }
                            },
                            replicate = {
                                y_count = 10,
                                y_step = 30
                            }
                        },
                        {
                            type = "image",
                            layer = 2,
                            pos1 = "(720,180)",
                            dimensions = "(20,20)",
                            sub = "(0,180)",
                            subDimensions = "(20,20)",
                            style = "icon",
                            url = "assets.prod.novaquark.com/94617/4158c26e-9db3-4a28-9468-b84207e44eec.png",
                            visible = "$bool(path{editRoute/points/[#]:gate}:init{false})",
                            mouse = {
                                click = {
                                    command =
                                    "$num(path{editRoute/points/[#]:index}:init{0}:format{route-set-pos-option -ix %d -toggleGate})"
                                },
                                inside = {
                                    set_style = "routeEditHover"
                                }
                            },
                            replicate = {
                                y_count = 10,
                                y_step = 30
                            }
                        },
                        {
                            type = "image",
                            layer = 2,
                            pos1 = "(720,180)",
                            dimensions = "(20,20)",
                            sub = "(0,160)",
                            subDimensions = "(20,20)",
                            style = "icon",
                            url = "assets.prod.novaquark.com/94617/4158c26e-9db3-4a28-9468-b84207e44eec.png",
                            visible = "$bool(path{editRoute/points/[#]:notGate}:init{false})",
                            mouse = {
                                click = {
                                    command =
                                    "$num(path{editRoute/points/[#]:index}:init{0}:format{route-set-pos-option -ix %d -toggleGate})"
                                },
                                inside = {
                                    set_style = "routeEditHover"
                                }
                            },
                            replicate = {
                                y_count = 10,
                                y_step = 30
                            }
                        },
                        {
                            type = "image",
                            layer = 2,
                            pos1 = "(770,180)",
                            dimensions = "(20,20)",
                            sub = "(0,180)",
                            subDimensions = "(20,20)",
                            style = "icon",
                            url = "assets.prod.novaquark.com/94617/4158c26e-9db3-4a28-9468-b84207e44eec.png",
                            visible = "$bool(path{editRoute/points/[#]:skippable}:init{false})",
                            mouse = {
                                click = {
                                    command =
                                    "$num(path{editRoute/points/[#]:index}:init{0}:format{route-set-pos-option -ix %d -toggleSkippable})"
                                },
                                inside = {
                                    set_style = "routeEditHover"
                                }
                            },
                            replicate = {
                                y_count = 10,
                                y_step = 30
                            }
                        },
                        {
                            type = "image",
                            layer = 2,
                            pos1 = "(770,180)",
                            dimensions = "(20,20)",
                            sub = "(0,160)",
                            subDimensions = "(20,20)",
                            style = "icon",
                            url = "assets.prod.novaquark.com/94617/4158c26e-9db3-4a28-9468-b84207e44eec.png",
                            visible = "$bool(path{editRoute/points/[#]:notSkippable}:init{false})",
                            mouse = {
                                click = {
                                    command =
                                    "$num(path{editRoute/points/[#]:index}:init{0}:format{route-set-pos-option -ix %d -toggleSkippable})"
                                },
                                inside = {
                                    set_style = "routeEditHover"
                                }
                            },
                            replicate = {
                                y_count = 10,
                                y_step = 30
                            }
                        },
                        {
                            type = "image",
                            layer = 2,
                            pos1 = "(820,180)",
                            dimensions = "(20,20)",
                            sub = "(0,180)",
                            subDimensions = "(20,20)",
                            style = "icon",
                            url = "assets.prod.novaquark.com/94617/4158c26e-9db3-4a28-9468-b84207e44eec.png",
                            visible = "$bool(path{editRoute/points/[#]:selectable}:init{false})",
                            mouse = {
                                click = {
                                    command =
                                    "$num(path{editRoute/points/[#]:index}:init{0}:format{route-set-pos-option -ix %d -toggleSelectable})"
                                },
                                inside = {
                                    set_style = "routeEditHover"
                                }
                            },
                            replicate = {
                                y_count = 10,
                                y_step = 30
                            }
                        },
                        {
                            type = "image",
                            layer = 2,
                            pos1 = "(820,180)",
                            dimensions = "(20,20)",
                            sub = "(0,160)",
                            subDimensions = "(20,20)",
                            style = "icon",
                            url = "assets.prod.novaquark.com/94617/4158c26e-9db3-4a28-9468-b84207e44eec.png",
                            visible = "$bool(path{editRoute/points/[#]:notSelectable}:init{false})",
                            mouse = {
                                click = {
                                    command =
                                    "$num(path{editRoute/points/[#]:index}:init{0}:format{route-set-pos-option -ix %d -toggleSelectable})"
                                },
                                inside = {
                                    set_style = "routeEditHover"
                                }
                            },
                            replicate = {
                                y_count = 10,
                                y_step = 30
                            }
                        },
                        {
                            type = "image",
                            layer = 2,
                            pos1 = "(870,180)",
                            dimensions = "(20,20)",
                            sub = "(0,320)", -- Up
                            subDimensions = "(20,20)",
                            style = "icon",
                            url = "assets.prod.novaquark.com/94617/4158c26e-9db3-4a28-9468-b84207e44eec.png",
                            visible = "$bool(path{editRoute/points/[#]:visible}:init{false})",
                            mouse = {
                                click = {
                                    command = "$num(path{editRoute/points/[#]:index}:init{0}:format{route-move-pos-back %0.f})"
                                },
                                inside = {
                                    set_style = "routeEditHover"
                                }
                            },
                            replicate = {
                                y_count = 10,
                                y_step = 30
                            }
                        },
                        {
                            type = "image",
                            layer = 2,
                            pos1 = "(900,180)",
                            dimensions = "(20,20)",
                            sub = "(0,300)", -- Down
                            subDimensions = "(20,20)",
                            style = "icon",
                            url = "assets.prod.novaquark.com/94617/4158c26e-9db3-4a28-9468-b84207e44eec.png",
                            visible = "$bool(path{editRoute/points/[#]:visible}:init{false})",
                            mouse = {
                                click = {
                                    command =
                                    "$num(path{editRoute/points/[#]:index}:init{0}:format{route-move-pos-forward %0.f})"
                                },
                                inside = {
                                    set_style = "routeEditHover"
                                }
                            },
                            replicate = {
                                y_count = 10,
                                y_step = 30
                            }
                        },
                        {
                            type = "text",
                            layer = 1,
                            style = "routeEditTableData",
                            font = "p24",
                            pos1 = "(950, 200)",
                            text = "<<",
                            visible = "$bool(path{editRoute/points/[#]:visible}:init{false})",
                            mouse = {
                                click = {
                                    command = "$num(path{editRoute/points/[#]:index}:init{0}:format{route-delete-pos %0.f})"
                                },
                                inside = {
                                    set_style = "routeEditHoverRed"
                                }
                            },
                            replicate = {
                                y_count = 10,
                                y_step = 30
                            }
                        },

                        {
                            type = "text",
                            layer = 1,
                            style = "routeEditTableData",
                            font = "p24",
                            text = "$num(path{editRoute:currentPage}:init{1}:format{< %0.0f})",
                            pos1 = "(530,520)",
                            mouse = {
                                click = {
                                    command = "#re-prev-point-page"
                                },
                                inside = {
                                    set_style = "routeEditHover"
                                }
                            }
                        },
                        {
                            type = "text",
                            layer = 1,
                            style = "routeEditTableDataRight",
                            font = "p24",
                            text = "$num(path{editRoute:pageCount}:init{1}:format{/ %0.0f >})",
                            pos1 = "(630,520)",
                            mouse = {
                                click = {
                                    command = "#re-next-point-page"
                                },
                                inside = {
                                    set_style = "routeEditHoverRight"
                                }
                            }
                        },
                        {
                            type = "image",
                            layer = 2,
                            pos1 = "(605,540)",
                            dimensions = "(20,20)",
                            sub = "(0,1040)",
                            subDimensions = "(20,20)",
                            style = "icon",
                            url = "assets.prod.novaquark.com/94617/4158c26e-9db3-4a28-9468-b84207e44eec.png",
                            mouse = {
                                click = {
                                    command = "route-add-current-pos"
                                },
                                inside = {
                                    set_style = "routeEditHover"
                                }
                            }
                        },
                        {
                            type = "text",
                            layer = 1,
                            style = "routeEditTableData",
                            font = "p24",
                            pos1 = "(630, 560)",
                            text = "Add current",
                            visible = true,
                            mouse = {
                                click = {
                                    command = "route-add-current-pos"
                                },
                                inside = {
                                    set_style = "routeEditHover"
                                }
                            }
                        },
                        {
                            type = "image",
                            layer = 2,
                            pos1 = "(765,540)",
                            dimensions = "(20,20)",
                            sub = "(0,1060)",
                            subDimensions = "(20,20)",
                            style = "icon",
                            url = "assets.prod.novaquark.com/94617/4158c26e-9db3-4a28-9468-b84207e44eec.png",
                            mouse = {
                                click = {
                                    command = "route-add-current-pos -lockdir"
                                },
                                inside = {
                                    set_style = "routeEditHover"
                                }
                            }
                        },
                        {
                            type = "text",
                            layer = 1,
                            style = "routeEditTableData",
                            font = "p24",
                            pos1 = "(790, 560)",
                            text = "Add + facing",
                            visible = true,
                            mouse = {
                                click = {
                                    command = "route-add-current-pos -lockdir"
                                },
                                inside = {
                                    set_style = "routeEditHover"
                                }
                            }
                        },
                        {
                            type = "text",
                            layer = 1,
                            font = "p24",
                            style = "routeEditTableData",
                            pos1 = "(630,600)",
                            text = "X Discard",
                            mouse = {
                                click = {
                                    command = "route-discard"
                                },
                                inside = {
                                    set_style = "routeEditHoverRed"
                                }
                            }
                        },
                        {
                            type = "image",
                            layer = 2,
                            pos1 = "(755,580)",
                            dimensions = "(20,20)",
                            sub = "(0,100)",
                            subDimensions = "(20,20)",
                            style = "icon",
                            url = "assets.prod.novaquark.com/94617/4158c26e-9db3-4a28-9468-b84207e44eec.png",
                            mouse = {
                                click = {
                                    command = "route-save"
                                },
                                inside = {
                                    set_style = "routeEditHover"
                                }
                            }
                        },
                        {
                            type = "text",
                            layer = 1,
                            font = "p24",
                            style = "routeEditTableData",
                            pos1 = "(780,600)",
                            text = "Save",
                            mouse = {
                                click = {
                                    command = "route-save"
                                },
                                inside = {
                                    set_style = "routeEditHover"
                                }
                            }
                        },
                        {
                            type = "image",
                            layer = 2,
                            pos1 = "(935,580)",
                            dimensions = "(20,20)",
                            sub = "(0,480)",
                            subDimensions = "(20,20)",
                            style = "icon",
                            url = "assets.prod.novaquark.com/94617/4158c26e-9db3-4a28-9468-b84207e44eec.png",
                            mouse = {
                                click = {
                                    command = "activatepage{status,routeSelection}"
                                },
                                inside = {
                                    set_style = "routeEditHover"
                                }
                            }
                        },
                        {
                            type = "text",
                            layer = 1,
                            font = "p24",
                            style = "routeEditTableData",
                            pos1 = "(960,600)",
                            text = "Exit",
                            mouse = {
                                click = {
                                    command = "activatepage{status,routeSelection}"
                                },
                                inside = {
                                    set_style = "routeEditHover"
                                }
                            }
                        }
                    }
                },
                details = {
                    components = {
                        {
                            type = "box",
                            layer = 1,
                            style = "bkgDark",
                            pos1 = "(0,0)",
                            pos2 = "(1024,613)"
                        },
                        {
                            type = "text",
                            pos1 = "(10, 25)",
                            text = "Version: 850e7fe / 20231223 22:22",
                            layer = 1,
                            font = "p24",
                            style = "routeEditTableData"
                        },
                        {
                            type = "text",
                            layer = 1,
                            style = "routeEditTableData",
                            font = "p24",
                            text = "$str(path{:floor}:format{Floor detection: %s}:init{0})",
                            pos1 = "(10,50)"
                        },
                        {
                            type = "image",
                            layer = 2,
                            pos1 = "(935,580)",
                            dimensions = "(20,20)",
                            sub = "(0,480)",
                            subDimensions = "(20,20)",
                            style = "icon",
                            url = "assets.prod.novaquark.com/94617/4158c26e-9db3-4a28-9468-b84207e44eec.png",
                            mouse = {
                                click = {
                                    command = "activatepage{status,routeSelection}"
                                },
                                inside = {
                                    set_style = "routeEditHover"
                                }
                            }
                        },
                        {
                            type = "text",
                            layer = 1,
                            font = "p24",
                            style = "routeEditTableData",
                            pos1 = "(960,600)",
                            text = "Exit",
                            mouse = {
                                click = {
                                    command = "activatepage{status,routeSelection}"
                                },
                                inside = {
                                    set_style = "routeEditHover"
                                }
                            }
                        }
                    }
                }
            }
        }


        return layout


        end)

        package.preload['YFS:../e/render/e/stream/e/serializer.lua']=(function()

        local concat = table.concat

        local sFormat=string.format


        local function internalSerialize(table, tC, t)
            t[tC] = "{"
            tC = tC + 1
            if #table == 0 then
                local hasValue = false
                for key, value in pairs(table) do
                    hasValue = true
                    local keyType = type(key)
                    if keyType == "string" then
                        t[tC] = sFormat("[%q]=", key)
                    elseif keyType == "number" then
                        t[tC] = "[" .. key .. "]="
                    elseif keyType == "boolean" then
                        t[tC] = "[" .. tostring(key) .. "]="
                    else
                        t[tC] = "notsupported="
                    end
                    tC = tC + 1

                    local check = type(value)
                    if check == "table" then
                        tC = internalSerialize(value, tC, t)
                    elseif check == "string" then
                        t[tC] = sFormat("%q", value)
                    elseif check == "number" then
                        t[tC] = value
                    elseif check == "boolean" then
                        t[tC] = tostring(value)
                    else
                        t[tC] = '"Not Supported"'
                    end
                    t[tC + 1] = ","
                    tC = tC + 2
                end
                if hasValue then
                    tC = tC - 1
                end
            else
                for i = 1, #table do
                    local value = table[i]
                    local check = type(value)
                    if check == "table" then
                        tC = internalSerialize(value, tC, t)
                    elseif check == "string" then
                        t[tC] = sFormat("%q", value)
                    elseif check == "number" then
                        t[tC] = value
                    elseif check == "boolean" then
                        t[tC] = tostring(value)
                    else
                        t[tC] = '"Not Supported"'
                    end
                    t[tC + 1] = ","
                    tC = tC + 2
                end
                tC = tC - 1
            end
            t[tC] = "}"
            return tC
        end


        function serialize(value)
            local t = {}
            local check = type(value)

            if check == "table" then
                internalSerialize(value, 1, t)
            elseif check == "string" then
                return sFormat("%q", value)
            elseif check == "number" then
                return value
            elseif check == "boolean" then
                return tostring(value)
            else
                return '"Not Supported"'
            end

            return concat(t)
        end


        function deserialize(s)
            return load("return " .. s)()
        end



        end)

        package.preload['YFS:../e/render/e/stream/src/Stream.lua']=(function()

        local _ = require('YFS:../e/render/e/stream/e/serializer.lua')

        local byte = string.byte

        local concat = table.concat


        ---@module "interface.Device"


        ---@alias CommQueue { queue:string[], waitingForReply:boolean, seq:integer }

        ---@alias ScreenLink {setScriptInput:fun(string), clearScriptOutput:fun(), getScriptOutput:fun():string}

        ---@alias Renderer {setOutput:fun(string), getInput:fun():string}


        ---@class Stream

        ---@field New fun(device:Device, parent:DataReceiver, timeout:number):Stream

        ---@field Tick fun()

        ---@field Write fun(data:table|string)

        ---@field WaitingToSend fun():boolean


        --[[
            Data format:
            #new_message|checksum|remaining_chunks|seq|cmd|payload

            Where:
            - new_message is 0 or 1 where 0 means continuation of a message, and 1 means a new message.
            - checksum is HEX representation of the XOR checksum of the data
            - remaining_chunks is an integer indicating how many chunks remains to complete the message. 0 means the last chuck.
            - seq is a single digit seqence number, used to ensure we don't read the same data twice. It wraps around at 9.
            - cmd is a two digit integer indicating what to do with the data
            - payload is the actual payload, if any
        ]]

        local HEADER_SIZE = 1 -- #
            + 1               -- new_message
            + 1               -- |
            + 2               -- checksum
            + 1               -- |
            + 3               -- remaining_chucks
            + 1               -- |
            + 1               -- seq
            + 1               -- |
            + 2               -- cmd
            + 1               -- |

        local BLOCK_HEADER_FORMAT = "#%0.1d|%0.2x|%0.3d|%0.1d|%0.2d|%s"

        local BLOCK_HEADER_PATTERN = "^#(%d)|(%x%x)|(%d+)|(%d)|(%d+)|(.*)$"


        ---@enum StreamCommand

        local Command = {
            Reset = 0,
            Poll = 1,
            Ack = 2,
            Data = 3,
        }


        ---Represents a stream between two entities.

        local Stream = {}

        Stream.__index = Stream


        ---Create a new Stream

        ---@param device Device

        ---@param parent DataReceiver

        ---@param timeout number The amount of time to wait for a reply before considering the connection broken.

        ---@return Stream

        function Stream.New(device, parent, timeout)
            local s = {}
            local DATA_SIZE = device.BlockSize() - HEADER_SIZE -- Game allows only a certain amount of bytes in buffers

            ---@diagnostic disable-next-line: undefined-global
            local getTime = getTime or system.getUtcTime

            device.Clear()

            local input = { queue = {}, waitingForReply = false, seq = -1, payloadChecksum = 0 }
            local output = { queue = {}, waitingForReply = false, seq = 0 }
            local lastReceived = getTime()

            ---@param data string
            ---@return string # Two character HEX value
            local function xor(data)
                local x = 0
                for i = 1, data:len() do
                    x = x ~ byte(data, i)
                end

                return x
            end

            ---Assembles the package
            ---@param payload string
            local function assemblePackage(payload)
                input.queue[#input.queue + 1] = payload
            end

            ---Completes a transmission
            ---@param remaining number
            local function completeTransmission(remaining)
                if remaining == 0 then
                    local complete = concat(input.queue)

                    if xor(complete) == input.payloadChecksum then
                        local deserialized = deserialize(complete)
                        parent.OnData(deserialized)
                    end

                    -- Last part, begin new data
                    input.queue = {}
                end
            end

            local function sameInput(seq)
                if seq == input.seq then
                    return true
                end

                input.seq = seq
                return false
            end

            ---Creates a block
            ---@param newMessage boolean
            ---@param blockCount integer
            ---@param commQueue CommQueue
            ---@param cmd StreamCommand
            ---@param payload string?
            ---@return string
            local function createBlock(newMessage, blockCount, commQueue, cmd, payload, checksum)
                checksum = checksum or 0

                commQueue.seq = (commQueue.seq + 1)
                if commQueue.seq > 9 then
                    commQueue.seq = 0
                end

                payload = payload or ""
                local b = string.format(BLOCK_HEADER_FORMAT, (newMessage and 1 or 0), checksum, blockCount, commQueue.seq, cmd,
                    payload)

                return b
            end

            ---Reads incoming data
            ---@return boolean #New message
            ---@return StreamCommand|nil #Command
            ---@return number #Packet chunks remaning
            ---@return string #Payload
            ---@return integer #Checksum
            local function readData()
                local r = device.Read()

                local new, checksum, remaining, seq, cmd, payload = r:match(BLOCK_HEADER_PATTERN)

                payload = payload or ""
                local validPacket = remaining and cmd and new and checksum
                if validPacket then
                    cmd = tonumber(cmd)
                    new = tonumber(new)
                    remaining = tonumber(remaining)
                    checksum = tonumber("0x" .. checksum)
                    validPacket = cmd and remaining and new and checksum
                end

                if not validPacket then
                    return true, nil, 0, "", 0
                end

                -- Since we can't clear the input when running in RenderScript, we have to rely on the sequence number to prevent duplicate data.
                if sameInput(seq) then
                    return true, nil, 0, "", 0
                end

                return new == 1, cmd, remaining, payload, checksum
            end

            local function resetQueues()
                output.queue = {}
                output.waitingForReply = false
                input.queue = {}
                input.waitingForReply = false
            end

            ---Call this function once every frame (i.e. in Update)
            function s.Tick()
                local new, cmd, remaining, payload, checksum = readData()

                -- Did we get any input?
                if cmd then
                    if new then
                        input.payloadChecksum = checksum
                    end

                    parent.OnTimeout(false, s)
                    lastReceived = getTime()

                    if new then
                        input.queue = {}
                    end

                    if device.IsController() then
                        if cmd == Command.Data then
                            assemblePackage(payload)
                            completeTransmission(remaining)
                        end
                        -- No need to handle ACK, it's just a trigger to move on.
                        output.waitingForReply = false
                    else
                        local sendAck = false

                        if cmd == Command.Poll or cmd == Command.Data then
                            if cmd == Command.Data then
                                assemblePackage(payload)
                                completeTransmission(remaining)
                            end

                            -- Send either ACK or actual data as a reply
                            if #output.queue > 0 then
                                device.Send(table.remove(output.queue, 1))
                            else
                                sendAck = true
                            end
                        elseif cmd == Command.Reset then
                            resetQueues()
                            sendAck = true
                        end

                        if sendAck then
                            device.Send(createBlock(true, 0, output, Command.Ack))
                        end
                    end
                end

                if getTime() - lastReceived >= timeout then
                    parent.OnTimeout(true, s)
                    input.payloadChecksum = 0
                    lastReceived = getTime() -- Reset to trigger again
                    resetQueues()
                end

                if device.IsController() and not output.waitingForReply then
                    if #output.queue == 0 then
                        device.Send(createBlock(true, 0, output, Command.Poll))
                    else
                        device.Send(table.remove(output.queue, 1))
                    end
                    output.waitingForReply = true
                end
            end

            ---Write the data to the stream
            ---@param dataToSend table|string
            function s.Write(dataToSend)
                local data = serialize(dataToSend) ---@type string
                local checksum = xor(data)
                local blockCount = math.ceil(data:len() / DATA_SIZE)

                if blockCount > 999 then
                    error("Too large data")
                end

                local new = true

                while data:len() > 0 do
                    blockCount = blockCount - 1
                    local part = data:sub(1, DATA_SIZE)
                    data = data:sub(DATA_SIZE + 1)
                    output.queue[#output.queue + 1] = createBlock(new, blockCount, output, Command.Data, part, checksum)
                    new = false
                    checksum = 0
                end
            end

            ---Returns true if there is data waiting to be sent. Good for holding off additional write.
            ---@return boolean
            function s.WaitingToSend() return #output.queue > 0 end

            setmetatable(s, Stream)

            parent.RegisterStream(s)

            return s
        end


        return Stream


        end)

        package.preload['YFS:../e/render/e/stream/src/device/ScreenDevice.lua']=(function()

        ---@module "Device"


        ---@class ScreenDevice

        ---@field Send fun(data:string)

        ---@field Read fun():string

        ---@field Clear fun()

        ---@field IsController fun():boolean

        ---@field BlockSize fun():integer

        ---@field New fun(screenLink:table):Device


        local ScreenDevice = {}

        ScreenDevice.__index = ScreenDevice


        ---Creates a new screen interface

        ---@param screenLink {getScriptOutput:stringf, clearScriptOutput:voidf, setScriptInput:fun(string)}

        ---@return Device

        function ScreenDevice.New(screenLink)
            local s = {}

            ---@param data string
            function s.Send(data)
                screenLink.setScriptInput(data)
            end

            ---@return string
            function s.Read()
                local data = screenLink.getScriptOutput()
                screenLink.clearScriptOutput()
                return data
            end

            function s.Clear()
                screenLink.clearScriptOutput()
            end

            ---@return boolean
            function s.IsController()
                -- We're running on the controller when we have a link to a screen
                return true
            end

            function s.BlockSize()
                return 1024
            end

            return setmetatable(s, ScreenDevice)
        end


        return ScreenDevice


        end)

        package.preload['YFS:../e/lib/src/util/MassFormat.lua']=(function()

        local oneTon = 1000

        local kiloTon = 1000 * 1000


        ---@param kg number

        function MassFormat(kg)
            if kg >= kiloTon then
                return { value = kg / kiloTon, unit = "kt" }
            elseif kg >= oneTon then
                return { value = kg / oneTon, unit = "t" }
            else
                return { value = kg, unit = "kg" }
            end
        end


        return MassFormat


        end)

        package.preload['YFS:controller/ScreenController.lua']=(function()

        require('YFS:../e/lib/src/abstraction/Vehicle.lua')

        require('YFS:GlobalTypes.lua')

        local s                                                                                         = require('YFS:Singletons.lua')

        local log, pub, su, commandLine, calc                                                           = s.log, s.pub, s
            .strUtil, s.commandLine, s.calc

        local ValueTree, layout, Stream, ScreenDevice, pagination, distanceFormat, massFormat, max, min =
            require('YFS:../e/lib/src/util/ValueTree.lua'), require('YFS:screen/layout_out.lua'), require('YFS:../e/render/e/stream/src/Stream.lua'), require('YFS:../e/render/e/stream/src/device/ScreenDevice.lua'),
            require('YFS:../e/lib/src/util/Pagination.lua'), require('YFS:../e/lib/src/util/DistanceFormat.lua'), require('YFS:../e/lib/src/util/MassFormat.lua'), math.max, math.min

        ---@class ScreenController

        ---@field ActivateFloorMode fun(string):boolean


        local ScreenController                                                                          = {}

        ScreenController.__index                                                                        = ScreenController


        ---@param flightCore FlightCore

        ---@param settings Settings

        ---@return ScreenController

        function ScreenController.New(flightCore, settings)
            local s = {}
            local layoutSent = false

            local rc = flightCore.GetRouteController()
            local dataToScreen = ValueTree.New()
            local routePage = 1
            local routesPerPage = 6

            local waypointPage = 1
            local waypointsPerPage = 10

            local floorPage = 1
            local floorPointsPerPage = 24

            local stream ---@type Stream -- forward declared

            local routeEditorPrefix = "#re-"
            local routeSelectionPrefix = "#rsel-"
            local floorSelectionPrefix = "#fl-"

            local editRouteIndex = 1
            local editRoutePointsPerPage = 10

            local editPointPage = 1
            pub.RegisterBool("RouteOpenedForEdit", function(_, _)
                editPointPage = 1
            end)

            function s.OnData(data)
                -- Publish data to system
                if data == nil then return end
                local command = data["mouse_click"]
                if command ~= nil then
                    if su.StartsWith(command, routeEditorPrefix) then
                        s.runRouteEditorCommand(su.RemovePrefix(command, routeEditorPrefix))
                    elseif su.StartsWith(command, routeSelectionPrefix) then
                        s.runRouteSelectionCommand(su.RemovePrefix(command, routeSelectionPrefix))
                    elseif su.StartsWith(command, floorSelectionPrefix) then
                        s.runFloorSelectionCommand(su.RemovePrefix(command, floorSelectionPrefix))
                    else
                        commandLine.Exec(command)
                        s.updateFloorData()
                        s.updateEditRouteData()
                        s.sendRoutes()
                    end
                end
            end

            ---@param isTimedOut boolean
            ---@param stream Stream
            function s.OnTimeout(isTimedOut, stream)
                if isTimedOut then
                    layoutSent = false
                elseif not layoutSent then
                    stream.Write({ screen_layout = layout })

                    local floorRoute = settings.String("showFloor")
                    local floorActivated = false

                    if floorRoute ~= "-" then
                        floorActivated = s.ActivateFloorMode(floorRoute)
                        if not floorActivated then
                            log.Error("Could not activate floor mode")
                        end
                    end

                    if not floorActivated then
                        stream.Write({ activate_page = "status,routeSelection" })
                    end

                    s.sendRoutes()
                    layoutSent = true
                end
            end

            function s.RegisterStream(stream)

            end

            ---@param cmd string
            function s.runRouteEditorCommand(cmd)
                if cmd == "previous-route" then
                    editRouteIndex = max(1, editRouteIndex - 1)
                elseif cmd == "next-route" then
                    editRouteIndex = min(#rc.GetRouteNames(), editRouteIndex + 1)
                elseif cmd == "prev-point-page" then
                    local r = rc.CurrentEdit()
                    if r then
                        editPointPage = max(1, editPointPage - 1)
                    end
                elseif cmd == "next-point-page" then
                    local r = rc.CurrentEdit()
                    if r then
                        editPointPage = min(editPointPage + 1, r.GetPageCount(editRoutePointsPerPage))
                    end
                elseif cmd == "prev-wp-page" then
                    waypointPage = max(1, waypointPage - 1)
                elseif cmd == "next-wp-page" then
                    waypointPage = min(waypointPage + 1, rc.GetWaypointPages(waypointsPerPage))
                end

                s.updateEditRouteData()
            end

            ---@param cmd string
            function s.runRouteSelectionCommand(cmd)
                if cmd == "next-route-page" then
                    routePage = min(routePage + 1, rc.GetPageCount(routesPerPage))
                elseif cmd == "prev-route-page" then
                    routePage = max(1, routePage - 1)
                end
                s.sendRoutes()
            end

            ---@param cmd string
            function s.runFloorSelectionCommand(cmd)
                if cmd == "next-floor-page" then
                    floorPage = min(floorPage + 1, pagination.GetPageCount(rc.SelectableFloorPoints(), floorPointsPerPage))
                elseif cmd == "prev-floor-page" then
                    floorPage = max(1, floorPage - 1)
                end
                s.updateFloorData()
            end

            function s.sendRoutes()
                local routeSelection = {
                    routePage = routePage,
                    pageCount = rc.GetPageCount(routesPerPage),
                    routes = {}
                }
                for i, r in ipairs(rc.GetRoutePage(routePage, routesPerPage)) do
                    routeSelection.routes[tostring(i)] = { visible = true, name = r }
                end

                -- Ensure to hide the rest if routes have been removed.
                for i = TableLen(routeSelection.routes) + 1, routesPerPage, 1 do
                    routeSelection.routes[tostring(i)] = { visible = false, name = "" }
                end

                dataToScreen.Set("routeSelection", routeSelection)
            end

            function s.updateEditRouteData()
                local routeNames = rc.GetRouteNames()
                local editRoute = {
                    ix = editRouteIndex,
                    count = #routeNames,
                    currentPage = editPointPage,
                    pageCount = editPointPage,
                    selectRouteName = "",
                    routeName = "",
                    points = {}
                }

                if #routeNames > 0 then
                    editRoute.selectRouteName = routeNames[editRouteIndex]
                end

                local editing = rc.CurrentEdit()
                local pointsShown = 0

                if editing then
                    editRoute.name = rc.CurrentEditName()
                    editRoute.pageCount = editing.GetPageCount(editRoutePointsPerPage)
                    local points = editing.GetPointPage(editPointPage, editRoutePointsPerPage)
                    pointsShown = #points
                    local distances = rc.CalculateDistances(points)

                    for index, p in ipairs(points) do
                        local opt = p.Options()
                        local gate = opt.Get(PointOptions.GATE, false)
                        local skippable = opt.Get(PointOptions.SKIPPABLE, false)
                        local selectable = opt.Get(PointOptions.SELECTABLE, true)

                        local pointInfo = {
                            visible = true,
                            index = index + (editPointPage - 1) * editRoutePointsPerPage,
                            position = p.Pos(),
                            gate = gate,
                            notGate = not gate,
                            skippable = skippable,
                            notSkippable = not skippable,
                            selectable = selectable,
                            notSelectable = not selectable
                        }

                        if p.HasWaypointRef() then
                            pointInfo.pointName = p.WaypointRef()
                        else
                            local d = distanceFormat(distances[index])
                            pointInfo.pointName = string.format("%0.1f%s", d.value, d.unit)
                        end

                        editRoute.points[tostring(index)] = pointInfo
                    end
                else
                    editRoute.name = "-"
                end

                -- Clear old data
                for i = pointsShown + 1, editRoutePointsPerPage, 1 do
                    editRoute.points[tostring(i)] = {
                        visible = false,
                        gate = false,
                        notGate = false,
                        skippable = false,
                        notSkippable = false,
                        selectable = false,
                        notSelectable = false
                    }
                end

                dataToScreen.Set("editRoute", editRoute)

                local availableWaypoints = {
                    currentPage = waypointPage,
                    pageCount = rc.GetWaypointPages(waypointsPerPage),
                    wayPoints = {}
                }

                local waypoints = rc.GetWaypointPage(waypointPage, waypointsPerPage)
                for index, p in ipairs(waypoints) do
                    availableWaypoints.wayPoints[tostring(index)] = {
                        visible = true,
                        name = p.name,
                        pos = p.point.Pos()
                    }
                end

                for i = #waypoints + 1, waypointsPerPage, 1 do
                    availableWaypoints.wayPoints[tostring(i)] = { visible = false }
                end

                dataToScreen.Set("availableWaypoints", availableWaypoints)
            end

            function s.updateFloorData()
                local points = rc.SelectableFloorPoints()

                local floorSelection = {
                    routeName = rc.FloorRouteName(),
                    points = {},
                    currentPage = floorPage,
                    pageCount = pagination.GetPageCount(points, floorPointsPerPage)
                }

                local selectable = pagination.Paginate(points, floorPage, floorPointsPerPage)

                floorSelection.currentPage = floorPage
                for i, p in ipairs(selectable) do
                    floorSelection.points[tostring(i)] = p
                end

                -- Clear any removed points
                for i = #selectable + 1, floorPointsPerPage, 1 do
                    floorSelection.points[tostring(i)] = { visible = false, name = "", index = "0" }
                end

                dataToScreen.Set("floorSelection", floorSelection)
            end

            ---@param routeName string
            ---@return boolean
            function s.ActivateFloorMode(routeName)
                local r = rc.LoadFloorRoute(routeName)
                if r then
                    floorPage = 1
                    s.updateFloorData()
                    stream.Write({ activate_page = "status,floor" })
                end
                return r ~= nil
            end

            local function screenTask()
                local screen = library.getLinkByClass("ScreenUnit")

                if not screen then return end
                log.Info("Screen found")

                local routeTimer = Stopwatch.New()
                routeTimer.Start()

                pub.RegisterTable("FlightData",
                    ---@param _ string
                    ---@param data FlightData
                    function(_, data)
                        dataToScreen.Set("flightData/absSpeed", calc.Mps2Kph(data.absSpeed))
                        local formatted = distanceFormat(data.waypointDist)
                        dataToScreen.Set("nextWp/distance", formatted.value)
                        dataToScreen.Set("nextWp/distanceUnit", formatted.unit)

                        formatted = massFormat(TotalMass())
                        dataToScreen.Set("mass/total", formatted.value)
                        dataToScreen.Set("mass/totalUnit", formatted.unit)
                    end)

                pub.RegisterTable("RouteData",
                    ---@param _ string
                    ---@param data {remaining:RouteRemainingInfo, activeRouteName:string|nil}
                    function(_, data)
                        local formatted = distanceFormat(data.remaining.TotalDistance)
                        dataToScreen.Set("finalWp/distance", formatted.value)
                        dataToScreen.Set("finalWp/distanceUnit", formatted.unit)
                        dataToScreen.Set("route/current/name", data.activeRouteName)
                    end)

                pub.RegisterTable("AdjustmentData",
                    ---@param _ string
                    ---@param data AdjustmentData
                    function(_, data)
                        dataToScreen.Set("deviation/distance",
                            string.format("%0.2f", Vec3.New(data.long, data.lat, data.ver):Len()))
                    end)

                pub.RegisterTable("FloorMonitor",
                    ---@param _ string
                    ---@param value TelemeterResult
                    function(_, value)
                        local floor = string.format("Hit: %s, distance: %0.2f, limit: %0.2f",
                            tostring(value.Hit), value.Distance,
                            settings.Number("autoShutdownFloorDistance"))
                        dataToScreen.Set("floor", floor)
                    end)

                stream = Stream.New(ScreenDevice.New(screen), s, 1)

                while screen do
                    screen.activate()
                    coroutine.yield()
                    stream.Tick()

                    if not stream.WaitingToSend() then
                        if not routeTimer.IsRunning() or routeTimer.Elapsed() > 2 then
                            s.sendRoutes()
                            s.updateEditRouteData()
                            routeTimer.Restart()
                        end

                        -- Get data to send to screen
                        local data = dataToScreen.Pick()
                        -- Send data to screen
                        if data then
                            stream.Write(data)
                        else
                            stream.Write('{"keepalive": ""}')
                        end
                    end
                end
            end

            -- Create a Task to handle communication with the screen
            Task.New("ScreenController", screenTask)
                .Then(function(...)
                    log.Info("No screen connected")
                end).Catch(function(t)
                log.Error(t.Name(), t.Error())
            end)

            return setmetatable(s, ScreenController)
        end


        return ScreenController


        end)

        package.preload['YFS:../e/render/e/stream/src/device/RxTx.lua']=(function()

        ---@alias onReceiveFunc fun(_:table, channel:string, message:string)

        ---@alias EmitterLink {send:fun(channel:string, message:string), setChannelList:fun(table)}

        ---@alias ReceiverLink {setChannelList:fun(channels:channelList), onEvent:fun(_:table, event:string, f:onReceiveFunc)}


        ---@class RxTx

        ---@field Send fun(data:string)

        ---@field Read fun():string

        ---@field Clear fun()

        ---@field SetChannel fun(string)

        ---@field BlockSize integer

        ---@field New fun(emitter:EmitterLink, receiver:ReceiverLink, channel:string, isController:boolean):Device


        ---@alias channelList string[]


        local RxTx = {}

        RxTx.__index = RxTx


        ---Create a transmit/receive interface

        ---@param emitter EmitterLink The emitter link

        ---@param receiver ReceiverLink The receiver link

        ---@param channel string The channel to communicate on

        ---@param isController boolean If true, this device is considered the controller.

        ---@return Device

        function RxTx.New(emitter, receiver, channel, isController)
            local s = {}

            -- Setup channels for two-way communication
            local sendChannel = channel .. (isController and "-ctrl" or "-worker")
            local recChannel = channel .. (isController and "-worker" or "-ctrl")

            local inQueue = {} ---@type string[]

            receiver.setChannelList({ recChannel })

            ---@diagnostic disable-next-line: undefined-field
            receiver:onEvent("onReceived", function(_, chan, message)
                -- Restore quotation marks
                message = message:gsub("&#34;", "\"")
                inQueue[#inQueue + 1] = message
            end)

            ---@param data string
            function s.Send(data)
                -- Can't send quotation marks through the emitter so replace it with HTML code for it.
                data = data:gsub("\"", "&#34;")
                emitter.send(sendChannel, data)
            end

            ---@return string
            function s.Read()
                return table.remove(inQueue, 1) or ""
            end

            function s.Clear()
                -- NOP
            end

            ---@return boolean
            function s.IsController()
                return isController
            end

            function s.BlockSize()
                return 512
            end

            return setmetatable(s, RxTx)
        end


        return RxTx


        end)

        package.preload['YFS:controller/Communication.lua']=(function()

        ---@module "Settings"

        local si, RxTx, Stream = require('YFS:Singletons.lua'), require('YFS:../e/render/e/stream/src/device/RxTx.lua'), require('YFS:../e/render/e/stream/src/Stream.lua')

        local log, pub, rx, tx = si.log, si.pub, library.getLinkByClass("ReceiverUnit"), library.getLinkByClass("EmitterUnit")



        ---@class Communication

        ---@field OnData fun(table)

        ---@field OnTimeout fun(isTimedOut:boolean, stream:Stream)

        ---@field RegisterStream fun(stream:Stream)


        local Communication = {}

        Communication.__index = Communication


        ---@param channel string

        ---@return Communication

        function Communication.New(channel)
            local s = {}
            local stream ---@type Stream
            local timedOut = true
            local outstanding = {} ---@type table<string, table|string>

            local function getOutstanding()
                for k, v in pairs(outstanding) do
                    return k, v
                end

                return nil, nil
            end

            pub.RegisterTable("SendData", function(_, value)
                if value.topic and value.data then
                    outstanding[value.topic] = value
                else
                    log.Error("Got data to send without topic or value")
                end
            end)

            ---@param incomingData {topic:string, data:table|string}
            function s.OnData(incomingData)
                local topic = incomingData.topic
                local data = incomingData.data

                if not (topic and data) then
                    log.Error("Received data without topic or value")
                    return
                end

                outstanding[topic] = nil

                pub.Publish("RecData-" .. topic, data)
            end

            function s.OnTimeout(isTimedOut, stream)
                if timedOut and not isTimedOut then
                    log.Info("Communication established")
                elseif not timedOut and isTimedOut then
                    log.Info("Communication lost")
                end
                timedOut = isTimedOut
            end

            function s.RegisterStream(stream)
                -- NOP
            end

            setmetatable(s, Communication)

            if not (rx and tx) then
                log.Error("Emitter or receiver not linked")
            else
                stream = Stream.New(RxTx.New(tx, rx, channel, true), s, 1)

                system:onEvent("onUpdate", function()
                    -- Stop sending if we're all done
                    local topic, data = getOutstanding()
                    if topic and data then
                        if not stream.WaitingToSend() then
                            stream.Write(data)
                        end

                        stream.Tick()
                    end
                end)
                log.Info("Communication enabled")
            end

            return s
        end


        return Communication


        end)

        package.preload['YFS:../e/STL/src/Template.lua']=(function()

        --[[ Wolfe Labs Smart Template Library (STL)

        https://github.com/wolfe-labs/SmartTemplateLibrary

        (C) 2022 - Wolfe Labs ]]


        --- Helper function that generates a clean print statement of a certain string

        ---@param str string The string we need to show

        ---@return string

        local function mkPrint(str)

        return 'print(\'' .. str:gsub('\'', '\\\''):gsub('\n', '\\n') .. '\')'

        end


        --- Helper function that merges tables

        ---@vararg table

        ---@return table

        local function tMerge(...)

        local tables = {...}

        local result = {}

        for _, t in pairs(tables) do
            for k, v in pairs(t) do
            result[k] = v
            end
        end

        return result

        end


        --- Retrieves a certain line from a string

        ---@param str string The source string

        ---@param ln number The line number

        ---@return string|nil

        local function getLine(str, ln)

        local _ = 0

        for s in str:gmatch("([^\n]*)\n?") do
            _ = _ + 1
            if _ == ln then
            return s
            end
        end

        return nil

        end


        --- Trims a string

        ---@param str string The string being trimmed

        ---@return string

        local function trim(str)

        return str:gsub("^%s*(.-)%s*$", "%1")

        end


        ---@class Template

        local Template = {

        --- Globals available for every template by default

        globals = {
            math = math,
            table = table,
            string = string,
            ipairs = ipairs,
            pairs = pairs,
        }

        }


        -- Makes our template directly callable

        function Template.__call(self, ...)

        return Template.render(self, ({...})[1])

        end


        --- Renders our template

        ---@param vars table The variables to be used when rendering the template

        ---@return string

        function Template:render(vars)

        -- Safety check, vars MUST be a table or nil

        if type(vars or {}) ~= 'table' then
            error('Template parameters must be a table, got ' .. type(vars))
        end


        --- This is our return buffer

        local _ = {}


        -- Creates our environment

        local env = tMerge(Template.globals, self.globals or {}, vars or {}, {
            print = function (str) table.insert(_, tostring(str or '')) end,
        })


        -- Invokes our template

        self.callable(env)


        -- General trimming

        local result = table.concat(_, ''):gsub('%s+', ' ')


        -- Trims result

        result = result:sub(result:find('[^%s]') or 1):gsub('%s*$', '')


        -- Done

        return result

        end


        --- Creates a new template

        ---@param source string The code for your template

        ---@param globals table|nil Global variables to be used on on the template

        ---@param buildErrorHandler function|nil A function to handle build errors, if none is found throws an error

        ---@return Template

        function Template.new(source, globals, buildErrorHandler)

        -- Creates our instance

        local self = {
            source = source,
            globals = globals,
        }


        -- Yield function (mostly for games who limit executions per frame)

        local yield = (coroutine and coroutine.isyieldable() and coroutine.yield) or function () end


        -- Parses direct printing of variables, we'll convert a {{var}} into {% print(var) %}

        source = source:gsub('{{(.-)}}', '{%% print(%1) %%}')


        -- Ensures {% if %} ... {% else %} ... {% end %} stays on same line

        source = source:gsub('\n%s*{%%', '{%%')

        source = source:gsub('%%}\n', '%%}')


        --- This variable stores all our Lua "pieces"

        local tPieces = {}


        -- Parses actual Lua inside {% lua %} tags

        while #source > 0 do
            --- The start index of Lua tag
            local iLuaStart = source:find('{%%')

            --- The end index of Lua tag
            local iLuaEnd = source:find('%%}')

            -- Checks if we have a match
            if iLuaStart then
            -- Errors when not closing a tag
            if not iLuaEnd then
                error('Template error, missing Lua closing tag near: ' .. source:sub(0, 16))
            end

            --- The current text before Lua tag
            local currentText = source:sub(1, iLuaStart - 1)
            if #currentText then
                table.insert(tPieces, mkPrint(currentText))
            end

            --- Our Lua tag content
            local luaTagContent = source:sub(iLuaStart, iLuaEnd + 1):match('{%%(.-)%%}') or ''
            table.insert(tPieces, luaTagContent)

            -- Removes parsed content
            source = source:sub(iLuaEnd + 2)
            else
            -- Adds remaining Lua as a single print statement
            table.insert(tPieces, mkPrint(source))

            -- Marks content as parsed
            source = ''
            end

            -- Yields loading
            yield()
        end


        -- Builds the Lua function

        self.code = table.concat(tPieces, '\n')


        -- Builds our function and caches it, this is our template now

        local lua = string.format('return function (_) _ENV = _; _ = _ENV[_]\n%s\nend', self.code)

        local _, err = load(lua, nil, 't', {})

        if _ and not err then
            _ = _()
        end


        -- Checks for any errors

        if err then
            local _, ln, msg = err:match('^(.-):(%d+):(.+)')
            local nearSrc = getLine(self.source, ln - 1)
            local nearLua = getLine(self.code, ln - 1)

            local ex = {
            raw = err,
            line = ln - 1,
            near = trim(nearSrc or 'N/A'),
            nearLua = trim(nearLua or 'N/A'),
            message = trim(msg),
            }

            if buildErrorHandler then
            buildErrorHandler(self, ex)
            else
            error(('Failed compiling template!\nError: %s\nLine: %d\nNear: %s\nCode: %s'):format(ex.message, ex.line, ex.near, ex.nearLua))
            end

            -- Retuns an invalid instance
            return nil
        else
            -- If everything passed, assigns our callable to our compiled function
            self.callable = _
        end


        -- Initializes our instance

        return setmetatable(self, Template)

        end


        -- By default, returns the constructor of our class

        return Template.new

        end)

        package.preload['YFS:hud/Hud.lua']=(function()

        require('YFS:GlobalTypes.lua')

        local si                              = require('YFS:Singletons.lua')

        local log, pub, input, calc, Template = si.log, si.pub, si.input, si.calc, require('YFS:../e/STL/src/Template.lua')

        local hudTemplate                     = '<!DOCTYPE html>\n<html>\n\n<head>\n    <style>\n        .logo {\n            position: fixed;\n            top: 20px;\n            left: 20px;\n        }\n\n        .ecuColor {\n            color: rgb(255, 0, 0);\n        }\n\n        .throttleColor {\n            color: white;\n        }\n\n        .throttle {\n            position: fixed;\n            top: 20px;\n            left: 60px;\n            font: 18px Montserrat;\n            text-shadow: 2px 2px black;\n        }\n\n        .progress-container {\n            width: 335px;\n            text-align: center;\n        }\n\n        .progress-border {\n            position: relative;\n            height: 26px;\n            margin: 0px;\n            border: 2px solid white;\n            color: #fff;\n            background-color: black;\n            border-radius: 10px;\n            overflow: hidden;\n        }\n\n        .progress-bar {\n            position: relative;\n            height: 26px;\n            color: #fff;\n        }\n\n        .progress-label {\n            position: absolute;\n            top: 50%;\n            transform: translateY(-50%);\n            width: 100%;\n            font: 12px Montserrat;\n            color: white;\n            text-shadow: inherit;\n        }\n    </style>\n</head>\n\n<body>\n    <div class="logo">\n        <svg width="24" height="28" viewBox="0 0 24 28" xmlns="http://www.w3.org/2000/svg">\n            <g>\n                <path d="M14 12L24 0L12 10L0 0L10 12L12 28L14 12Z" fill="white" />\n            </g>\n        </svg>\n    </div>\n    {% if isECU then %}\n    <div class="throttle ecuColor">ECU Active</div>\n    {% else %}\n    <div class="throttle throttleColor">{{throttle}}</div>\n    {% end %}\n    <div class="progress-container">\n        {%\n        for _, t in ipairs({ { t = "atmo", c = "#022966ff"}, { t = "space", c = "#616102ff"}, { t = "rocket", c =\n        "#02A9BF"}\n        })\n        do\n\n        local color = t.c\n        local byType = fuelByType[t.t]\n\n        if byType then\n        local topMargin = 15\n        for _, curr in ipairs(byType) do\n        local percent = round(curr.percent, 1)\n        %}\n        <div class="progress-border" style="margin-top: {{topMargin - 2}}px;">\n            <div class="progress-bar" style="width: {{percent}}%; background-color: {{t.c}};">\n            </div>\n            <div class="progress-label">\n                <span style="float: left; margin-left: 10px;">{{curr.name}}</span>\n                <span style="float: right; margin-right: 10px;">{{percent}} %</span>\n            </div>\n        </div>\n        {%\n        topMargin = 0\n        end\n        end\n        end %}\n    </div>\n</body>\n\n</html>'


        local updateInterval                  = 0.3


        ---@alias HudData {speed:number, maxSpeed:number}


        ---@class Hud

        ---@field New fun():Hud


        local Hud                             = {}

        Hud.__index                           = Hud


        ---@return Hud

        function Hud.New()
            local s = {}
            local flightData = {} ---@type FlightData
            local fuelByType = {} ---@type table<string,FuelTankInfo[]>
            local unitInfo = system.getItem(unit.getItemId())
            local isECU = unitInfo.displayNameWithSize:lower():match("emergency")

            system.showScreen(true)

            Task.New("HUD", function()
                local tpl = Template(hudTemplate, { log = log, tostring = tostring, round = calc.Round }, function(obj, err)
                    log.Error("Error compiling template: ", err)
                end)

                local sw = Stopwatch.New()
                sw.Start()

                while true do
                    if sw.Elapsed() > updateInterval then
                        sw.Restart()

                        local html = tpl({
                            throttle = player.isFrozen() and
                                string.format("Throttle: %0.0f%% (Manual Control)", input.Throttle() * 100) or
                                "Automatic Control",
                            fuelByType = fuelByType,
                            isECU = isECU,
                        })

                        system.setScreen(html)
                    end
                    coroutine.yield()
                end
            end).Catch(function(t)
                log.Error(t.Name(), " ", t.Error())
            end)


            pub.RegisterTable("FlightData",
                ---@param _ string
                ---@param data FlightData
                function(_, data)
                    flightData = data
                end)

            pub.RegisterTable("FuelByType",
                ---@param _ string
                ---@param data table<string,FuelTankInfo[]>
                function(_, data)
                    fuelByType = data
                end)

            return setmetatable(s, Hud)
        end


        return Hud


        end)

        package.preload['YFS:../e/lib/src/panel/ValueWidget.lua']=(function()

        ---@class ValueWidget

        ---@field New fun(panelId:string, title:string, unit:string):ValueWidget

        ---@field Close fun()

        ---@field Set fun(value:any)

        ---@field Update fun()

        ---@field WidgetId fun():string


        local ValueWidget = {}

        ValueWidget.__index = ValueWidget


        ---@param panelId string

        ---@param title string

        ---@param unit string

        ---@return ValueWidget

        function ValueWidget.New(panelId, title, unit)
            local s = {
                panelId = panelId,
                title = title,
                unit = unit,
                widgetId = system.createWidget(panelId, "value"),
                dataId = nil,
                newValue = nil
            }

            if s.widgetId == nil then
                system.print("Could not create widget!")
                unit.exit()
            end

            function s.Close()
                system.removeDataFromWidget(s.dataId, s.widgetId)
                system.destroyData(s.dataId)
                system.destroyWidget(s.widgetId)
            end

            function s.Set(value)
                s.newValue = tostring(value)
            end

            function s.Update()
                if s.newValue ~= nil then
                    local str = '{ "label":"' ..
                        s.title .. '", "value": "' .. s.newValue .. '", "unit": "' .. s.unit .. '"}'

                    if s.dataId == nil then
                        system.destroyData(s.dataId)
                        s.dataId = system.createData(str)
                        system.addDataToWidget(s.dataId, s.widgetId)
                    else
                        system.updateData(s.dataId, str)
                    end

                    s.newValue = nil
                end
            end

            function s.WidgetId()
                return s.widgetId
            end

            setmetatable(s, ValueWidget)
            return s
        end


        return ValueWidget


        end)

        package.preload['YFS:../e/lib/src/panel/Panel.lua']=(function()

        local ValueWidget = require('YFS:../e/lib/src/panel/ValueWidget.lua')


        ---@class Panel

        ---@field New fun(title:string):Panel

        ---@field Close fun()

        ---@field Clear fun()

        ---@field Update fun()

        ---@field CreateValue fun(title?:string, unit?:string)


        local Panel = {}

        Panel.__index = Panel


        ---@param title string

        ---@return Panel

        function Panel.New(title)
            local s = {
                panelId = system.createWidgetPanel(title),
                widgets = {},
                updateHandlerId = nil
            }

            function s.Close()
                system:clearEvent("update", s.updateHandlerId)

                s.Clear()

                system.destroyWidgetPanel(s.panelId)
            end

            function s.Clear()
                for _, widget in pairs(s.widgets) do
                    widget:Close()
                end
                s.widgets = {}
            end

            function s.CreateValue(valueTitle, unit)
                local w = ValueWidget.New(s.panelId, valueTitle or "", unit or "")
                s.widgets[w.WidgetId()] = w
                return w
            end

            function s.Update()
                for _, widget in pairs(s.widgets) do
                    widget.Update()
                end
            end

            s.updateHandlerId = system:onEvent("onUpdate", s.Update, s)
            return setmetatable(s, Panel)
        end


        return Panel


        end)

        package.preload['YFS:../e/lib/src/panel/SharedPanel.lua']=(function()

        local Panel = require('YFS:../e/lib/src/panel/Panel.lua')


        ---@class SharedPanel

        ---@field Instance fun():SharedPanel

        ---@field Get fun(title:string):Panel

        ---@field Close fun(title:string)


        local singleton = nil


        local SharedPanel = {}

        SharedPanel.__index = SharedPanel


        ---@return SharedPanel

        function SharedPanel.Instance()
            if singleton then return singleton end
            local s = {}
            local panels = {}

            function s.Close(title)
                local p = panels[title]
                if p ~= nil then
                    p:Close()
                    panels[title] = nil
                end
            end

            function s.Get(title)
                if panels[title] == nil then
                    panels[title] = Panel.New(title)
                end

                return panels[title]
            end

            singleton = setmetatable(s, SharedPanel)
            return s
        end


        return SharedPanel


        end)

        package.preload['YFS:info/InfoCentral.lua']=(function()

        local s                              = require('YFS:Singletons.lua')

        local pub, calc, sharedPanel, format = s.pub, s.calc, require('YFS:../e/lib/src/panel/SharedPanel.lua').Instance(), string.format


        ---@class InfoCentral

        ---@field Instance fun():InfoCentral

        ---@field SetBrake fun(data:BrakeData)


        local InfoCentral                    = {}

        InfoCentral.__index                  = InfoCentral

        local instance


        function InfoCentral.Instance()
            if instance then return instance end

            local s = {}

            local brakeInfo = {
                visible       = false,
                panel         = nil,
                wDeceleration = nil,
                wCurrentDec   = nil,
                wPid          = nil,
            }

            local flightInfo = {
                visible = false,
                targetSpeed = 0,
                wStateName = nil,
                wPointDistance = nil,
                wAcceleration = nil,
                wCtrlAcceleration = nil,
                wTargetSpeed = nil,
                wFinalSpeed = nil,
                wSpeedDiff = nil,
                wBrakeMaxSpeed = nil,
                wPid = nil,
                wDistToAtmo = nil,
                wSpeed = nil,
                wAdjTowards = nil,
                wAdjDist = nil,
                wAdjAcc = nil,
                wAdjBrakeDistance = nil,
                wAdjSpeed = nil
            }

            local adjustInfo = {
                visible = false,
                panel = nil,
                wAdjTowards = nil,
                wAdjDist = nil,
                wAdjAcc = nil,
                wAdjBrakeDistance = nil,
                wAdjSpeed = nil
            }

            local axisInfo = {
                visible = false,
                pitchPanels = nil,
                rollPanels = nil,
                yawPanels = nil,
            }

            local waypointInfo = {
                visible = false,
                wDistance = nil,
                wMargin = nil,
                wFinalSpeed = nil,
                wMaxSpeed = nil,
            }

            pub.RegisterBool("ShowInfoWidgets", function(_, value)
                brakeInfo.visible = value
                flightInfo.visible = value
                adjustInfo.visible = value
                axisInfo.visible = value
                waypointInfo.visible = value

                if value then
                    unit.showWidget()
                else
                    unit.hideWidget()
                end

                system.showHelper(value)
            end)

            unit.hideWidget()
            system.showHelper(false)

            ---@param value BrakeData
            pub.RegisterTable("BrakeData", function(topic, value)
                if not brakeInfo.panel and brakeInfo.visible then
                    local p = sharedPanel.Get("Brake")
                    brakeInfo.panel = p
                    brakeInfo.wMaxDeceleration = p.CreateValue("Max deceleration", "m/s2")
                    brakeInfo.wCurrentDec = p.CreateValue("Brake dec.", "m/s2")
                    brakeInfo.wPid = p.CreateValue("Pid")
                    brakeInfo.wAutoBrakeAngle = p.CreateValue("Auto brake angle")
                elseif brakeInfo.panel and not brakeInfo.visible then
                    sharedPanel.Close("Brake")
                    brakeInfo.panel = nil
                end

                if brakeInfo.panel then
                    brakeInfo.wMaxDeceleration.Set(calc.Round(value.maxDeceleration, 2))
                    brakeInfo.wCurrentDec.Set(calc.Round(value.currentDeceleration, 2))
                    brakeInfo.wPid.Set(calc.Round(value.pid, 4))
                    brakeInfo.wAutoBrakeAngle.Set(format("%.1f/%.1f", value.autoBrakeAngle, value.setAutoBrakeAngle))
                end
            end)

            ---@param topic string
            ---@param value FlightData
            pub.RegisterTable("FlightData", function(topic, value)
                if not flightInfo.panel and flightInfo.visible then
                    local p = sharedPanel.Get("Movement")
                    flightInfo.panel = p
                    flightInfo.wStateName = p.CreateValue("State", "")
                    flightInfo.wPointDistance = p.CreateValue("Point dist.", "m")
                    flightInfo.wAcceleration = p.CreateValue("Acceleration", "m/s2")
                    flightInfo.wCtrlAcceleration = p.CreateValue("Ctrl. acc.", "m/s2")
                    flightInfo.wTargetSpeed = p.CreateValue("Target speed")
                    flightInfo.wFinalSpeed = p.CreateValue("Final speed")
                    flightInfo.wSpeedDiff = p.CreateValue("Speed diff", "km/h")
                    flightInfo.wBrakeMaxSpeed = p.CreateValue("Brake Max Speed", "km/h")
                    flightInfo.wPid = p.CreateValue("Pid")
                    flightInfo.wDistToAtmo = p.CreateValue("Atmo dist.", "m")
                    flightInfo.wSpeed = p.CreateValue("Abs. speed", "km/h")
                elseif brakeInfo.panel and not brakeInfo.visible then
                    sharedPanel.Close("Movement")
                    flightInfo.panel = nil
                end

                if flightInfo.panel then
                    flightInfo.wStateName.Set(value.fsmState)
                    flightInfo.wPointDistance.Set(calc.Round(value.waypointDist, 2))
                    flightInfo.wAcceleration.Set(format("%.1f", value.acceleration))
                    flightInfo.wCtrlAcceleration.Set(format("%.1f", value.controlAcc))
                    flightInfo.wTargetSpeed.Set(format("%.1f (%s)", calc.Mps2Kph(value.targetSpeed), value.targetSpeedReason))
                    flightInfo.wFinalSpeed.Set(format("%.1f km/h in %.1f m", calc.Mps2Kph(value.finalSpeed),
                        value.finalSpeedDistance))
                    flightInfo.wSpeedDiff.Set(calc.Round(calc.Mps2Kph(value.speedDiff), 1))
                    flightInfo.wBrakeMaxSpeed.Set(calc.Round(calc.Mps2Kph(value.brakeMaxSpeed)))
                    flightInfo.wPid.Set(calc.Round(value.pid, 4))
                    flightInfo.wDistToAtmo.Set(calc.Round(value.distanceToAtmo, 1))
                    flightInfo.wSpeed.Set(calc.Round(calc.Mps2Kph(value.absSpeed), 1))
                end
            end)

            ---@param topic string
            ---@param value AdjustmentData
            pub.RegisterTable("AdjustmentData", function(topic, value)
                if not adjustInfo.panel and adjustInfo.visible then
                    local p = sharedPanel.Get("Adjustment")
                    adjustInfo.panel = p
                    adjustInfo.wLong = p.CreateValue("Long", "m")
                    adjustInfo.wLat = p.CreateValue("Lat", "m")
                    adjustInfo.wVert = p.CreateValue("Vert", "m")
                elseif adjustInfo.panel and not adjustInfo.visible then
                    sharedPanel.Close("Adjustment")
                    adjustInfo.panel = nil
                end

                if adjustInfo.panel then
                    adjustInfo.wLong.Set(calc.Round(value.long, 2))
                    adjustInfo.wLat.Set(calc.Round(value.lat, 2))
                    adjustInfo.wVert.Set(calc.Round(value.ver, 2))
                end
            end)

            ---@param p Panel
            ---@param axisName string
            local function createAxisValues(p, axis, axisName)
                axis.wTitle = p.CreateValue("Axis")
                axis.wTitle.Set(axisName)
                axis.wSpeed = p.CreateValue("Speed", "°/s")
                axis.wAcceleration = p.CreateValue("Acc.", "°/s2")
                axis.wOffset = p.CreateValue("Offset", "°")
            end

            local function setupAxisPanels()
                if not axisInfo.pitchPanels and axisInfo.visible then
                    local p = sharedPanel.Get("Rotation")
                    axisInfo.panel = p
                    axisInfo.pitchPanels = {}
                    createAxisValues(p, axisInfo.pitchPanels, "--- Pitch ---")
                    axisInfo.rollPanels = {}
                    createAxisValues(p, axisInfo.rollPanels, "--- Roll ---")
                    axisInfo.yawPanels = {}
                    createAxisValues(p, axisInfo.yawPanels, "--- Yaw ---")
                elseif axisInfo.pitchPanels and not axisInfo.visible then
                    sharedPanel.Close("Rotation")
                    adjustInfo.pitchPanels = nil
                    adjustInfo.rollPanels = nil
                    adjustInfo.yawPanels = nil
                end
            end

            ---@param p table
            ---@param value AxisControlData
            local function setAxisValues(p, value)
                p.wSpeed.Set(calc.Round(value.speed, 2))
                p.wAcceleration.Set(calc.Round(value.acceleration, 2))
                p.wOffset.Set(calc.Round(value.offset, 2))
            end

            ---@param topic string
            ---@param value AxisControlData
            pub.RegisterTable("PitchData", function(topic, value)
                axisInfo.pitch = value

                setupAxisPanels()

                if axisInfo.panel then
                    local p = axisInfo.pitchPanels
                    if p ~= nil then
                        setAxisValues(p, value)
                    end
                end
            end)

            ---@param topic string
            ---@param value AxisControlData
            pub.RegisterTable("RollData", function(topic, value)
                axisInfo.roll = value

                setupAxisPanels()

                if axisInfo.panel then
                    local p = axisInfo.rollPanels
                    if p ~= nil then
                        setAxisValues(p, value)
                    end
                end
            end)

            ---@param topic string
            ---@param value AxisControlData
            pub.RegisterTable("YawData", function(topic, value)
                axisInfo.pitch = value

                setupAxisPanels()

                if axisInfo.panel then
                    local p = axisInfo.yawPanels
                    if p ~= nil then
                        setAxisValues(p, value)
                    end
                end
            end)

            pub.RegisterTable("WaypointData",
                ---@param topic string
                ---@param waypoint Waypoint
                function(topic, waypoint)
                    if not waypointInfo.panel and waypointInfo.visible then
                        local p = sharedPanel.Get("Waypoint")
                        waypointInfo.panel = p
                        waypointInfo.wDistance = p.CreateValue("Distance", "m")
                        waypointInfo.wMargin = p.CreateValue("Margin", "m")
                        waypointInfo.wFinalSpeed = p.CreateValue("Final speed", "km/h")
                        waypointInfo.wMaxSpeed = p.CreateValue("Max speed", "km/h")
                    elseif waypointInfo.panel and not waypointInfo.visible then
                        sharedPanel.Close("Waypoint")
                        waypointInfo.panel = nil
                    end

                    if waypointInfo.panel then
                        waypointInfo.wDistance.Set(calc.Round(waypoint.DistanceTo(), 3))
                        waypointInfo.wMargin.Set(calc.Round(waypoint.Margin(), 3))
                        waypointInfo.wFinalSpeed.Set(calc.Round(calc.Kph2Mps(waypoint.FinalSpeed()), 1))
                        waypointInfo.wMaxSpeed.Set(calc.Round(calc.Kph2Mps(waypoint.MaxSpeed()), 1))
                    end
                end)

            instance = setmetatable(s, InfoCentral)
            return instance
        end


        return InfoCentral


        end)

        package.preload['YFS:controller/Wsad.lua']=(function()

        require('YFS:GlobalTypes.lua')

        local s                                = require('YFS:Singletons.lua')

        local log, universe, input, pub, gateControl,

        constants, calc, keys, floor, gateCtrl =
            s.log, s.universe, s.input, s.pub, s.gateCtrl, s.constants, s.calc, s.keys, s.floorDetector, s.gateCtrl
        local VerticalReferenceVector          = universe.VerticalReferenceVector

        local Sign                             = calc.Sign

        local NF                               = function() return not IsFrozen() end

        local Clamp                            = calc.Clamp


        local defaultMargin                    = constants.flight.defaultMargin


        ---@class Wsad

        ---@field New fun(flightcore:FlightCore):Wsad


        local Wsad                             = {}

        Wsad.__index                           = Wsad


        ---@param fsm FlightFSM

        ---@param flightCore FlightCore

        ---@param settings Settings

        ---@param access Access

        ---@return Wsad

        function Wsad.New(fsm, flightCore, settings, access)
            local s = {}
            local turnAngle = settings.Number("turnAngle")
            local desiredAltitude = 0
            local vertical = 0
            local longitudal = 0
            local lateral = 0
            local pointDir = Vec3.zero
            local newMovement = false
            local stopVerticalMovement = false
            local yawSmoothStop = false
            local yawStopSign = 0
            local plane = Plane.NewByVertialReference()
            local stopPos = Vec3.zero
            local forwardToggle = false
            local allowForwardToggle = settings.Boolean("allowForwardToggle")

            settings.Callback("allowForwardToggle", function(v)
                allowForwardToggle = v
            end)

            local function getForwardToggle()
                return forwardToggle and allowForwardToggle
            end


            input.SetThrottle(1) -- Start at max speed
            local throttleStep = settings.Get("throttleStep", constants.flight.throttleStep) / 100
            ---@cast throttleStep number
            input.SetThrottleStep(throttleStep)

            settings.Callback("throttleStep", function(step)
                input.SetThrottleStep(step / 100)
            end)

            local function checkControlMode()
                if unit.isMouseControlActivated() or unit.isMouseDirectControlActivated() or unit.isMouseVirtualJoystickActivated() then
                    log.Error("Must use control scheme 'Keyboard'")
                    unit.exit()
                end
            end

            checkControlMode()

            local function lockUser()
                if not access.AllowsManualControl() then
                    log.Error("Manual control not authorized")
                    return
                end

                player.freeze(true)
                log.Info("Manual control enabled, auto shutdown disabled.")
            end

            local function toggleUserLock()
                if IsFrozen() then
                    player.freeze(false)
                    log.Info("Manual control disabled, auto shutdown enabled.")
                else
                    lockUser()
                end
            end

            local function getThrottleSpeed()
                return MaxSpeed() * input.Throttle()
            end

            ---@return number
            local function altitude()
                local curr = Current()
                local body = universe.ClosestBody(curr)
                return (curr - body.Geography.Center):Len()
            end

            local function monitorHeight()
                desiredAltitude = altitude()
                stopVerticalMovement = true
            end

            ---@param body Body
            ---@return Vec3
            local function movement(body)
                local curr = Current()
                -- Put the point 50 m ahead
                local dist = 50

                local dir = (plane.Forward() * (getForwardToggle() and 1 or longitudal)
                        + plane.Right() * lateral
                        + plane.Up() * vertical)
                    :Normalize()

                if body:IsInAtmo(curr) and vertical == 0 then
                    -- As we meassure only periodically, we can't make the threshold too small. 0.2m/s was too small, we can miss that when moving fast.
                    if stopVerticalMovement and Velocity():ProjectOn(-VerticalReferenceVector()):Len() < 0.5 then
                        desiredAltitude = altitude()
                        stopVerticalMovement = false
                    end


                    -- Find the direction from body center to forward point and calculate a new point with same
                    -- height as the movement started at so that we move along the curvature of the body.
                    local pointInDir = curr + dir * dist
                    local center = body.Geography.Center
                    return center + (pointInDir - center):NormalizeInPlace() * desiredAltitude
                end

                return Current() + dir * dist
            end

            Task.New("WASD", function()
                local t = 0.1
                local sw = Stopwatch.New()
                sw.Start()
                local wantsToMove = false

                pub.RegisterBool("ResetWSAD", function(_, _)
                    stopPos = Vec3.zero
                    wantsToMove = false
                    pointDir = Vec3.zero
                    forwardToggle = false
                end)

                pub.RegisterTable("ForwardDirectionChanged",
                    ---@param _ string
                    ---@param value Vec3
                    function(_, value)
                        pointDir = value
                    end)

                pub.RegisterTable("YawData",
                    ---@param value {speed:number}
                    function(_, value)
                        if yawSmoothStop then
                            if Sign(value.speed) ~= yawStopSign then
                                flightCore.AlignTo(Current() + plane.Forward() * 1000)
                                yawSmoothStop = false
                            end
                        end
                        yawStopSign = Sign(value.speed)
                    end)

                monitorHeight()

                while true do
                    local curr = Current()
                    local body = universe.ClosestBody(curr)

                    local hadNewMovement = newMovement

                    wantsToMove = getForwardToggle() or longitudal ~= 0 or vertical ~= 0 or lateral ~= 0
                    if not wantsToMove and newMovement then
                        stopPos = Current()
                    end

                    if IsFrozen() then
                        if wantsToMove then
                            gateControl.Enable(false)
                            if pointDir:IsZero() then
                                -- Recovery after running a route
                                pointDir = plane.Forward()
                            end

                            if sw.Elapsed() > t or newMovement then
                                sw.Restart()

                                local throttleSpeed = getThrottleSpeed()
                                local target = movement(body)
                                flightCore.GotoTarget(target, pointDir, defaultMargin, throttleSpeed, throttleSpeed, true, true)
                            end
                        else
                            if newMovement then
                                flightCore.GotoTarget(stopPos, pointDir, defaultMargin, 0, construct.getMaxSpeed(), true, true)
                            elseif not stopPos:IsZero() and Velocity():Normalize():Dot(stopPos - curr) >= 0 then
                                local holdMargin = defaultMargin
                                flightCore.GotoTarget(Current(), pointDir, holdMargin, calc.Kph2Mps(2), 0, false, true)
                                stopPos = Vec3.zero
                            end
                        end
                    else
                        -- Ensure we keep throttle at max when not in manual control.
                        input.SetThrottle(1)
                    end

                    -- Reset this only if it was active at the start of the loop.
                    if hadNewMovement then
                        newMovement = false
                    end

                    coroutine.yield()
                end
            end)

            local function change(value, delta)
                forwardToggle = false

                local prev = value
                value = Clamp(value + delta, -1, 1)

                if value == 0 then
                    monitorHeight()
                end

                newMovement = value ~= prev
                gateControl.Enable(false)

                return value
            end

            ---@param delta integer
            local function changeVertical(delta)
                vertical = change(vertical, delta)
            end

            ---@param delta integer
            local function changeLongitudal(delta)
                longitudal = change(longitudal, delta)
            end

            ---@param delta integer
            local function changeLateral(delta)
                lateral = change(lateral, delta)
            end

            local function NewIgnoreBoth()
                return Criteria.New().IgnoreLCtrl().IgnoreLShift()
            end

            local function fwd() changeLongitudal(1) end
            local function back() changeLongitudal(-1) end

            input.Register(keys.forward, NewIgnoreBoth().OnRepeat(), fwd)
            input.Register(keys.forward, NewIgnoreBoth().OnRelease(), back)
            input.Register(keys.backward, NewIgnoreBoth().OnRepeat(), back)
            input.Register(keys.backward, NewIgnoreBoth().OnRelease(), fwd)

            local function left() changeLateral(-1) end
            local function right() changeLateral(1) end

            input.RegisterMany({ keys.strafeleft, keys.left }, NewIgnoreBoth().OnRepeat(), left)
            input.RegisterMany({ keys.strafeleft, keys.left }, NewIgnoreBoth().OnRelease(), right)
            input.RegisterMany({ keys.straferight, keys.right }, NewIgnoreBoth().OnRepeat(), right)
            input.RegisterMany({ keys.straferight, keys.right }, NewIgnoreBoth().OnRelease(), left)

            local function up() changeVertical(1) end
            local function down() changeVertical(-1) end

            input.Register(keys.up, NewIgnoreBoth().OnRepeat(), up)
            input.Register(keys.up, NewIgnoreBoth().OnRelease(), down)
            input.Register(keys.down, NewIgnoreBoth().OnRepeat(), down)
            input.Register(keys.down, NewIgnoreBoth().OnRelease(), up)

            local function turn(positive)
                if NF() then return end
                pointDir = flightCore.Turn(positive and turnAngle or -turnAngle, plane.Up())
            end

            input.Register(keys.yawleft, NewIgnoreBoth().OnRepeat(), function()
                turn(true)
            end)

            input.Register(keys.yawright, NewIgnoreBoth().OnRepeat(), function()
                turn(false)
            end)

            input.RegisterMany({ keys.yawleft, keys.yawright }, NewIgnoreBoth().OnRelease(),
                function()
                    if NF() then return end
                    yawSmoothStop = true
                end)

            local function booster(on)
                if NF() then return end
                fsm.SetBooster(on)
            end

            input.Register(keys.brake, Criteria.New().LCtrl().OnPress(), function()
                forwardToggle = false
                newMovement = true
                pointDir = plane.Forward()
                stopPos = Current()
            end)

            input.Register(keys.booster, NewIgnoreBoth().OnPress(), function() booster(true) end)
            input.Register(keys.booster, NewIgnoreBoth().OnRelease(), function() booster(false) end)

            -- shift + alt + Option9 to switch modes
            input.Register(keys.option9, Criteria.New().LShift().OnPress(), toggleUserLock)

            input.Register(keys.stopengines, NewIgnoreBoth().OnPress(), function()
                if NF() then return end
                forwardToggle = not forwardToggle
                newMovement = true
            end)

            if settings.Get("manualControlOnStartup", false) then
                log.Info("Manual control on startup active.")
                lockUser()
            end

            settings.Callback("turnAngle",
                ---@param angle number
                function(angle)
                    turnAngle = angle
                end)

            return setmetatable(s, Wsad)
        end


        return Wsad


        end)

        package.preload['YFS:Access.lua']=(function()

        local s = require('YFS:Singletons.lua')

        local log, su = s.log, s.strUtil


        ---@alias AdminData table<string, boolean>

        ---@alias ConstructOwner {id:integer, isOrganization:boolean}


        ---@class Access

        ---@field CanExecute fun(command:string):boolean

        ---@field AllowsManualControl fun():boolean

        ---@field AllowedRoute fun(routeName:string)

        ---@field DisallowRoute fun(routeName:string)

        ---@field MayStartRoute fun(routeName:string):boolean

        ---@field New fun(db:BufferedDB):Access


        local Access = {}

        Access.__index = Access

        local instance


        ---@param db BufferedDB

        ---@param cmdLine CommandLine

        ---@return Access

        function Access.New(db, cmdLine)
            if instance then return instance end

            local s = {}
            local ROUTES, MANUAL, ORG_ADMIN, ADMIN = "allowedRoutes", "allowManualControl", "orgAdmin", "adminList"

            ---@return ConstructOwner
            local function getOwner()
                ---@type {id:integer, isOrganization:boolean}
                return construct.getOwner()
            end

            local function isOwnedByAnOrg()
                return getOwner().isOrganization
            end

            local function isOrgAnAdmin()
                -- By default owning org is an admin
                return isOwnedByAnOrg() and db.Boolean(ORG_ADMIN, true)
            end

            local function isMemberOfOwningOrg()
                local owner = getOwner()
                if owner.isOrganization then
                    for _, v in ipairs(player.getOrgIds()) do
                        if v == owner.id then
                            return true
                        end
                    end
                end
                return false
            end

            local function isSingleOwner()
                local owner = getOwner()
                return (not owner.isOrganization) and owner.id == player.getId()
            end

            local function isInAdminList()
                local name, admins = player.getName(), db.Get(ADMIN, {})
                ---@cast admins AdminData
                for k, _ in pairs(admins) do
                    if k == name then
                        return true
                    end
                end

                return false
            end

            local function isAdmin()
                return isSingleOwner() or
                    (isOwnedByAnOrg() and isMemberOfOwningOrg() and isOrgAnAdmin()) or
                    isInAdminList()
            end

            if isAdmin() then
                log.Info(player.getName(), " is an admin")
            end

            ---@param command string
            ---@return boolean
            function s.CanExecute(command)
                -- Disallow everything but route-activate
                return isAdmin() or su.StartsWith(command, "route-activate")
            end

            ---@return boolean
            function s.AllowsManualControl()
                return isAdmin() or db.Boolean(MANUAL, false)
            end

            ---@param routeName string
            function s.AllowRoute(routeName)
                local routes = db.Get(ROUTES, {})
                routes[routeName] = true
                db.Put(ROUTES, routes or {})
            end

            ---@param routeName string
            function s.DisallowRoute(routeName)
                local routes = db.Get(ROUTES, {})
                routes[routeName] = nil
                db.Put(ROUTES, routes or {})
            end

            ---@param routeName string
            function s.MayStartRoute(routeName)
                local routes = db.Get(ROUTES, {})
                local mayStart = (routes and routes[routeName] ~= nil) or isAdmin()

                if not mayStart then
                    log.Error("Not authorized to start route '", routeName, "'")
                end

                return mayStart
            end

            instance = setmetatable(s, Access)

            cmdLine.Accept("allow-route",
                ---@param data {commandValue:string}
                function(data)
                    s.AllowRoute(data.commandValue)
                end).AsString().Must()

            cmdLine.Accept("disallow-route",
                ---@param data {commandValue:string}
                function(data)
                    s.DisallowRoute(data.commandValue)
                end).AsString().Must()

            cmdLine.Accept("print-allowed-routes",
                ---@param _ {commandValue:string}
                function(_)
                    local allowed = db.Get(ROUTES, {})
                    ---@cast allowed table
                    if TableLen(allowed) > 0 then
                        log.Info("Allowed routes:")
                        for k, v in pairs(allowed) do
                            log.Info(k)
                        end
                    else
                        log.Info("No allowed routes")
                    end
                end).AsEmpty()

            cmdLine.Accept("allow-manual-control", function(data)
                db.Put(MANUAL, true)
            end)

            cmdLine.Accept("disallow-manual-control", function(data)
                db.Put(MANUAL, false)
            end)

            local function checkOrgOwner()
                local owner = getOwner()
                if not owner.isOrganization then
                    log.Error("Owner is not an organization")
                    return false
                end
                return true
            end

            cmdLine.Accept("allow-org-admin", function(data)
                if checkOrgOwner() then
                    db.Put(ORG_ADMIN, true)
                    log.Info("Owning organization is now considered an admin")
                end
            end)

            cmdLine.Accept("disallow-org-admin", function(data)
                if not checkOrgOwner() then
                    return
                end

                if not isInAdminList() then
                    log.Error(
                        "Removing the orginaization as an admin would lock yourself out since you're not in the admin list, aborting!")
                    return
                end

                db.Put(ORG_ADMIN, false)
                log.Info("Owning organization is no longer considered an admin")
            end)

            ---@param name string
            ---@param value? boolean
            local function setAdmin(name, value)
                local admins = db.Get(ADMIN, {})
                ---@cast admins AdminData

                local existed = admins[name] ~= nil

                admins[name] = value or nil
                db.Put(ADMIN, admins)

                if value then
                    log.Info(name, " added to admin list")
                elseif existed then
                    log.Info(name, " removed from admin list")
                else
                    log.Error(name, " is not in the admin list")
                end
            end

            cmdLine.Accept("add-admin",
                ---@param data {commandValue:string}
                function(data)
                    setAdmin(data.commandValue, true)
                end).AsString().Must()

            cmdLine.Accept("remove-admin",
                ---@param data {commandValue:string}
                function(data)
                    -- Can't remove yourself if org owned and org is not an admin, that would lock you out
                    local isAdminViaOrg = isMemberOfOwningOrg() and isOrgAnAdmin()
                    local isAssignedAdmin = isInAdminList()

                    if data.commandValue == player.getName() then
                        if not (isAdminViaOrg and isAssignedAdmin) then
                            log.Error(
                                "Removing yourself as an admin would lock yourself out, aborting!")
                            return
                        end
                    end

                    setAdmin(data.commandValue)
                end).AsString().Must()

            cmdLine.Accept("print-admins", function(_)
                local admins = db.Get(ADMIN, {})
                ---@cast admins AdminData
                if TableLen(admins) > 0 then
                    log.Info("Admins:")
                    for k, v in pairs(admins) do
                        log.Info(k)
                    end
                else
                    log.Info("No named admins")
                end
                if isOrgAnAdmin() then
                    log.Info("Members of owning orgs are all admins")
                end
            end)

            return instance
        end


        return Access


        end)

        package.preload['YFS:flight/GeoFence.lua']=(function()

        require('YFS:../e/lib/src/abstraction/Vehicle.lua')

        local s                   = require('YFS:Singletons.lua')

        local log, universe, Vec3 = s.log, s.universe, require('YFS:../e/lib/src/math/Vec3.lua')


        ---@alias GeoFenceData {centerPos:string, boundary:number, enabled:boolean}


        ---@class GeoFence

        ---@field Limited fun(travelDir:Vec3):boolean


        local GeoFence            = {}

        GeoFence.__index          = GeoFence


        ---@param db BufferedDB

        ---@param cmdLine CommandLine

        ---@return GeoFence

        function GeoFence.New(db, cmdLine)
            local s = {}

            local center = Vec3.zero

            ---@type GeoFenceData
            local cfg = {
                enabled = false,
                centerPos = "",
                boundary = 0, ---@type number
            }

            local KEY = "geofence"

            local function load()
                local c = db.Get(KEY)
                ---@cast c GeoFenceData
                if c then
                    cfg.boundary = c.boundary
                    cfg.centerPos = c.centerPos
                    cfg.enabled = c.enabled

                    if cfg.centerPos ~= nil and cfg.centerPos ~= "" then
                        center = universe.ParsePosition(cfg.centerPos).Coordinates()
                    end

                    cfg.boundary = cfg.boundary or 150
                end
            end

            local function save()
                db.Put(KEY, cfg)
                local c = universe.ParsePosition(cfg.centerPos)
                if c then
                    center = c.Coordinates()
                end
            end

            local geo = cmdLine.Accept("geofence",
                ---@param data {commandValue:string, boundary:number}
                function(data)
                    if data.boundary <= 0 then
                        log.Error("Boundary must be > 0")
                        return
                    end

                    local c = universe.ParsePosition(data.commandValue)
                    if c then
                        cfg.centerPos = c.AsPosString()
                        cfg.boundary = data.boundary
                        cfg.enabled = true
                        save()

                        center = c.Coordinates()
                    end
                end).AsString().Must()
            geo.Option("boundary").AsNumber().Must()

            cmdLine.Accept("disable-geofence", function()
                cfg.enabled = false
                save()
            end)

            cmdLine.Accept("print-geofence", function(data)
                log.Info(cfg)
            end)

            ---@param travelDir Vec3
            ---@return boolean #True if limited
            function s.Limited(travelDir)
                if cfg.enabled and cfg.centerPos ~= nil and cfg.centerPos ~= "" then
                    local pos = Current()
                    local dir, dist = (center - pos):NormalizeLen()

                    -- Outside boundary or moving >90 degrees away from center
                    return dist > cfg.boundary and dir:Dot(travelDir) < 0
                end

                return false
            end

            function s.Center()
                return center
            end

            load()

            return setmetatable(s, GeoFence)
        end


        return GeoFence


        end)

        package.preload['YFS:Start.lua']=(function()

        require('YFS:GlobalTypes.lua')

        local s = require('YFS:Singletons.lua')


        local pub, input, commandLine, log, radar, floorDetector = s.pub, s.input, s.commandLine, s.log, s.radar,
            s.floorDetector
        local ControlCommands, RouteController, BufferedDB, Fuel, FlightFSM, FlightCore, ScreenController, Communcation, Settings, Hud, InfoCentral, Wsad, Access, GeoFence =
            require('YFS:controller/ControlCommands.lua'),
            require('YFS:flight/route/RouteController.lua'), require('YFS:../e/lib/src/storage/BufferedDB.lua'), require('YFS:info/Fuel.lua'),
            require('YFS:flight/FlightFSM.lua'), require('YFS:flight/FlightCore.lua'), require('YFS:controller/ScreenController.lua'),
            require('YFS:controller/Communication.lua'), require('YFS:Settings.lua'), require('YFS:hud/Hud.lua'), require('YFS:info/InfoCentral.lua'),
            require('YFS:controller/Wsad.lua'), require('YFS:Access.lua'), require('YFS:flight/GeoFence.lua')

        ---Main routine that starts the system

        ---@param isECU boolean

        local function Start(isECU)
            log.SetLevel(LVL.WARNING)

            local routeDbName = "Routes"
            local routeLink   = library.getLinkByName(routeDbName)

            if not routeLink then
                log.Error("Must link a databank named '", routeDbName, "'")
                unit.exit()
                return
            end

            local settingsDbName = "Settings"
            local settingLink = library.getLinkByName(settingsDbName)
            if not settingLink then
                log.Info("No DB named '", settingsDbName, "' linked falling back to route DB.")
                settingLink = routeLink
            end

            if isECU then
                log.Info("Running as ECU")
            end

            local settingsDb = BufferedDB.New(settingLink)
            local routeDb = BufferedDB.New(routeLink)
            local settings = Settings.Create(settingsDb)
            local hud ---@type Hud
            local wsad ---@type Wsad
            local commands ---@type ControlCommands
            local screen ---@type ScreenController
            local fuel ---@type Fuel
            local info ---@type InfoCentral

            local followRemote = library.getLinkByName("FollowRemote") ---@type any

            if followRemote and (type(followRemote.activate) ~= "function" or type(followRemote.deactivate) ~= "function") then
                followRemote = nil
            end

            if followRemote then
                log.Info("Found FollowRemote switch")
                followRemote.activate()

                unit:onEvent("onStop", function()
                    followRemote.deactivate()
                end)
            end

            Task.New("Main", function()
                settingsDb.BeginLoad()
                routeDb.BeginLoad()

                while not settingsDb.IsLoaded() or not routeDb.IsLoaded() do
                    coroutine.yield()
                end

                local access = Access.New(settingsDb, commandLine)
                commandLine.SetAccess(access.CanExecute)

                local rc = RouteController.Instance(routeDb)
                local fsm = FlightFSM.New(settings, rc, GeoFence.New(settingsDb, commandLine))
                local fc = FlightCore.New(rc, fsm)
                fsm.SetFlightCore(fc)

                if not isECU then
                    screen = ScreenController.New(fc, settings)
                    wsad = Wsad.New(fsm, fc, settings, access)
                end

                commands = ControlCommands.New(input, commandLine, fc, settings, screen, access, routeDb)

                settings.Reload()
                -- After this point settings are loaded so any registered callback will not be called.
                fc.ReceiveEvents()

                local floor = floorDetector.Measure()
                if not floor.Hit or floor.Distance > settings.Get("autoShutdownFloorDistance") then
                    log.Info("No floor detected within set limit during startup, holding postition.")
                    rc.ActivateHoldRoute()
                    fc.StartFlight()
                elseif isECU then
                    log.Info("Floor detected, shutting down")
                    unit.exit()
                else
                    fsm.SetState(Idle.New(fsm))
                end

                fuel = Fuel.New(settings)

                info = InfoCentral.Instance()
                hud = Hud.New()

                commands.RegisterMoveCommands()
                commands.RegisterCommonCommands(isECU)
                if not isECU then
                    commands.RegisterRouteCommands()
                    radar.Show(settings.Boolean("showRadarOnStart"))
                    radar.Sort(settings.Number("defaultRadarMode"))

                    settings.Callback("defaultRadarMode", function(value)
                        radar.Sort(value)
                    end)
                end

                pub.Publish("ShowInfoWidgets", settings.Boolean("showWidgetsOnStart", false))

                local channel = settings.String("commChannel")
                local comm
                if not isECU and channel ~= "" then
                    comm = Communcation.New(channel)
                end
            end).Catch(function(t)
                log.Error(t.Name(), t.Error())
            end)

            Task.New("FloorMonitor", function()
                if floorDetector.Present() then
                    log.Info("FloorMonitor started")
                    local sw = Stopwatch.New()
                    sw.Start()

                    while true do
                        coroutine.yield()
                        if sw.Elapsed() > 0.3 then
                            sw.Restart()
                            pub.Publish("FloorMonitor", floorDetector.Measure())
                        end
                    end
                end
            end).Then(function(...)
                log.Info("Auto shutdown disabled")
            end).Catch(function(t)
                log.Error(t.Name(), t.Error())
            end)
        end


        return Start


        end)

        package.preload['YFS:variants/Limited.lua']=(function()

        require('YFS:GlobalTypes.lua')

        local log = require('YFS:../e/lib/src/debug/Log.lua').Instance()

        local Lock = require('YFS:../e/lib/src/element/Lock.lua')

        local v = require('YFS:version_out.lua')

        local linked, isECU = require('YFS:variants/CoreLinkCheck.lua')()


        ---@class Limited

        ---@field New fun():Limited

        ---@field AddLimit fun(count:number, size:EngineSize, engineType:EngineType)


        local Limited = {}

        Limited.__index = Limited


        function Limited.New()
            local s = {}
            local lock = Lock.New()

            function s.Start()
                log.Info(v.APP_NAME)
                log.Info(v.APP_VERSION)

                if linked then
                    local start = require('YFS:Start.lua')
                    start(isECU)

                    Task.New("Lock", function()
                        if lock.ValidateCo() then
                            log.Info("Engine check passed")
                        else
                            error("Engine check failed")
                        end
                    end).Catch(function(t)
                        unit.exit()
                    end)
                else
                    unit.exit()
                end
            end

            ---@param engineType EngineType
            ---@param size EngineSize
            ---@param count integer
            function s.AddLimit(engineType, size, count)
                lock.AddLimit(engineType, size, count)
            end

            return setmetatable(s, Limited)
        end


        return Limited


        end)

        library.addEventHandlers(library)

        library.addEventHandlers(system)

        library.addEventHandlers(player)

        library.addEventHandlers(construct)

        library.addEventHandlers(unit)

        library.addEventHandlers(receiver)

        library.addEventHandlers(spaceRadar)

        library.addEventHandlers(atmoRadar)
  system:
    onActionStart(action):
      lua: system:triggerEvent('onActionStart',action)
    onActionLoop(action):
      lua: system:triggerEvent('onActionLoop',action)
    onActionStop(action):
      lua: system:triggerEvent('onActionStop',action)
    onUpdate():
      lua: system:triggerEvent('onUpdate')
    onFlush():
      lua: system:triggerEvent('onFlush')
    onInputText(text):
      lua: system:triggerEvent('onInputText',text)
    onCameraChanged(mode):
      lua: system:triggerEvent('onCameraChanged',mode)
  player:
    "onParentChanged(oldId,newId)":
      lua: player:triggerEvent('onParentChanged',oldId,newId)
  construct:
    onDocked(id):
      lua: construct:triggerEvent('onDocked',id)
    onUndocked(id):
      lua: construct:triggerEvent('onUndocked',id)
    onPlayerBoarded(id):
      lua: construct:triggerEvent('onPlayerBoarded',id)
    onVRStationEntered(id):
      lua: construct:triggerEvent('onVRStationEntered',id)
    onConstructDocked(id):
      lua: construct:triggerEvent('onConstructDocked',id)
    onPvPTimer(active):
      lua: construct:triggerEvent('onPvPTimer',active)
  unit:
    onStop():
      lua: unit:triggerEvent('onStop')
    onTimer(timerId):
      lua: unit:triggerEvent('onTimer',timerId)
    onStart():
      lua: |-
        local limited = require('YFS:variants/Limited.lua').New()
        limited.AddLimit(EngineType.SPACE, EngineSize.XS, 10)
        limited.Start()
