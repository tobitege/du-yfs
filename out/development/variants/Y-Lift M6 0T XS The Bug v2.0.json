{"slots":{"0":{"name":"receiver","class":"Receiver","type":{"events":[],"methods":[]}},"1":{"name":"spaceRadar","class":"RadarPVPUnit","type":{"events":[],"methods":[]}},"2":{"name":"atmoRadar","class":"RadarPVPUnit","type":{"events":[],"methods":[]}},"-5":{"name":"library","type":{"events":[],"methods":[]}},"-4":{"name":"system","type":{"events":[],"methods":[]}},"-3":{"name":"player","type":{"events":[],"methods":[]}},"-2":{"name":"construct","type":{"events":[],"methods":[]}},"-1":{"name":"unit","type":{"events":[],"methods":[]}}},"handlers":[{"key":1,"filter":{"slotKey":-5,"signature":"onStart()","args":[]},"code":";(function()\nlocal a={}local b=0;function library.addEventHandlers(c)if not c or c.onEvent and c.triggerEvent then return false end;b=b+1;a[b]=c;local d,e,f='table','function','thread'if d~=type(c)then error('You can only add event handlers to table objects!')end;local g={}local function h(c)local i=type(c)return e==i or d==i and h(getmetatable(c).__call)or f==i end;c.onEvent=function(self,j,k,l)if not h(k)then error('Event handler must be a function, a callable object or a thread!')end;l=l or self;if d~=type(l)then error('The value of self must be a table!')end;if not g[j]then g[j]={_=0}end;local m=f==type(k)and function(...)coroutine.resume(k,...)end or k;local k=g[j]local n=k._+1;k[n]={m,l}k._=n;return n end;c.clearEvent=function(self,j,o)if g[j]and g[j][o]then g[j][o]=nil end end;c.clearAllEvents=function(self)g={}end;c.triggerEvent=function(self,j,...)local p=g[j]if p then for q=1,p._ do local k=p[q]if k then k[1](k[2],...)end end end end;return true end;function library.clearAllEventHandlers()for q=1,b do local c=a[q]if c and c.clearAllEvents then c:clearAllEvents()end end end\nend)()"},{"key":2,"filter":{"slotKey":-5,"signature":"onStart()","args":[]},"code":";(function()\nlocal a=DULibrary or{}function a.getLinks(b,c)local d={}if not b then b={}end;for e,f in pairs(unit.getOutPlugs())do local g=unit[f.name]if'table'==type(g)and'function'==type(g.getClass)then local h=true;for i,j in pairs(b)do if not('function'==type(g[i])and j==g[i]():sub(1,#j))then h=false;break end end;if h then if c then table.insert(d,g)else d[f.name]=g end end end end;return d end;function a.getLinksByClass(k,c)return a.getLinks({getClass=k},c)end;function a.getLinkByClass(k)return a.getLinksByClass(k,true)[1]end;function a.getCoreUnit()return a.getLinkByClass('CoreUnit')end;function a.getLinkByName(l)local m=a.getCoreUnit()if not m then error('getLinkByName requires a linked CoreUnit to work')end;local d=a.getLinks()for n,o in pairs(d)do if l==m.getElementNameById(o.getLocalId())then return o end end end\nend)()"},{"key":3,"filter":{"slotKey":-5,"signature":"onStart()","args":[]},"code":"package.preload['YFS:../e/lib/src/input/Keys.lua']=(function()\n---@class Keys\nlocal Keys = {}\nKeys.__index = Keys\n\nKeys[\"lshift\"] = 1\nKeys[\"lalt\"] = 2\nKeys[\"brake\"] = 3\nKeys[\"forward\"] = 4\nKeys[\"backward\"] = 5\nKeys[\"yawleft\"] = 6\nKeys[\"yawright\"] = 7\nKeys[\"strafeleft\"] = 8\nKeys[\"straferight\"] = 9\nKeys[\"left\"] = 10\nKeys[\"right\"] = 11\nKeys[\"up\"] = 12\nKeys[\"down\"] = 13\nKeys[\"groundaltitudeup\"] = 14\nKeys[\"groundaltitudedown\"] = 15\nKeys[\"gear\"] = 16\nKeys[\"light\"] = 17\nKeys[\"stopengines\"] = 18\nKeys[\"speedup\"] = 19\nKeys[\"speeddown\"] = 20\nKeys[\"antigravity\"] = 21\nKeys[\"booster\"] = 22\nKeys[\"option0\"] = 23\nKeys[\"option1\"] = 24\nKeys[\"option2\"] = 25\nKeys[\"option3\"] = 26\nKeys[\"option4\"] = 27\nKeys[\"option5\"] = 28\nKeys[\"option6\"] = 29\nKeys[\"option7\"] = 30\nKeys[\"option8\"] = 31\nKeys[\"option9\"] = 32\nKeys[\"option10\"] = 33\nKeys[\"option11\"] = 34\nKeys[\"option12\"] = 35\nKeys[\"option13\"] = 36\nKeys[\"option14\"] = 37\nKeys[\"option15\"] = 38\nKeys[\"option16\"] = 39\nKeys[\"option17\"] = 40\nKeys[\"option18\"] = 41\nKeys[\"option19\"] = 42\nKeys[\"option20\"] = 43\nKeys[\"option21\"] = 44\nKeys[\"option22\"] = 45\nKeys[\"option23\"] = 46\nKeys[\"option24\"] = 47\nKeys[\"option25\"] = 48\nKeys[\"option26\"] = 49\nKeys[\"option27\"] = 50\nKeys[\"option28\"] = 51\nKeys[\"option29\"] = 52\n\nlocal indexToName = {}\nfor key, value in pairs(Keys) do\n    indexToName[value] = key\nend\n\n---Returns the name of the key\n---@param value integer\n---@return string\nfunction Keys.Name(value)\n    return indexToName[value] or \"unknown key\"\nend\n\nreturn setmetatable({}, Keys)\n\nend)\npackage.preload['YFS:../e/lib/src/input/Criteria.lua']=(function()\nlocal keys = require('YFS:../e/lib/src/input/Keys.lua')\n\n---@class Criteria\n---@field Matches fun(input:Input, isRepeat:boolean, isPressed:boolean):boolean\n---@field LShift fun():Criteria\n---@field IgnoreLShift fun():Criteria\n---@field LCtrl fun():Criteria\n---@field IgnoreLCtrl fun():Criteria\n---@field OnPress fun():Criteria\n---@field OnRelease fun():Criteria\n---@field OnRepeat fun():Criteria\n\nlocal Criteria = {}\nCriteria.__index = Criteria\n\nfunction Criteria.New()\n    local s = {}\n    local requiredMods = {} ---@type integer[]\n    local prohibitedMods = { [keys.lshift] = true, [keys.brake] = true } ---@type table<integer,boolean>\n    local onRepeat = false\n    local onPress = false\n    local onRelease = false\n    local lastPressed = false -- when reacting to release events, we must know that we've been pressed first\n\n    ---Checks if the key events matches the set criterias\n    ---@param input Input\n    ---@param isRepeat boolean\n    ---@param isPressed boolean\n    ---@return boolean\n    function s.Matches(input, isRepeat, isPressed)\n        local released = onRelease and not isPressed\n\n        if not onRepeat and isRepeat then\n            return false\n        end\n\n        -- This check does not work with checking released keys, when the key is also a modifier key.\n        -- Only when pressing the key\n        if isPressed then\n            for _, k in pairs(requiredMods) do\n                if not input.IsPressed(k) then\n                    return false\n                end\n            end\n\n            -- Also need to check that other modifier keys are *not* pressed\n            for k, v in pairs(prohibitedMods) do\n                if v and input.IsPressed(k) then\n                    return false\n                end\n            end\n\n            lastPressed = true\n        end\n\n        if released then\n            if not lastPressed then\n                return false\n            end\n\n            lastPressed = false\n        end\n\n        return (onRepeat and isRepeat) or (onPress and isPressed) or released\n    end\n\n    function Criteria.__tostring()\n        local str = \"\"\n        for _, c in pairs(requiredMods) do\n            str = str .. \" \" .. c\n        end\n\n        return \"\" .. str\n    end\n\n    -- Q: Where is Alt key?\n    -- A: The game doesn't pass that though to us\n\n    ---Requires left shift to be pressed\n    ---@return Criteria\n    function s.LShift()\n        table.insert(requiredMods, keys.lshift)\n        prohibitedMods[keys.lshift] = false\n        return s\n    end\n\n    ---Requires left control to be pressed\n    ---@return Criteria\n    function s.LCtrl()\n        table.insert(requiredMods, keys.brake)\n        prohibitedMods[keys.brake] = false\n        return s\n    end\n\n    ---@return Criteria\n    function s.IgnoreLCtrl()\n        prohibitedMods[keys.brake] = false\n        return s\n    end\n\n    ---@return Criteria\n    function s.IgnoreLShift()\n        prohibitedMods[keys.lshift] = false\n        return s\n    end\n\n    ---Makes the critera match when the button is pressed\n    ---@return Criteria\n    function s.OnPress()\n        onPress = true\n        return s\n    end\n\n    ---Makes the criteria match when the button is released.\n    ---@return Criteria\n    function s.OnRelease()\n        onRelease = true\n        return s\n    end\n\n    ---Makes the critera match when the button is repeated\n    ---@return Criteria\n    function s.OnRepeat()\n        onRepeat = true\n        return s\n    end\n\n    return setmetatable(s, Criteria)\nend\n\nreturn Criteria\n\nend)\npackage.preload['YFS:../e/lib/src/math/Vec3.lua']=(function()\n--- A 3 component vector.\n-- https://github.com/excessive/cpml/blob/master/modules/Vec3.lua\n\nlocal sqrt    = math.sqrt\nlocal cos     = math.cos\nlocal sin     = math.sin\nlocal acos    = math.acos\n\n---@class Vec3\n---@field x number\n---@field y number\n---@field z number\n---@field New fun(a:number, b:number, c:number):Vec3\n---@field unit_x Vec3 X axis of rotation\n---@field unit_y Vec3 Y axis of rotation\n---@field unit_z Vec3 Z axis of rotation\n---@field zero Vec3 Empty vector\n---@field Clone fun():Vec3\n---@field Add fun(a:Vec3, b:Vec3):Vec3\n---@field Sub fun(a:Vec3, b:Vec3):Vec3\n---@field Mul fun(a:Vec3, b:Vec3):Vec3\n---@field Div fun(a:Vec3, b:Vec3):Vec3\n---@field Normalize fun(a:Vec3):Vec3\n---@field NormalizeInPlace fun(a:Vec3):Vec3\n---@field NormalizeLen fun(a:Vec3):Vec3,number\n---@field Trim fun(a:Vec3, len:number):Vec3\n---@field TrimInPlace fun(a:Vec3, len:number):Vec3\n---@field Cross fun(a:Vec3, b:Vec3):Vec3\n---@field Dot fun(a:Vec3, b:Vec3):number\n---@field Len fun(a:Vec3):number\n---@field Len2 fun(a:Vec3):number\n---@field Dist fun(a:Vec3, b:Vec3):number\n---@field Dist2 fun(a:Vec3, b:Vec3):number\n---@field Scale fun(a:Vec3, b:number):Vec3\n---@field ScaleInPlace fun(a:Vec3, b:number):Vec3\n---@field Rotate fun(a:Vec3, phi:number, axis:Vec3):Vec3\n---@field Perpendicular fun(a:Vec3):Vec3\n---@field Lerp fun(a:Vec3, b:Vec3, s:number):Vec3\n---@field Unpack fun(a:Vec3):number,number,number\n---@field ComponentMin fun(a:Vec3, b:Vec3):Vec3\n---@field ComponentMax fun(a:Vec3, b:Vec3):Vec3\n---@field FlipX fun(a:Vec3):Vec3\n---@field FlipY fun(a:Vec3):Vec3\n---@field FlipZ fun(a:Vec3):Vec3\n---@field AngleTo fun(a:Vec3, b:Vec3):number\n---@field AngleToDeg fun(a:Vec3, b:Vec3):number\n---@field ProjectOn fun(a:Vec3, b:Vec3):Vec3\n---@field ProjectOnPlane fun(a:Vec3, planeNormal:Vec3):Vec3\n---@field IsVec3 fun(a:any):boolean\n---@field IsZero fun(a:Vec3):boolean\n---@field ToString fun(a:Vec3):string\n---@operator add(Vec3):Vec3\n---@operator sub(Vec3):Vec3\n---@operator div(Vec3):Vec3\n---@operator div(number):Vec3\n---@operator mul(Vec3):Vec3\n---@operator mul(number):Vec3\n---@operator unm:Vec3\n\nlocal rad2deg = 180 / math.pi\n\nlocal Vec3    = {}\nVec3.__index  = Vec3\n\n\n---Creates a new Vec3\n-- X can be {x, y, z} or {x=x, y=y, z=z} or a scalar to fill the vector eg. {x, x, x}\n---@param x? number|{x:number,y:number,z:number}|number X component\n---@param y? number Y component\n---@param z? number Z component\n---@return Vec3 out\nfunction Vec3.New(x, y, z)\n    local s = {}\n    -- number, number, number\n    if x and y and z then\n        s.x = x\n        s.y = y\n        s.z = z\n        -- {x, y, z} or {x=x, y=y, z=z}\n    elseif type(x) == \"table\" then -- table in vanilla lua, cdata in luajit\n        s.x, s.y, s.z = x.x or x[1], x.y or x[2], x.z or x[3]\n        -- number\n    elseif type(x) == \"number\" then\n        s.x = x\n        s.y = x\n        s.z = x\n    else\n        s.x = 0\n        s.y = 0\n        s.z = 0\n    end\n\n    return setmetatable(s, Vec3)\nend\n\n--- Constants\nVec3.unit_x = Vec3.New(1, 0, 0)\nVec3.unit_y = Vec3.New(0, 1, 0)\nVec3.unit_z = Vec3.New(0, 0, 1)\nVec3.zero   = Vec3.New(0, 0, 0)\n\n--- Clone a vector.\n---@param a Vec3 Vector to be cloned\n---@return Vec3\nfunction Vec3.Clone(a)\n    return Vec3.New(a.x, a.y, a.z)\nend\n\n--- Add two vectors.\n---@param a Vec3 Left hand operand\n---@param b Vec3 Right hand operand\n---@return Vec3 out\nfunction Vec3.Add(a, b)\n    return Vec3.New(\n        a.x + b.x,\n        a.y + b.y,\n        a.z + b.z\n    )\nend\n\n--- Subtract one vector from another.\n-- Order: If a and b are positions, computes the direction and distance from b to a.\n---@param a Vec3 Left hand operand\n---@param b Vec3 Right hand operand\n---@return Vec3 out\nfunction Vec3.Sub(a, b)\n    return Vec3.New(\n        a.x - b.x,\n        a.y - b.y,\n        a.z - b.z\n    )\nend\n\n--- Multiply a vector by another vector.\n-- Component-wise multiplication not matrix multiplication.\n---@param a Vec3 Left hand operand\n---@param b Vec3 Right hand operand\n---@return Vec3 out\nfunction Vec3.Mul(a, b)\n    return Vec3.New(\n        a.x * b.x,\n        a.y * b.y,\n        a.z * b.z\n    )\nend\n\n--- Divide a vector by another.\n-- Component-wise inv multiplication. Like a non-uniform Scale().\n---@param a Vec3 Left hand operand\n---@param b Vec3 Right hand operand\n---@return Vec3 out\nfunction Vec3.Div(a, b)\n    return Vec3.New(\n        a.x / b.x,\n        a.y / b.y,\n        a.z / b.z\n    )\nend\n\n--- Scale a vector to unit length (1).\n---@param a Vec3 vector to Normalize\n---@return Vec3\nfunction Vec3.Normalize(a)\n    if a:IsZero() then\n        return Vec3.New()\n    end\n    return a:Scale(1 / a:Len())\nend\n\n---Normalizes the vector in place\n---@param a Vec3\n---@return Vec3\nfunction Vec3.NormalizeInPlace(a)\n    if a:IsZero() then\n        return a\n    end\n\n    return a:ScaleInPlace(1 / a:Len())\nend\n\n--- Scale a vector to unit length (1), and return the input length.\n---@param a Vec3 vector to normalize\n---@return Vec3, number\nfunction Vec3.NormalizeLen(a)\n    if a:IsZero() then\n        return Vec3.New(), 0\n    end\n    local len = a:Len()\n    return a:Scale(1 / len), len\nend\n\n--- Trim a vector to a given length\n---@param a Vec3 vector to be trimmed\n---@param len number Length to trim the vector to\n---@return Vec3 out\nfunction Vec3.Trim(a, len)\n    return a:Normalize():Scale(math.min(a:Len(), len))\nend\n\n--- Trim the vector, in place, to a given length\n---@param a Vec3 vector to be trimmed\n---@param len number Length to trim the vector to\n---@return Vec3 out\nfunction Vec3.TrimInPlace(a, len)\n    return a:NormalizeInPlace():ScaleInPlace(math.min(a:Len(), len))\nend\n\n---Get the cross product of two vectors.\n---Resulting direction is right-hand rule normal of plane defined by a and b.\n---Magnitude is the area spanned by the parallelograms that a and b span.\n---Order: Direction determined by right-hand rule.\n---@param a Vec3 Left hand operand\n---@param b Vec3 Right hand operand\n---@return Vec3\nfunction Vec3.Cross(a, b)\n    return Vec3.New(\n        a.y * b.z - a.z * b.y,\n        a.z * b.x - a.x * b.z,\n        a.x * b.y - a.y * b.x\n    )\nend\n\n--- Get the dot product of two vectors.\n---@param a Vec3 Left hand operand\n---@param b Vec3 Right hand operand\n---@return number\nfunction Vec3.Dot(a, b)\n    return a.x * b.x + a.y * b.y + a.z * b.z\nend\n\n--- Get the length of a vector.\n---@param a Vec3 Vector to get the length of\n---@return number len\nfunction Vec3.Len(a)\n    return sqrt(a.x * a.x + a.y * a.y + a.z * a.z)\nend\n\n--- Get the squared length of a vector.\n---@param a Vec3 Vector to get the squared length of\n---@return number len\nfunction Vec3.Len2(a)\n    return a.x * a.x + a.y * a.y + a.z * a.z\nend\n\n--- Get the distance between two vectors.\n---@param a Vec3 Left hand operand\n---@param b Vec3 Right hand operand\n---@return number dist\nfunction Vec3.Dist(a, b)\n    local dx = a.x - b.x\n    local dy = a.y - b.y\n    local dz = a.z - b.z\n    return sqrt(dx * dx + dy * dy + dz * dz)\nend\n\n--- Get the squared distance between two vectors.\n---@param a Vec3 Left hand operand\n---@param b Vec3 Right hand operand\n---@return number dist\nfunction Vec3.Dist2(a, b)\n    local dx = a.x - b.x\n    local dy = a.y - b.y\n    local dz = a.z - b.z\n    return dx * dx + dy * dy + dz * dz\nend\n\n--- Scale a vector by a scalar.\n---@param a Vec3 Left hand operand\n---@param b number Right hand operand\n---@return Vec3\nfunction Vec3.Scale(a, b)\n    return Vec3.New(a):ScaleInPlace(b)\nend\n\n--- Scale a vector, in place, by a scalar.\n---@param a Vec3 Left hand operand\n---@param b number Right hand operand\n---@return Vec3\nfunction Vec3.ScaleInPlace(a, b)\n    a.x = a.x * b\n    a.y = a.y * b\n    a.z = a.z * b\n    return a\nend\n\n--- Rotate vector about an axis.\n---@param a Vec3 Vector to rotate\n---@param phi number Angle to rotate vector by (in radians)\n---@param axis Vec3 Axis to rotate by\n---@return Vec3\nfunction Vec3.Rotate(a, phi, axis)\n    if not Vec3.IsVec3(axis) then\n        return a\n    end\n\n    local u = axis:Normalize()\n    local c = cos(phi)\n    local s = sin(phi)\n\n    -- Calculate generalized rotation matrix\n    local m1 = Vec3.New((c + u.x * u.x * (1 - c)), (u.x * u.y * (1 - c) - u.z * s), (u.x * u.z * (1 - c) + u.y * s))\n    local m2 = Vec3.New((u.y * u.x * (1 - c) + u.z * s), (c + u.y * u.y * (1 - c)), (u.y * u.z * (1 - c) - u.x * s))\n    local m3 = Vec3.New((u.z * u.x * (1 - c) - u.y * s), (u.z * u.y * (1 - c) + u.x * s), (c + u.z * u.z * (1 - c)))\n\n    return Vec3.New(\n        a:Dot(m1),\n        a:Dot(m2),\n        a:Dot(m3)\n    )\nend\n\n--- Get the perpendicular vector of a vector.\n---@param a Vec3 Vector to get perpendicular axes from\n---@return Vec3 out\nfunction Vec3.Perpendicular(a)\n    return Vec3.New(-a.y, a.x, 0)\nend\n\n--- Lerp between two vectors.\n---@param a Vec3 Left hand operand\n---@param b Vec3 Right hand operand\n---@param s number Step value\n---@return Vec3 out\nfunction Vec3.Lerp(a, b, s)\n    return a + (b - a) * s\nend\n\n--- Unpack a vector into individual components.\n---@param a Vec3 Vector to unpack\n---@return number x\n---@return number y\n---@return number z\nfunction Vec3.Unpack(a)\n    return a.x, a.y, a.z\nend\n\n--- Return the component-wise minimum of two vectors.\n---@param a Vec3 Left hand operand\n---@param b Vec3 Right hand operand\n---@return Vec3 A vector where each component is the lesser value for that component between the two given vectors.\nfunction Vec3.ComponentMin(a, b)\n    return Vec3.New(math.min(a.x, b.x), math.min(a.y, b.y), math.min(a.z, b.z))\nend\n\n--- Return the component-wise maximum of two vectors.\n---@param a Vec3 Left hand operand\n---@param b Vec3 Right hand operand\n---@return Vec3 A vector where each component is the lesser value for that component between the two given vectors.\nfunction Vec3.ComponentMax(a, b)\n    return Vec3.New(math.max(a.x, b.x), math.max(a.y, b.y), math.max(a.z, b.z))\nend\n\n-- Negate x axis only of vector.\n---@param a Vec3 Vector to x-flip.\n---@return Vec3\nfunction Vec3.FlipX(a)\n    return Vec3.New(-a.x, a.y, a.z)\nend\n\n-- Negate y axis only of vector.\n---@param a Vec3 Vector to y-flip.\n---@return Vec3\nfunction Vec3.FlipY(a)\n    return Vec3.New(a.x, -a.y, a.z)\nend\n\n-- Negate z axis only of vector.\n---@param a Vec3 Vector to z-flip.\n---@return Vec3 z-flipped vector\nfunction Vec3.FlipZ(a)\n    return Vec3.New(a.x, a.y, -a.z)\nend\n\n---Gets the angle to b from a\n---@param a Vec3\n---@param b Vec3\n---@return number\nfunction Vec3.AngleTo(a, b)\n    local v = a:Normalize():Dot(b:Normalize())\n    return acos(v)\nend\n\n---Gets the angle to b from a in degrees\n---@param a Vec3\n---@param b Vec3\n---@return number\nfunction Vec3.AngleToDeg(a, b)\n    return a:AngleTo(b) * rad2deg\nend\n\n---Projects vector a onto b\n---@param a Vec3\n---@param v Vec3\n---@return Vec3\nfunction Vec3.ProjectOn(a, v)\n    -- (self * v) * v / v:Len2()\n    local s = (a.x * v.x + a.y * v.y + a.z * v.z) / (v.x * v.x + v.y * v.y + v.z * v.z)\n    return Vec3.New(s * v.x, s * v.y, s * v.z)\nend\n\n---Project a on plane containing origin\n---@param a Vec3\n---@param planeNormal Vec3\n---@return Vec3\nfunction Vec3.ProjectOnPlane(a, planeNormal)\n    return a - planeNormal * a:Dot(planeNormal)\nend\n\n--- Return a boolean showing if a table is or is not a Vec3.\n---@param a any Vector to be tested\n---@return boolean is_vec3\nfunction Vec3.IsVec3(a)\n    return type(a) == \"table\" and\n        type(a.x) == \"number\" and\n        type(a.y) == \"number\" and\n        type(a.z) == \"number\"\nend\n\n--- Return a boolean showing if a table is or is not a zero Vec3.\n---@param a Vec3 Vector to be tested\n---@return boolean IsZero\nfunction Vec3.IsZero(a)\n    return a.x == 0 and a.y == 0 and a.z == 0\nend\n\n--- Return a formatted string.\n---@param a Vec3 Vector to be turned into a string\n---@return string formatted\nfunction Vec3.ToString(a)\n    return string.format(\"(%+0.3f,%+0.3f,%+0.3f)\", a.x, a.y, a.z)\nend\n\nfunction Vec3.__tostring(a)\n    return a:ToString()\nend\n\n---Negation operator\n---@param a Vec3\n---@return Vec3\nfunction Vec3.__unm(a)\n    return Vec3.New(-a.x, -a.y, -a.z)\nend\n\n---Equality operator\n---@param a Vec3\n---@param b Vec3\n---@return boolean\nfunction Vec3.__eq(a, b)\n    if not Vec3.IsVec3(a) or not Vec3.IsVec3(b) then\n        return false\n    end\n    return a.x == b.x and a.y == b.y and a.z == b.z\nend\n\n---Addition operator\n---@param a Vec3\n---@param b Vec3\n---@return unknown\nfunction Vec3.__add(a, b)\n    return a:Add(b)\nend\n\n---Subtraction operator\n---@param a Vec3\n---@param b Vec3\n---@return Vec3\nfunction Vec3.__sub(a, b)\n    return a:Sub(b)\nend\n\n---Multiplication operator\n---@param a Vec3|number\n---@param b Vec3|number\n---@return Vec3\nfunction Vec3.__mul(a, b)\n    local aIsVec3 = Vec3.IsVec3(a)\n    local bIsVec3 = Vec3.IsVec3(b)\n    if aIsVec3 and bIsVec3 then\n        ---@cast b Vec3\n        return a:Mul(b)\n    end\n\n    -- The case when doing <number> * Vec3 a opposed to Vec3 * <number>\n    if type(a) == \"number\" and bIsVec3 then\n        return b:Scale(a)\n    end\n\n    ---@cast b number\n    return a:Scale(b)\nend\n\n---Division operator\n---@param a Vec3\n---@param b Vec3\n---@return Vec3\nfunction Vec3.__div(a, b)\n    if Vec3.IsVec3(b) then\n        return a:Div(b)\n    end\n\n    return a:Scale(1 / b)\nend\n\nreturn Vec3\n\nend)\npackage.preload['YFS:../e/lib/src/system/Taskmanager.lua']=(function()\n---@module \"Task\"\n\n---@class Taskmanager\n---@field Instance fun():Taskmanager Returns the Taskmanager singleton\n---@field Add fun(t:Task) Adds a task\n---@field Count fun():number Returns the number of tasks\n\n\nlocal Taskmanager = {}\nTaskmanager.__index = {}\nlocal instance\n\nfunction Taskmanager.Instance()\n    if instance then\n        return instance\n    end\n\n    local s = {}\n    local tasks = {} ---@type Task[]\n\n    ---@param task Task\n    function s.Add(task)\n        tasks[#tasks + 1] = task\n    end\n\n    function s.Count()\n        return #tasks\n    end\n\n    local function update()\n        local keep = {}\n        for i, t in ipairs(tasks) do\n            local curr = tasks[i]\n            if curr.Run() == TaskState.Dead then\n                if not curr.Success() then\n                    if curr.catcher then\n                        curr.catcher(curr)\n                    end\n                end\n\n                if curr.finalizer then\n                    curr.finalizer(curr)\n                end\n            else\n                keep[#keep + 1] = curr\n            end\n        end\n\n        tasks = keep\n    end\n\n    instance = setmetatable(s, Taskmanager)\n\n    system:onEvent(\"onUpdate\", update)\n\n    return instance\nend\n\nreturn Taskmanager\n\nend)\npackage.preload['YFS:../e/lib/src/system/Task.lua']=(function()\nlocal taskmanager = require('YFS:../e/lib/src/system/Taskmanager.lua').Instance()\nlocal status = coroutine.status\nlocal resume = coroutine.resume\n\n---@enum TaskState\nTaskState = {\n    Dead = 0,\n    Running = 1\n}\n\n---@alias thenFunc fun(...:any): any\n\n---@class Task\n---@field New fun(taskName:string, f:thenFunc, arg1:any?, ...:any[]?):Task Creates a new Task and runs the function ansync.\n---@field Run fun():TaskState The status of the task\n---@field Success fun():boolean Returns true if the task succeeded\n---@field Result fun():any|nil Returns the return value of the task.\n---@field Error fun():string|nil Returns the error message value of the task, if an error is raised.\n---@field Exited fun():boolean Returns true when the task has completed its work (or otherwise exited)\n---@field Then fun(f:thenFunc, thenArg1:any?, ...:any?):Task Chains another call to be run when the previous one has completed.\n---@field Catch fun(f:fun(t:Task)):Task Sets an error handler, called if the task raises an error\n---@field Finally fun(f:fun(t:Task)):Task Sets a finalizer, always called before the task is removed from the task manager.\n---@field Name fun():string Returns the name of the Task\n---@field catcher fun(t:Task)\n---@field finalizer fun(t:Task)\n\nlocal Task = {}\nTask.__index = Task\n\n---Create a new task\n---@param taskName string The name of the task\n---@param toRun fun():any\n---@param arg1 any? First argument to function to be run\n---@param ... any?[] Other arguments to be passed to the function to be run\n---@return Task\nfunction Task.New(taskName, toRun, arg1, ...)\n    local s = {\n        catcher = nil, ---@type fun(f:Task):Task\n        finalizer = nil ---@type fun(f:Task):Task\n    }\n\n    local thenFunc = {} --- @type { co:thread, args:any[] }[]\n\n    local function newThen(fun, ...)\n        thenFunc[#thenFunc + 1] = { co = coroutine.create(fun), args = { ... } }\n    end\n\n    local resultValue ---@type any|nil\n    local errorMessage ---@type string|nil\n    local success = true\n    local exited = false\n    local name = taskName\n\n    ---Moves to next call when needed\n    local function next()\n        if #thenFunc == 0 then\n            return TaskState.Dead\n        end\n\n        local dead = status(thenFunc[1].co) == \"dead\"\n\n        if dead then\n            -- Move to next, or are we done?\n            table.remove(thenFunc, 1)\n            exited = #thenFunc == 0\n            if exited then\n                return TaskState.Dead\n            end\n        end\n\n        return TaskState.Running\n    end\n\n    function s.Run()\n        local result\n        if next() == TaskState.Running then\n            local t = thenFunc[1]\n            success, result = resume(t.co, table.unpack(t.args))\n        end\n\n        if success then\n            resultValue = result\n            return next()\n        end\n\n        errorMessage = result\n        return TaskState.Dead\n    end\n\n    ---Chain another function to run after the previous one is completed\n    ---@param thenfunc fun(...:any[]?)\n    ---@param thenArg1 any? First argument to function to be run\n    ---@param ... any? Other arguments to be passed to the function to be run\n    function s.Then(thenfunc, thenArg1, ...)\n        newThen(thenfunc, thenArg1, ...)\n        return s\n    end\n\n    ---Sets an error handler\n    ---@param catcher fun(t:Task)\n    function s.Catch(catcher)\n        if type(catcher) ~= \"function\" then\n            error(\"Can only add function as catchers\")\n        end\n\n        s.catcher = catcher\n        return s\n    end\n\n    ---Sets a finalizer\n    ---@param finalizer fun(t:Task)\n    function s.Finally(finalizer)\n        if type(finalizer) ~= \"function\" then\n            error(\"Can only add function as catchers\")\n        end\n\n        s.finalizer = finalizer\n        return s\n    end\n\n    ---Indicates success of failure\n    ---@return boolean\n    function s.Success()\n        return success\n    end\n\n    ---The result of the task\n    ---@return any|nil\n    function s.Result()\n        return resultValue\n    end\n\n    ---The error of the task\n    ---@return string|nil\n    function s.Error()\n        return errorMessage\n    end\n\n    ---Indicates if the task has completed its run\n    ---@return boolean\n    function s.Exited()\n        return exited\n    end\n\n    ---Gets the task name\n    ---@return string\n    function s.Name()\n        return name\n    end\n\n    newThen(toRun, arg1, ...)\n    setmetatable(s, Task)\n\n    taskmanager.Add(s)\n\n    return s\nend\n\n---Waits for the task to complete\n---@param task Task\n---@return any\nfunction Task.Await(task)\n    while not task.Exited() do\n        coroutine.yield()\n    end\n\n    return task.Result()\nend\n\nreturn Task\n\nend)\npackage.preload['YFS:../e/lib/src/util/Table.lua']=(function()\n---Get the length of the table. Operator \"#\" does not function on non-arrays or arrays with nil values.\n---@param t table\n---@return integer\nTableLen = function(t)\n    local n = 0\n\n    for _ in pairs(t) do\n        n = n + 1\n    end\n\n    return n\nend\n\n---Revereses the list in-place\n---@param list any[]\nReverseInplace = function(list)\n    local n = #list\n\n    for i = 1, n / 2 do\n        list[i], list[n] = list[n], list[i]\n        n = n - 1\n    end\nend\n\n---Copies elements from one list to another\n---@param from table\n---@param to table\nCopyList = function(to, from)\n    local start = #to\n    for i, item in ipairs(from) do\n        to[start + i] = item\n    end\nend\n\n-- http://lua-users.org/wiki/CopyTable\n-- It is important that only one argument is supplied to this version of the deepcopy function.\n-- Otherwise, it will attempt to use the second argument as a table, which can have unintended consequences.\nlocal function deepcopy(orig, copies)\n    copies = copies or {}\n    local orig_type = type(orig)\n    local copy\n    if orig_type == 'table' then\n        if copies[orig] then\n            copy = copies[orig]\n        else\n            copy = {}\n            copies[orig] = copy\n            for orig_key, orig_value in next, orig, nil do\n                copy[deepcopy(orig_key, copies)] = deepcopy(orig_value, copies)\n            end\n            setmetatable(copy, deepcopy(getmetatable(orig), copies))\n        end\n    else -- number, string, boolean, etc\n        copy = orig\n    end\n    return copy\nend\n\n---Deeply copies the provided table\n---@generic T\n---@param o T\n---@return T\nDeepCopy = function(o)\n    return deepcopy(o)\nend\n\nend)\npackage.preload['YFS:flight/route/PointOptions.lua']=(function()\nlocal _ = require('YFS:../e/lib/src/util/Table.lua')\n\n---@class PointOptions\n---@field New fun():PointOptions Creates a new PointOptions\n---@field Set fun(name:string, value:any) Sets an option value\n---@field Get fun(opt:string, defaultValue:any): any a Gets an option value\n---@field Data fun():table<string, any> Gets the options as a table\n---@field Clone fun():PointOptions Clones the options\n\nlocal PointOptions = {}\nPointOptions.__index = PointOptions\n\n---Creates a new PointOptions instance\n---@param optionData? table An existing table holding option data or nil\n---@return PointOptions\nfunction PointOptions.New(optionData)\n    local s = {}\n    local options = DeepCopy(optionData or {})\n\n    ---@param opt string The name of the option to set\n    ---@param value string|number The value of the option\n    function s.Set(opt, value)\n        options[opt] = value\n    end\n\n    ---@param opt string The name of the option to get\n    ---@param default string|number The default value if the option doesn't exist\n    ---@return string|number # The option value, or the default value\n    function s.Get(opt, default)\n        local curr = options[opt]\n        if curr ~= nil then\n            return curr\n        end\n        return default\n    end\n\n    ---@return table<string, any> # The options as a table\n    function s.Data()\n        return options\n    end\n\n    ---Clones the options\n    ---@return PointOptions\n    function s.Clone()\n        return PointOptions.New(DeepCopy(options))\n    end\n\n    return setmetatable(s, PointOptions)\nend\n\n--- Unit vector in world coordinates in format {x,y,z}. Causes the direction of the construct to be locked to the direction stored in the point throughout the approach to the point.\nPointOptions.LOCK_DIRECTION = \"lockDir\"\n--- Meters. How close must the construct be to consider the point reached.\nPointOptions.MARGIN = \"margin\"\n--- m/s. Desired speed when the point is reached.\nPointOptions.FINAL_SPEED = \"finalSpeed\"\n--- m/s. Desired maximal speed. (equal or less than finalSpeed)\nPointOptions.MAX_SPEED = \"maxSpeed\"\n-- Boolean. If true, final speed takese precedence over last-point in route check.\nPointOptions.FORCE_FINAL_SPEED = \"forcefinalspeed\"\n-- Boolean. If true, the point can be skipped while traveling along the route\nPointOptions.SKIPPABLE = \"skippable\"\n-- Boolean. If true, the point is not shown on the waypoint page\nPointOptions.SELECTABLE = \"selectable\"\n-- Boolean. If true, the point is considered to have gates that needs opening or closing\nPointOptions.GATE = \"gate\"\n-- Boolean. If true, forces alignment along vertical up\nPointOptions.FORCE_VERT = \"forceVert\"\n\nPointOptions.ALL = { PointOptions.LOCK_DIRECTION, PointOptions.MARGIN, PointOptions.FINAL_SPEED, PointOptions.MAX_SPEED,\n    PointOptions.FORCE_FINAL_SPEED, PointOptions.SKIPPABLE, PointOptions.SELECTABLE, PointOptions.GATE,\n    PointOptions.FORCE_VERT }\n\nreturn PointOptions\n\nend)\npackage.preload['YFS:flight/route/Point.lua']=(function()\nlocal PointOptions = require('YFS:flight/route/PointOptions.lua')\n\n-- This class represents a position and behavior in a route.\n-- Keep data as small as possible.\n\n---@alias PointPOD {pos:string, waypointRef?:string, opt:table<string, any>}\n\n---@class Point Represents a point/waypoint in a route\n---@field New fun(pos:string, waypointRef?:string, options?:PointOptions):Point\n---@field Pos fun():string\n---@field HasWaypointRef fun():boolean\n---@field WaypointRef fun():string|nil\n---@field SetWaypointRef fun(ref:string)\n---@field Persist fun():PointPOD\n---@field Options fun():PointOptions\n---@field SetOptions fun(newOptions:PointOptions)\n---@field LoadFromPOD fun(source:PointPOD):Point\nlocal Point = {}\nPoint.__index = Point\n\n---Creates a new Point\n---@param pos string A ::pos{} string\n---@param waypointRef? string A named waypoint reference or nil\n---@param options? PointOptions Point options, or nil\n---@return Point\nfunction Point.New(pos, waypointRef, options)\n    local s = {}\n\n    local position = pos -- ::pos{} string\n    local wpRef = waypointRef\n    local opt = options or PointOptions.New()\n\n    ---Returns the ::pos{} string. When retrieved from a loaded route, this is guaranteed to be populated.\n    ---@return string\n    function s.Pos()\n        return position\n    end\n\n    ---Indicates if the point has a waypoint reference\n    ---@return boolean\n    function s.HasWaypointRef()\n        return wpRef ~= nil and #wpRef > 0\n    end\n\n    ---Returns the name of the waypoint reference\n    ---@return string|nil\n    function s.WaypointRef()\n        return wpRef\n    end\n\n    ---Sets the named waypoint reference\n    ---@param ref string\n    function s.SetWaypointRef(ref)\n        wpRef = ref\n    end\n\n    ---Returns a persistable table version of the point\n    ---@return PointPOD\n    function s.Persist()\n        local pod ---@type PointPOD\n        pod = {\n            pos = position,\n            waypointRef = wpRef,\n            opt = opt.Data() or {}\n        }\n\n        return pod\n    end\n\n    ---Returns the options for the point\n    ---@return PointOptions\n    function s.Options()\n        return opt\n    end\n\n    ---Sets new options\n    ---@param newOptions PointOptions\n    function s.SetOptions(newOptions)\n        opt = newOptions\n    end\n\n    return setmetatable(s, Point)\nend\n\n---Loads data from a PointPOD\n---@param source PointPOD\nfunction Point.LoadFromPOD(source)\n    return Point.New(source.pos, source.waypointRef, PointOptions.New(source.opt))\nend\n\nreturn Point\n\nend)\npackage.preload['YFS:../e/lib/src/system/Stopwatch.lua']=(function()\n---@class Stopwatch\n---@field Start fun() Starts the stopwatch, or leaves it running if it already is.\n---@field Restart fun() Restarts the stopwatch\n---@field Stop fun() Stops the stopwatch\n---@field Reset fun() Resets the stopwatch to a state as if it never had been started\n---@field Elapsed fun():number Returns the number of seconds the stopwatch has been running.\n---@field IsRunning fun():boolean Returns true if the stopwatch is currently running, i.e. started, and not stopped.\n\nlocal Stopwatch = {}\nStopwatch.__index = Stopwatch\n\n---Creates a new Stopwatch\n---@return Stopwatch\nfunction Stopwatch.New()\n    local s = {}\n\n    local utc = system.getUtcTime\n    local startTime = nil\n    local stopTime = nil\n\n    ---Starts the stopwatch, or leaves it running if it already is.\n    function s.Start()\n        if not s.IsRunning() then\n            startTime = utc()\n            stopTime = nil\n        end\n    end\n\n    ---Restarts the stopwatch\n    function s.Restart()\n        s.Stop()\n        s.Start()\n    end\n\n    ---Stops the stopwatch\n    function s.Stop()\n        stopTime = utc()\n    end\n\n    ---Resets the stopwatch, Elapsed() will return 0 after this call\n    function s.Reset()\n        startTime = nil\n        stopTime = nil\n    end\n\n    ---@return number # Elapsed time, in seconds with fractions.\n    function s.Elapsed()\n        if startTime == nil then\n            return 0\n        elseif stopTime == nil then\n            return utc() - startTime\n        else\n            return stopTime - startTime\n        end\n    end\n\n    ---Checks if the stopwatch is running\n    ---@return boolean\n    function s.IsRunning()\n        return startTime ~= nil and stopTime == nil\n    end\n\n    return setmetatable(s, Stopwatch)\nend\n\nreturn Stopwatch\n\nend)\npackage.preload['YFS:../e/lib/src/abstraction/Vehicle.lua']=(function()\nlocal V3                      = require('YFS:../e/lib/src/math/Vec3.lua').New\nlocal core                    = library.getCoreUnit()\n\n---@alias fun3 fun():Vec3\n---@alias funn fun():number\n---@alias funb fun():boolean\n---@alias VPosition {Current:fun3}\n---@alias VPlayer {position:{Current:fun3, orientation:{Forward:fun3, Up:fun3, Right:fun3, IsFirstPerson:funb}}}}\n---@alias VSpeed {MaxSpeed:funn}\n\n---@class Vehicle\n---@field position VPosition\n---@field player VPlayer\n---@field speed VSpeed\n\nlocal ct                      = construct\n\nlocal Vehicle                 = {}\nVehicle.__index               = Vehicle\n\nlocal atmoToSpaceDensityLimit = 0.09 -- At what density level we consider space to begin. Densities higher than this is atmo.\n\nlocal vehicle                 = {\n    acceleration = {\n        Angular = function()\n            return V3(ct.getWorldAngularAcceleration())\n        end,\n    },\n    player = {\n        position = {\n            Current = function()\n                return V3(player.getWorldPosition())\n            end\n        },\n        orientation = {\n            Up = function()\n                return V3(player.getWorldUp())\n            end\n        },\n    },\n}\n\nCurrent                       = function() return V3(ct.getWorldPosition()) end\nUp                            = function() return V3(ct.getWorldOrientationUp()) end\nRight                         = function() return V3(ct.getWorldOrientationRight()) end\nForward                       = function() return V3(ct.getWorldOrientationForward()) end\n\nLocalUp                       = function() return V3(ct.getOrientationUp()) end\nLocalRight                    = function() return V3(ct.getOrientationRight()) end\nLocalForward                  = function() return V3(ct.getOrientationForward()) end\n\nAtmoDensity                   = unit.getAtmosphereDensity\nIsInAtmo                      = function() return AtmoDensity() > atmoToSpaceDensityLimit end\nIsInSpace                     = function() return not IsInAtmo() end\nGravityDirection              = function() return V3(core.getWorldVertical()) end\nG                             = core.getGravityIntensity\nAirFrictionAcceleration       = function() return V3(ct.getWorldAirFrictionAcceleration()) end\n\nMaxSpeed                      = function()\n    return IsInAtmo() and ct.getFrictionBurnSpeed() * 0.99 or ct.getMaxSpeed()\nend\n\nAcceleration                  = function() return V3(ct.getWorldAcceleration()) end\nVelocity                      = function() return V3(ct.getWorldAbsoluteVelocity()) end\nLocalAngVel                   = function() return V3(ct.getAngularVelocity()) end\nLocalAngAcc                   = function() return V3(ct.getAngularAcceleration()) end\n\n-- player.isFrozen() can return nil, reported to NQ in ticket 81865\n-- Their answer is \"don't call from flush\"\nIsFrozen                      = player.isFrozen\n\nTotalMass                     = ct.getTotalMass\n\nreturn vehicle\n\nend)\npackage.preload['YFS:YFSConstants.lua']=(function()\nlocal Vec3 = require('YFS:../e/lib/src/math/Vec3.lua')\n\nlocal constants = {\n    ticksPerSecond = 60.0,\n    flushTick = 1 / 60.0,\n    universe = {\n        up = Vec3.New(0, 1, 0),\n        forward = Vec3.New(1, 0, 0),\n        right = Vec3.New(0, 0, 1)\n    },\n    direction = {\n        counterClockwise = 1,\n        clockwise = -1,\n        rightOf = 1,\n        leftOf = -1,\n        still = 0\n    },\n    flight = {\n        speedPid = {\n            p = 5,\n            i = 0.005,\n            d = 100,\n            a = 0.99\n        },\n        axis = {\n            light = {\n                p = 10,\n                i = 0,\n                d = 800,\n                a = 0.1\n            },\n            heavy = {\n                p = 6,\n                i = 1,\n                d = 1600,\n                a = 0.1\n            }\n        },\n        throttleStep = 10,                   -- percent\n        defaultMargin = 0.1,                 -- meter\n        defaultStartEndMargin = 0.3,         -- meter\n        defaultTurnAngle = 1,                -- degrees\n        lightConstructMassThreshold = 10000, -- ten tons\n        minimumPathCheckOffset = 2,          -- meters\n        pathAlignmentAngleLimit = 10,        -- degrees\n        pathAlignmentDistanceLimit = 200     -- meters\n\n    },\n    route = {\n        routeStartDistanceLimit = 10,    -- meters\n        autoShutdownFloorDistance = 5,   -- meters\n        yawAlignmentThrustLimiter = 3,   -- degrees\n        pitchAlignmentThrustLimiter = 5, -- degrees\n        rollAlignmentThrustLimiter = 5,  -- degrees\n        gateControlDistance = 5          -- meters\n    },\n    widgets = {\n        showOnStart = false\n    }\n}\n\nreturn constants\n\nend)\npackage.preload['YFS:../e/lib/src/debug/Log.lua']=(function()\n---@class Log\n---@field Instance fun():Log\n---@field SetLevel fun(level:LogLevel)\n---@field Info fun(...:any)\n---@field Warning fun(...:any)\n---@field Error fun(...:any)\n---@field Debug fun(...:any)\n\nlocal Log = {}\nLog.__index = Log\n\n---@enum LogLevel\nLVL = {\n    OFF = 0,\n    INFO = 2,\n    ERROR = 3,\n    WARNING = 4,\n    DEBUG = 5\n}\n\nlocal instance ---@type Log\n\n---@return Log\nfunction Log.Instance()\n    if instance then return instance end\n    local s = {}\n    local level = LVL.WARNING\n\n    local function getLevelStr(lvl)\n        if lvl == LVL.DEBUG then\n            return \"D\"\n        elseif lvl == LVL.ERROR then\n            return \"E\"\n        elseif lvl == LVL.INFO then\n            return \"I\"\n        elseif lvl == LVL.WARNING then\n            return \"W\"\n        else\n            return \"UNKOWN\"\n        end\n    end\n\n    local function formatValues(...)\n        local parts = {}\n        local args = { ... }\n\n        for i = 1, #args, 1 do\n            local v\n\n            v = args[i]\n            if v == nil then\n                v = \"\"\n            end\n\n            local r = \"\"\n\n            local t = type(v)\n            if t == \"string\" then\n                r = string.format(\"%s\", v)\n            elseif t == \"number\" then\n                r = string.format(\"%s\", tonumber(v))\n            elseif t == \"boolean\" then\n                r = tostring(v)\n            elseif t == \"function\" then\n                r = tostring(v)\n            elseif t == \"table\" then\n                r = \"{\"\n                for key, data in pairs(v) do\n                    r = r .. formatValues(key, \": \", data, \",\")\n                end\n                r = r .. \"}\"\n            else\n                r = \"unprintable: '\" .. t .. \"'\"\n            end\n\n            parts[#parts + 1] = string.format(\"%s\", r)\n        end\n\n        return table.concat(parts)\n    end\n\n    ---@param logLevel LogLevel\n    ---@param ... any\n    function s.print(logLevel, ...)\n        if logLevel <= level then\n            system.print(string.format(\"[%s] %s\", getLevelStr(logLevel), formatValues(...)))\n        end\n    end\n\n    ---@param logLevel LogLevel\n    function s.SetLevel(logLevel)\n        level = logLevel\n    end\n\n    ---@param msg any\n    ---@param ... any\n    function s.Info(msg, ...)\n        s.print(LVL.INFO, msg, ...)\n    end\n\n    ---comment\n    ---@param msg any\n    ---@param ... any\n    function s.Warning(msg, ...)\n        s.print(LVL.WARNING, msg, ...)\n    end\n\n    ---@param msg any\n    ---@param ... any\n    function s.Error(msg, ...)\n        s.print(LVL.ERROR, msg, ...)\n    end\n\n    ---@param msg any\n    ---@param ... any\n    function s.Debug(msg, ...)\n        s.print(LVL.DEBUG, msg, ...)\n    end\n\n    return setmetatable(s, Log)\nend\n\nreturn Log\n\nend)\npackage.preload['YFS:../e/lib/src/util/StringUtil.lua']=(function()\nlocal SU = {}\n\nfunction SU.CoSplit(str, pat)\n   -- http://lua-users.org/wiki/SplitJoin\n\n   local t = {} -- NOTE: use {n = 0} in Lua-5.0\n   local fpat = \"(.-)\" .. pat\n   local last_end = 1\n   local s, e, cap = str:find(fpat, 1)\n   while s do\n      if s ~= 1 or cap ~= \"\" then\n         table.insert(t, cap)\n      end\n      last_end = e + 1\n      s, e, cap = str:find(fpat, last_end)\n      coroutine.yield()\n   end\n   if last_end <= #str then\n      cap = str:sub(last_end)\n      table.insert(t, cap)\n   end\n   return t\nend\n\nfunction SU.Round(num, numDecimalPlaces)\n   local mult = 10 ^ (numDecimalPlaces or 0)\n   return math.floor(num * mult + 0.5) / mult\nend\n\nfunction SU.RemoveDecimal(s)\n   return s:gsub(\"%.%d\", \"\")\nend\n\nfunction PadLeft(s, width)\n   if #s < width then\n      s = string.rep('&nbsp;', width - #s) .. s\n   end\n\n   return s\nend\n\nfunction SU.FormatThousands(value)\n   local formatted = value\n   local k\n   local done = false\n\n   while not done do\n      formatted, k = string.gsub(formatted, \"^(-?%d+)(%d%d%d)\", '%1 %2')\n      done = k == 0\n   end\n\n   return formatted\nend\n\nfunction SU.Trim(s)\n   return s:match \"^%s*(.-)%s*$\"\nend\n\n---Splits the string into parts, honoring \" and ' as quote chars to make multi-word arguments\n---@param s string\n---@return string[]\nfunction SU.SplitQuoted(s)\n   local function isQuote(c) return c == '\"' or c == \"'\" end\n\n   local function isSpace(c) return c == \" \" end\n\n   local function add(target, v)\n      v = SU.Trim(v)\n      if v:len() > 0 then\n         table.insert(target, #target + 1, v)\n      end\n   end\n\n   local inQuote = false\n   local parts = {} ---@type string[]\n   local current = \"\"\n\n   for c in s:gmatch(\".\") do\n      if isSpace(c) and not inQuote then\n         -- End of non-quoted part\n         add(parts, current)\n         current = \"\"\n      elseif isQuote(c) then\n         if inQuote then\n            -- End of quote\n            add(parts, current)\n            current = \"\"\n            inQuote = false\n         else\n            -- End current, start quoted\n            add(parts, current)\n            current = \"\"\n            inQuote = true\n         end\n      else\n         current = current .. c\n      end\n   end\n\n   -- Add whatever is at the end of the string.\n   add(parts, current)\n\n   return parts\nend\n\n---Returns true if the original string starts with the prefix\n---@param original string\n---@param prefix string\nfunction SU.StartsWith(original, prefix)\n   return original:find(prefix, 1, true) == 1\nend\n\nfunction SU.EndsWith(str, ending)\n   return ending == \"\" or str:sub(- #ending) == ending\nend\n\n---@param original string\n---@param prefix string\nfunction SU.RemovePrefix(original, prefix)\n   if SU.StartsWith(original, prefix) then\n      return original:sub(#prefix + 1, #original)\n   else\n      return original\n   end\nend\n\nreturn SU\n\nend)\npackage.preload['YFS:../e/lib/src/commandline/Types.lua']=(function()\nlocal log = require('YFS:../e/lib/src/debug/Log.lua').Instance()\n\n---@alias ArgumentValueTypes nil|boolean|number|string\n\n---@enum ArgTypes\nlocal argType = {\n    EMPTY = 0,\n    BOOLEAN = 1,\n    NUMBER = 2,\n    STRING = 3,\n    EMPTY_BOOLEAN = 4\n}\n\n---Parses the raw input returning status, value\n---@param wantedType ArgTypes\n---@param raw string\n---@return boolean, ArgumentValueTypes\nfunction argType.parseValue(wantedType, raw)\n    if wantedType == argType.EMPTY and raw == nil then\n        return true, \"\"\n    elseif raw == nil then\n        return true, raw\n    end\n\n    if wantedType == argType.BOOLEAN then\n        if raw == \"true\" or raw == \"1\" then\n            return true, true\n        elseif raw == \"false\" or raw == \"0\" then\n            return true, false\n        else\n            log.Error(\"Not a boolean: \", raw)\n        end\n    elseif wantedType == argType.NUMBER then\n        local match = string.match(raw, \"([+-]?%d*%.?%d+)\")\n        if match == nil then\n            log.Error(\"Not a number: \", raw)\n        else\n            return true, tonumber(match)\n        end\n    else\n        return true, raw\n    end\n\n    return false, nil\nend\n\nreturn argType\n\nend)\npackage.preload['YFS:../e/lib/src/commandline/Option.lua']=(function()\nlocal log = require('YFS:../e/lib/src/debug/Log.lua').Instance()\nlocal argType = require('YFS:../e/lib/src/commandline/Types.lua')\n\n---@class Option\n---@field New fun(name:string):Option\n---@field AsString fun():Option\n---@field AsNumber fun():Option\n---@field AsBoolean fun():Option\n---@field AsEmptyBoolean fun():Option\n---@field Must fun():Option\n---@field Default fun(v:ArgumentValueTypes):Option\n---@field Parse fun(args:string[], target:table<string,ArgumentValueTypes>):boolean\n\nlocal Option = {}\nOption.__index = Option\n\n---Creates a new command option\n---@param name string The option name, such as \"-opt\", \"--opt\" or just \"opt\". Im the latter case a \"-\" is added to the name.\n---@return Option\nfunction Option.New(name)\n    if name:sub(1, 1) ~= \"-\" then\n        name = \"-\" .. name\n    end\n\n    local s = {}\n    local sanitizedName = name:gsub(\"^%-*\", \"\")\n    local optType = argType.EMPTY\n    local mandatory = false\n    local default = nil\n\n    ---Marks option to be a string\n    ---@return Option\n    function s.AsString()\n        optType = argType.STRING\n        return s\n    end\n\n    ---Mark option as number\n    ---@return Option\n    function s.AsNumber()\n        optType = argType.NUMBER\n        return s\n    end\n\n    ---Mark option as boolean\n    ---@return Option\n    function s.AsBoolean()\n        optType = argType.BOOLEAN\n        return s\n    end\n\n    ---Mark option as mandatory\n    ---@return Option\n    function s.Must()\n        mandatory = true\n        return s\n    end\n\n    ---Mark option as empty\n    ---@return Option\n    function s.AsEmptyBoolean()\n        optType = argType.EMPTY_BOOLEAN\n        return s\n    end\n\n    ---Set default value for option\n    ---@param v ArgumentValueTypes\n    function s.Default(v)\n        default = v\n        return s\n    end\n\n    ---Parses the arguments, putting the found values in the the target in a key:value fashion, with sanitized key names.\n    ---@param args string[]\n    ---@param target table<string, ArgumentValueTypes>\n    ---@return boolean\n    function s.Parse(args, target)\n        -- Find the argument in the input data\n        for i, key in ipairs(args) do\n            if key == name then\n                if optType == argType.EMPTY_BOOLEAN then\n                    target[sanitizedName] = true\n                    table.remove(args, i)\n                elseif i + 1 <= #args then          -- Next value is the argument, if it exists\n                    table.remove(args, i)           -- Remove the arg itself\n                    local v = table.remove(args, i) -- Remove and store the value\n\n                    local ok\n                    ok, target[sanitizedName] = argType.parseValue(optType, v)\n                    if not ok then\n                        return false\n                    end\n                elseif mandatory then\n                    log.Error(\"Missing value for mandatory option \", key)\n                    return false\n                end\n\n                break\n            end\n        end\n\n        if optType == argType.EMPTY_BOOLEAN and target[sanitizedName] == nil then\n            target[sanitizedName] = false\n        end\n\n        if target[sanitizedName] == nil and default ~= nil then\n            target[sanitizedName] = default\n        end\n\n        local res = (not mandatory) or target[sanitizedName] ~= nil\n\n        if not res then\n            log.Error(\"Option \", name, \" not complete\")\n        end\n        return res\n    end\n\n    return setmetatable(s, Option)\nend\n\nreturn Option\n\nend)\npackage.preload['YFS:../e/lib/src/util/Calc.lua']=(function()\nlocal Vec3 = require('YFS:../e/lib/src/math/Vec3.lua')\n\nlocal solve3 = library.systemResolution3\n\nlocal atan = math.atan\nlocal cos = math.cos\nlocal acos = math.acos\nlocal max = math.max\nlocal min = math.min\nlocal abs = math.abs\nlocal sqrt = math.sqrt\nlocal deg2rad = math.pi / 180\nlocal rad2deg = 180 / math.pi\n\nlocal calc = {}\n\n---Returns the absolute difference between a and b\n---@param a any Value a to compare\n---@param b any Value b to compare\n---@return any Absolute difference between the two numbers.\ncalc.AbsDiff = function(a, b)\n    a, b = abs(a), abs(b)\n    return max(a, b) - min(a, b)\nend\n\ncalc.Round = function(number, decimalPlaces)\n    local mult = 10 ^ (decimalPlaces or 0)\n    return math.floor(number * mult + 0.5) / mult\nend\n\n---@param v number\n---@return number\ncalc.Sign = function(v)\n    if v > 0 then\n        return 1\n    elseif v < 0 then\n        return -1\n    else\n        return 0\n    end\nend\n\n---@param value number\n---@param sign integer -1 or 1\n---@return number\ncalc.SetSign = function(value, sign)\n    value = abs(value)\n\n    if sign ~= 0 then\n        return value * sign\n    end\n\n    return value\nend\n\ncalc.Scale = function(value, inMin, inMax, outMin, outMax)\n    return (outMax - outMin) / (inMax - inMin) * (value - inMin) + outMin\nend\n\n--- @param coordinate Vec3 A position in in world coordinates to convert to local coordinates\ncalc.WorldToLocal = function(coordinate)\n    local localized = coordinate - Vec3.New(construct.getWorldPosition())\n    return Vec3.New(solve3(construct.getWorldRight(), construct.getWorldForward(), construct.getWorldUp(),\n        { localized:Unpack() }))\nend\n\n--- @param direction Vec3 A unit vector, in world coordinates to convert to a local unit vector\ncalc.WorldDirectionToLocal = function(direction)\n    return Vec3.New(solve3(construct.getWorldRight(), construct.getWorldForward(), construct.getWorldUp(),\n        { direction:Unpack() }))\nend\n--[[ This one does the same thing as the above one, except that it doesn't subtract the construct position to move the vector to origo.\ncalc.WorldToLocal = function(worldPos)\n    local RGT = Vec3.New(construct.getWorldRight())\n    local FWD = Vec3.New(construct.getWorldForward())\n    local UP = Vec3.New(construct.getWorldUp())\n\n    local localPos = Vec3.New(\n            worldPos:Dot(RGT),\n            worldPos:Dot(FWD),\n            worldPos:Dot(UP)\n    )\n\n    return localPos\nend]]\n\n---Converts construct local coordinates to world coordinates\n---@param localCoord Vec3\n---@return Vec3\ncalc.LocalToWorld = function(localCoord)\n    local xOffset = localCoord.x * Vec3.New(construct.getWorldOrientationRight())\n    local yOffset = localCoord.y * Vec3.New(construct.getWorldOrientationForward())\n    local zOffset = localCoord.z * Vec3.New(construct.getWorldOrientationUp())\n    return xOffset + yOffset + zOffset + Vec3.New(construct.getWorldPosition())\nend\n\n---@param normal Vec3\n---@param vecA Vec3\n---@param vecB Vec3\n---@return number\ncalc.SignedRotationAngle = function(normal, vecA, vecB)\n    vecA = vecA:ProjectOnPlane(normal)\n    vecB = vecB:ProjectOnPlane(normal)\n    return atan(vecA:Cross(vecB):Dot(normal), vecA:Dot(vecB))\nend\n\n---@param up Vec3\n---@param right Vec3\n---@return Vec3\ncalc.StraightForward = function(up, right)\n    return up:Cross(right)\nend\n\n---@param mps number\n---@return number\ncalc.Mps2Kph = function(mps)\n    return mps * 3.6\nend\n\n---@param kph number\n---@return number\ncalc.Kph2Mps = function(kph)\n    return kph / 3.6\nend\n\n---Clamps v between minVal and maxVal, inclusive\n---@param v number\n---@param minVal number\n---@param maxVal number\n---@return number\ncalc.Clamp = function(v, minVal, maxVal)\n    return min(maxVal, max(v, minVal))\nend\n\n\n---Returns the nearest point on the line\n---@param lineStart Vec3\n---@param lineDirection Vec3\n---@param pointAwayFromLine Vec3\n---@return Vec3\ncalc.NearestPointOnLine = function(lineStart, lineDirection, pointAwayFromLine)\n    -- https://forum.unity.com/threads/how-do-i-find-the-closest-point-on-a-line.340058/\n    local lineDir = lineDirection:Normalize()\n    local v = pointAwayFromLine - lineStart\n    local d = v:Dot(lineDir)\n    return lineStart + lineDir * d\nend\n\n---Gets the closest point to p on the line segment a-b\n---@param a Vec3 Line start\n---@param b Vec3 Line end\n---@param p Vec3 The point away from the line\n---@return Vec3 #Point on the line segment\ncalc.NearestOnLineBetweenPoints = function(a, b, p)\n    local ab = b - a\n    local ap = p - a\n\n    local proj = ap:Dot(ab)\n\n    local abLen2 = ab:Len2()\n\n    if abLen2 <= 0 then\n        -- a and b are on the same place\n        return a\n    end\n\n    local d = proj / abLen2\n\n    if d <= 0 then\n        return a\n    elseif d >= 1 then\n        return b\n    else\n        return a + ab * d\n    end\nend\n\n-- https://gamedev.stackexchange.com/questions/96459/fast-ray-sphere-collision-code\n-- https://github.com/excessive/cpml/blob/master/modules/intersect.lua#L152\n---@param ray Ray\n---@param sphereCenter Vec3\n---@param sphereRadius number\n---@return boolean,Vec3,number\ncalc.LineIntersectSphere = function(ray, sphereCenter, sphereRadius)\n    local offset = ray.Start - sphereCenter\n    local b = offset:Dot(ray.Dir)\n    local c = offset:Dot(offset) - sphereRadius * sphereRadius\n\n    -- ray's position outside sphere (c > 0)\n    -- ray's direction pointing away from sphere (b > 0)\n    if c > 0 and b > 0 then\n        return false, Vec3.New(), 0\n    end\n\n    local discr = b * b - c\n\n    -- negative discriminant\n    if discr < 0 then\n        return false, Vec3.New(), 0\n    end\n\n    -- If t is negative, ray started inside sphere so clamp t to zero\n    local t = -b - sqrt(discr)\n    t = t < 0 and 0 or t\n\n    -- Return collision point and distance from ray origin\n    return true, ray.Start + ray.Dir * t, t\nend\n\n---Determmines of the value is NaN\n---@param value number\n---@return boolean\ncalc.IsNaN = function(value)\n    return value ~= value\nend\n\n---Determines if the difference between a and b is within the margin\n---@param a number\n---@param b number\n---@param margin number\n---@return boolean\ncalc.AreAlmostEqual = function(a, b, margin)\n    return abs(a - b) < margin\nend\n\n---Tenary function\n---@generic T\n---@param condition boolean\n---@param a T\n---@param b T\n---@return T\ncalc.Ternary = function(condition, a, b)\n    if condition then\n        return a\n    end\n\n    return b\nend\n\n---Rotate a vector around a point\n---@param vector Vec3 The vector to rotate\n---@param rotationPoint Vec3 The point to rotate around\n---@param degrees number The angle, in degrees, to rotate\n---@param axis Vec3 The axis to rotate around\n---@return Vec3 #The vector, rotated around the axis\ncalc.RotateAroundAxis = function(vector, rotationPoint, degrees, axis)\n    return (vector - rotationPoint):Rotate(degrees * deg2rad, axis:NormalizeInPlace()) + rotationPoint\nend\n\n---@param vector Vec3\n---@return number\ncalc.SignLargestAxis = function(vector)\n    local arr = { vector:Unpack() }\n\n    local ix = 1\n    local maxFound = abs(arr[ix])\n    for i = 1, #arr, 1 do\n        local v = abs(arr[i])\n        if v > maxFound then\n            maxFound = v\n            ix = i\n        end\n    end\n\n    return calc.Sign(arr[ix])\nend\n\n\n---Calculates the brake distance\n---@param speed number\n---@param acceleration number\n---@return number\ncalc.CalcBrakeDistance = function(speed, acceleration)\n    local d = (speed ^ 2) / (2 * acceleration)\n    if calc.IsNaN(d) or acceleration == 0 then\n        return 0\n    end\n\n    return d\nend\n\n---Calculates the required brake acceleration to come to a stop in the remaining distance\n---@param speed number\n---@param remainingDistance number\n---@return number\ncalc.CalcBrakeAcceleration = function(speed, remainingDistance)\n    ---Calculating the brake acceleration is the same mathematical operation as for the brake distance so we resuse for less code.\n    return calc.CalcBrakeDistance(speed, remainingDistance)\nend\n\n\n-- https://github.com/GregLukosek/3DMath/blob/master/Math3D.cs\n\n-- Get the shortest distance between a point and a plane. The output is signed so it holds information\n-- as to which side of the plane normal the point is.\n---@param planeNormal Vec3\n---@param planePoint Vec3\n---@param point Vec3\n---@return number\nlocal function signedDistancePlanePoint(planeNormal, planePoint, point)\n    return planeNormal:Dot(point - planePoint)\nend\n\n---Project a point on a plane\n---@param planeNormal Vec3\n---@param planePoint Vec3\n---@param point Vec3\n---@return Vec3\ncalc.ProjectPointOnPlane = function(planeNormal, planePoint, point)\n    -- First calculate the distance from the point to the plane:\n    local distance = signedDistancePlanePoint(planeNormal, planePoint, point)\n\n    -- Reverse the sign of the distance\n    distance = distance * -1;\n\n    -- Get a translation vector\n    local translationVector = planeNormal * distance\n\n    -- Translate the point to form a projection\n    return point + translationVector\nend\n\n\n---Returns the corresponding angle for the given dot product (for unit vectors)\n---@param dot number Dot product\n---@return number # Angle in degrees\ncalc.DotToAngle = function(dot)\n    return rad2deg * acos(dot)\nend\n\ncalc.AngleToDot = function(angleDeg)\n    return cos(angleDeg * deg2rad)\nend\n\n---@param v number\n---@param minV number\n---@param maxV number\n---@return boolean\ncalc.BetweenOrEqual = function(v, minV, maxV)\n    return v >= minV and v <= maxV\nend\n\nreturn calc\n\nend)\npackage.preload['YFS:../e/lib/src/commandline/Command.lua']=(function()\nlocal log = require('YFS:../e/lib/src/debug/Log.lua').Instance()\nlocal Option = require('YFS:../e/lib/src/commandline/Option.lua')\nlocal argType = require('YFS:../e/lib/src/commandline/Types.lua')\nlocal calc = require('YFS:../e/lib/src/util/Calc.lua')\nrequire('YFS:../e/lib/src/util/Table.lua')\n\n---@module \"commandline/Types\"\n\n---@alias CommandResult table<string, ArgumentValueTypes> -- Actual layout: {commandValue:value, sanitizedName:optionValue}\n\n---@class Command\n---@field New fun():Command\n---@field AsString fun():Command\n---@field AsNumber fun():Command\n---@field AsBoolean fun():Command\n---@field AsEmpty fun():Command\n---@field Must fun():Command\n---@field Option fun(name:string):Option\n---@field Parse fun(args:string[]):CommandResult\n\nlocal Command = {}\nCommand.__index = Command\n\nfunction Command.New()\n    local s = {}\n    local type = argType.EMPTY ---@type ArgTypes\n    local option = {} ---@type table<string,Option>\n    local mandatory = false\n\n    ---Marks command as string\n    ---@return Command\n    function s.AsString()\n        type = argType.STRING\n        return s\n    end\n\n    ---Marks command as number\n    ---@return Command\n    function s.AsNumber()\n        type = argType.NUMBER\n        return s\n    end\n\n    ---Marks command as boolean\n    ---@return Command\n    function s.AsBoolean()\n        type = argType.BOOLEAN\n        return s\n    end\n\n    ---Marks command as emtpy\n    ---@return Command\n    function s.AsEmpty()\n        if mandatory then\n            error(\"Command is mandatory, cannot set as type empty\")\n        end\n        type = argType.EMPTY\n        return s\n    end\n\n    ---Marks command as mandatory\n    ---@return Command\n    function s.Must()\n        if type == argType.EMPTY then\n            error(\"Command is of type empty, cannot set as mandatory\")\n        end\n        mandatory = true\n        return s\n    end\n\n    ---Adds an option to the command\n    ---@param name string\n    ---@return Option\n    function s.Option(name)\n        local opt = Option.New(name)\n        option[name] = opt\n        return opt\n    end\n\n    ---Parses command and options from args\n    ---@param args string[]\n    ---@return CommandResult|nil\n    function s.Parse(args)\n        -- Let the options extract their data first; whatever is left is for the command\n        local data = {} ---@type CommandResult\n\n        for _, opt in pairs(option) do\n            if not opt.Parse(args, data) then\n                return nil\n            end\n        end\n\n        local expectedLength = type == argType.EMPTY and 0 or 1\n        local len = TableLen(args)\n        if len < expectedLength then\n            log.Error(\"Too few arguments for command.\")\n            return nil\n        elseif len > expectedLength then\n            log.Error(\"Too many arguments for command.\")\n            log.Error(args)\n            return nil\n        end\n\n        local ok\n        ok, data.commandValue = argType.parseValue(type, args[1])\n\n        if not ok then\n            return nil\n        end\n\n        if data.commandValue == nil and mandatory then\n            log.Error(\"Missing mandatory value for command\")\n            return nil\n        end\n\n        return data\n    end\n\n    return setmetatable(s, Command)\nend\n\nreturn Command\n\nend)\npackage.preload['YFS:../e/lib/src/commandline/CommandLine.lua']=(function()\nlocal log = require('YFS:../e/lib/src/debug/Log.lua').Instance()\nlocal su = require('YFS:../e/lib/src/util/StringUtil.lua')\nlocal Command = require('YFS:../e/lib/src/commandline/Command.lua')\n\n---@alias CommandFunction fun(data:CommandResult)\n---@alias PreparedCommand {cmd:Command, exec:CommandFunction}\n---@alias AccessCheck fun(cmd:string):boolean\n\n---@class CommandLine\n---@field Accept fun(name:string, func:CommandFunction):Command\n---@field Clear fun()\n---@field Exec fun(command:string)\n---@field SetAccess fun(f:AccessCheck)\n\nlocal CommandLine = {}\nCommandLine.__index = CommandLine\nlocal singleton\n\n---Get the commandline instance\n---@return CommandLine\nfunction CommandLine.Instance()\n    if singleton then\n        return singleton\n    end\n\n    local s       = {}\n    local command = {} ---@type table<string, PreparedCommand>\n    ---@type AccessCheck\n    local access  = function(_)\n        return true\n    end\n\n    ---@param f AccessCheck\n    function s.SetAccess(f)\n        access = f\n    end\n\n    ---Accepts a command\n    ---@param name string\n    ---@param func CommandFunction\n    ---@return Command\n    function s.Accept(name, func)\n        local o = Command.New()\n        command[name] = { cmd = o, exec = func }\n        return o\n    end\n\n    ---Clears all registered commands\n    function s.Clear()\n        command = {}\n    end\n\n    ---Parses and executes the input command\n    ---@param input string\n    local function exec(input)\n        local exeFunc = function(commandString)\n            local parts = su.SplitQuoted(commandString)\n            -- We now have each part of the command in an array, where the first part is the command itself.\n            local possibleCmd = table.remove(parts, 1)\n            local preparedCommand = command[possibleCmd]\n            if preparedCommand == nil then\n                log.Error(\"Command not supported: \", possibleCmd)\n            else\n                -- Let the command parse the rest of the arguments. If successful, we get back a table with the values as per the options.\n                -- The command-value itself may be empty if it is not mandatory.\n                local data = preparedCommand.cmd.Parse(parts)\n                if data == nil then\n                    log.Error(\"Cannot execute: \", commandString)\n                else\n                    if access(possibleCmd) then\n                        log.Info(\"Executing: \", commandString)\n                        preparedCommand.exec(data)\n                    else\n                        log.Error(\"Not authorized to execute command '\", possibleCmd, \"'\")\n                    end\n                end\n            end\n        end\n\n        local status, ret = xpcall(exeFunc, traceback, input)\n        if not status then\n            log.Error(ret)\n        end\n    end\n\n    ---Executes the provided command\n    ---@param command string\n    function s.Exec(command)\n        exec(command)\n    end\n\n    ---Receiver of input from the lua chat\n    ---@param cmdLine CommandLine\n    ---@param text string\n    function s.inputText(cmdLine, text)\n        exec(text)\n    end\n\n    singleton = setmetatable(s, CommandLine)\n\n    system:onEvent(\"onInputText\", s.inputText, s)\n    return singleton\nend\n\nreturn CommandLine\n\nend)\npackage.preload['YFS:../e/lib/src/input/Input.lua']=(function()\nlocal keys = require('YFS:../e/lib/src/input/Keys.lua')\nlocal clamp = require('YFS:../e/lib/src/util/Calc.lua').Clamp\n\n---@alias InputCallback fun()\n---@alias CallbackPair {criteria:Criteria, func:InputCallback}\n\n---@class Input\n---@field Instance fun():Input\n---@field Register fun(key:integer, criteria:Criteria, callback:InputCallback)\n---@field RegisterMany fun(keys:integer[], criteria:Criteria, callback:InputCallback)\n---@field IsPressed fun(key:integer):boolean\n---@field AnyPressed fun(keys:integer[]):boolean\n---@field KeyState fun():table<integer, boolean>\n---@field Clear fun()\n---@field Throttle fun():number\n---@field SetThrottle fun(value:number)\n---@field SetThrottleStep fun(value:number)\n\nlocal Input = {}\nInput.__index = Input\nlocal singleton\n\n---Returns the Input intance\n---@return Input\nfunction Input.Instance()\n    if singleton then\n        return singleton\n    end\n\n    local s = {}\n    local lookup = {} ---@type table<Keys, CallbackPair[]>\n    local keyState = {} ---@type table<integer, boolean>\n    local throttleValue = 0\n    local throttleStep = 0.1\n\n    ---Decodes the event\n    ---@param keyName string\n    ---@param isPressed boolean\n    ---@param isRepeat boolean\n    function s.decode(keyName, isPressed, isRepeat)\n        local key = keys[keyName]\n        if key == nil then return end\n\n        keyState[key] = isPressed\n\n        local l = lookup[key]\n\n        if l ~= nil then\n            for _, entry in ipairs(l) do\n                if entry.criteria.Matches(s, isRepeat, isPressed) then\n                    entry.func()\n                end\n            end\n        end\n    end\n\n    local function keyPress(_, key)\n        s.decode(key, true, false)\n    end\n\n    local function keyRelease(_, key)\n        s.decode(key, false, false)\n    end\n\n    local function keyRepeat(_, key)\n        s.decode(key, true, true)\n    end\n\n    local function update()\n        throttleValue = clamp(throttleValue + throttleStep * system.getThrottleInputFromMouseWheel(), 0, 1)\n    end\n\n    ---Indicates if a key is pressed\n    ---@param key Keys\n    ---@return boolean\n    function s.IsPressed(key)\n        return keyState[key] or false\n    end\n\n    ---Indicates if any of the keys are pressed\n    ---@param keys Keys[]\n    ---@return boolean\n    function s.AnyPressed(keys)\n        for _, k in ipairs(keys) do\n            if s.IsPressed(k) then return true end\n        end\n\n        return false\n    end\n\n    ---@return table<integer, boolean>\n    function s.KeyStates()\n        return keyState\n    end\n\n    ---Register a function to be triggered when a key is pressed and certain modifiers are set\n    ---@param key integer\n    ---@param criteria Criteria\n    ---@param callback InputCallback\n    function s.Register(key, criteria, callback)\n        local cbPair = lookup[key]\n\n        if cbPair == nil then\n            cbPair = {}\n            lookup[key] = cbPair\n        end\n\n        table.insert(cbPair, { criteria = criteria, func = callback })\n    end\n\n    ---Registers multiple keys to the same function\n    ---@param keys integer[]\n    ---@param critera Criteria\n    ---@param callback InputCallback\n    function s.RegisterMany(keys, critera, callback)\n        for _, v in ipairs(keys) do\n            s.Register(v, critera, callback)\n        end\n    end\n\n    ---Clears all registered callbacks\n    function s.Clear()\n        lookup = {}\n        keyState = {}\n    end\n\n    ---Returns the throttle value, 0...1\n    ---@return number\n    function s.Throttle()\n        return throttleValue\n    end\n\n    ---Sets the throttle value 0...1\n    ---@param value number\n    function s.SetThrottle(value)\n        throttleValue = clamp(value, 0, 1)\n    end\n\n    ---Sets the throttle step 0...1\n    ---@param value number\n    function s.SetThrottleStep(value)\n        throttleStep = clamp(value, 0.01, 1)\n    end\n\n    singleton = setmetatable(s, Input)\n\n    system:onEvent(\"onActionStart\", keyPress)\n    system:onEvent(\"onActionStop\", keyRelease)\n    system:onEvent(\"onActionLoop\", keyRepeat)\n    system:onEvent(\"onUpdate\", update)\n\n    return singleton\nend\n\nreturn Input\n\nend)\npackage.preload['YFS:../e/lib/src/util/PubSub.lua']=(function()\n---@class PubSub\n---@field RegisterString fun(topic:string, callback:SubStringCallback)\n---@field RegisterNumber fun(topic:string, callback:SubNumberCallback)\n---@field RegisterTable fun(topic:string, callback:SubTableCallback)\n---@field RegisterBool fun(topic:string, callback:SubBooleanCallback)\n---@field Publish fun(topic:string, value:string|number|table|boolean)\n---@field Unregister fun(topic:string, callback:SubStringCallback|SubNumberCallback|SubTableCallback|SubBooleanCallback)\n---@field Instance fun():PubSub\n\n---@alias SubStringCallback fun(topic:string, value:string)\n---@alias SubNumberCallback fun(topic:string, value:number)\n---@alias SubBooleanCallback fun(topic:string, value:boolean)\n---@alias SubTableCallback fun(topic:string, value:table)\n\nlocal PubSub = {}\nPubSub.__index = PubSub\nlocal singelton\n\n---Gets the instance\n---@return PubSub\nfunction PubSub.Instance()\n    if singelton then\n        return singelton\n    end\n\n    local s = {}\n    local subscribers = {\n        number = {}, ---@type table<string, SubNumberCallback[]>\n        string = {}, ---@type table<string, SubStringCallback[]>\n        table = {}, ---@type table<string, SubTableCallback[]>\n        boolean = {} ---@type table<string, SubBooleanCallback[]>\n    }\n\n    ---@param subs table\n    ---@param topic string\n    ---@param callback SubStringCallback|SubNumberCallback|SubTableCallback|SubBooleanCallback\n    local function register(subs, topic, callback)\n        local callbacks = subs[topic]\n        if not callbacks then\n            callbacks = {}\n            subs[topic] = callbacks\n        end\n\n        table.insert(callbacks, callback)\n    end\n\n    ---@param topic string\n    ---@param callback SubStringCallback|SubNumberCallback|SubTableCallback|SubBooleanCallback\n    function s.Unregister(topic, callback)\n        for _, topics in pairs(subscribers) do\n            local subs = topics[topic]\n            if subs then\n                for index, sub in ipairs(subs) do\n                    if sub == callback then\n                        table.remove(subs, index)\n                        return\n                    end\n                end\n            end\n        end\n    end\n\n    ---Registers a string callback for the topic\n    ---@param topic string\n    ---@param callback SubStringCallback\n    function s.RegisterString(topic, callback)\n        register(subscribers[type(\"\")], topic, callback)\n    end\n\n    ---Registers a number callback for the topic\n    ---@param topic string\n    ---@param callback SubNumberCallback\n    function s.RegisterNumber(topic, callback)\n        register(subscribers[type(1)], topic, callback)\n    end\n\n    ---Registers a table callback for the topic\n    ---@param topic string\n    ---@param callback SubTableCallback\n    function s.RegisterTable(topic, callback)\n        register(subscribers[type({})], topic, callback)\n    end\n\n    ---Registers a boolean callback for the topic\n    ---@param topic string\n    ---@param callback SubBooleanCallback\n    function s.RegisterBool(topic, callback)\n        register(subscribers[type(true)], topic, callback)\n    end\n\n    ---Publishes the value on the topic\n    ---@param topic string\n    ---@param value string|number|table|boolean\n    function s.Publish(topic, value)\n        local subs = subscribers[type(value)]\n\n        if not subs then return end\n\n        local callbacks = subs[topic]\n        if not callbacks then return end\n\n        for _, subscriber in ipairs(callbacks) do\n            subscriber(topic, value)\n        end\n    end\n\n    singelton = setmetatable(s, PubSub)\n    return singelton\nend\n\nreturn PubSub\n\nend)\npackage.preload['YFS:flight/Brakes.lua']=(function()\nrequire('YFS:../e/lib/src/abstraction/Vehicle.lua')\nlocal calc, nullVec, PID, pub, autoBrakeTimer = require('YFS:../e/lib/src/util/Calc.lua'), require('YFS:../e/lib/src/math/Vec3.lua').New(), require(\"cpml/pid\"),\n    require('YFS:../e/lib/src/util/PubSub.lua').Instance(), require('YFS:../e/lib/src/system/Stopwatch.lua').New()\nlocal Clamp = calc.Clamp\nlocal max = math.max\n\nlocal atmoBrakeCutoffSpeed = calc.Kph2Mps(360) -- Speed limit under which atmospheric brakes become less effective (down to 10m/s [36km/h] where they give 0.1 of max)\nlocal atmoBrakeEfficiencyFactor = 0.9          -- Kept at 0.9\nlocal spaceEfficiencyFactor = 0.9              -- Reduced from one to counter brake PID not reacting immediately, thus inducing a delay and subsequent overshoot.\n\n---@class Brake\n---@field Instance fun() Brake\n---@field Forced fun(enable:boolean)\n---@field BrakeUpdate fun()\n---@field BrakeFlush fun()\n---@field MaxBrakeAcc fun():number\n---@field GravityInfluencedAvailableDeceleration fun():number\n---@field MaxSeenGravityInfluencedAvailableAtmoDeceleration fun():number\n---@field BrakeEfficiency fun(inAtmo:boolean, speed:number):number\n---@field EffectiveBrakeDeceleration fun():number\n---@field Feed fun(desiredMovementDir:Vec3, accelerationDir:Vec3, targetSpeed:number)\n---@field Active fun():boolean\n---@field SetAutoBrakeAngle fun(angle:number)\n---@field SetAutoBrakeDelay fun(delay:number)\n---@field CalcMaxAllowedSpeed fun(distance:number, endSpeed:number, availableBrakeDeceleration:number|nil):number\n\n\nlocal Brake = {}\nBrake.__index = Brake\n\nlocal instance\n\n---Gets the brake instance\n---@return Brake\nfunction Brake.Instance()\n    if instance then\n        return instance\n    end\n\n    local pidHighSpeed = PID(1, 0, 0.01)\n    local pidLowSpeed = PID(0.1, 0.0, 1)\n    local deceleration = nullVec\n    local maxSeenBrakeAtmoAcc = 0\n    local _100kmph = calc.Kph2Mps(100)\n    local brakeData = { maxDeceleration = 0, currentDeceleration = 0, pid = 0, setAutoBrakeAngle = 0, autoBrakeAngle = 0 } ---@type BrakeData\n    local autoBrakeAngle = 45\n    local autoBrakeDelay = 1\n    local _1kmph = calc.Kph2Mps(1)\n\n    local s = {\n        engaged = false,\n        forced = false,\n        totalMass = TotalMass()\n    }\n\n    ---Returns the deceleration the construct is capable of in the given movement.\n    ---@return number Deceleration\n    local function rawAvailableDeceleration()\n        -- F = m * a => a = F / m\n        return construct.getMaxBrake() / s.totalMass\n    end\n\n    ---@return Vec3\n    local function finalDeceleration()\n        if s.forced then\n            return -Velocity():Normalize() * rawAvailableDeceleration()\n        else\n            return deceleration\n        end\n    end\n\n    function s.BrakeUpdate()\n        s.totalMass = TotalMass()\n        local raw = rawAvailableDeceleration()\n        brakeData.maxDeceleration = raw\n        brakeData.currentDeceleration = construct.getCurrentBrake() / s.totalMass\n        if IsInAtmo() then\n            maxSeenBrakeAtmoAcc = max(raw, maxSeenBrakeAtmoAcc)\n        end\n        brakeData.setAutoBrakeAngle = autoBrakeAngle\n        pub.Publish(\"BrakeData\", brakeData)\n    end\n\n    ---Enables/disables forced brakes\n    ---@param on boolean\n    function s.Forced(on)\n        s.forced = on\n    end\n\n    function s.BrakeFlush()\n        -- The brake vector must point against the direction of travel.\n        local brakeVector = finalDeceleration()\n        unit.setEngineCommand(\"brake\", { brakeVector:Unpack() }, { 0, 0, 0 }, true, true, \"\", \"\", \"\", 0.001)\n    end\n\n    ---Gets the available brake deceleration, after taking gravity into account\n    ---@return number\n    function s.GravityInfluencedAvailableDeceleration()\n        local dot = GravityDirection():Dot(Velocity():Normalize())\n        local movingTowardsGravityWell = dot > 0\n        local influence = calc.Ternary(movingTowardsGravityWell, -1, 1)\n        -- Might not be enough brakes to counter gravity so don't go below 0\n        return max(0, rawAvailableDeceleration() + influence * dot * G())\n    end\n\n    function s.MaxSeenGravityInfluencedAvailableAtmoDeceleration()\n        local dot = GravityDirection():Dot(Velocity():Normalize())\n        local movingTowardsGravityWell = dot > 0\n        local influence = calc.Ternary(movingTowardsGravityWell, -1, 1)\n        -- Might not be enough brakes to counter gravity so don't go below 0\n        return max(0, maxSeenBrakeAtmoAcc + influence * dot * G())\n    end\n\n    ---@param desiredMovementDir Vec3 The direction we want to move\n    ---@param accelerationDir Vec3 Current acceleration vector\n    ---@param targetSpeed number The desired speed\n    function s.Feed(desiredMovementDir, accelerationDir, targetSpeed)\n        local movementDir, currentSpeed = Velocity():NormalizeLen()\n        local angle = 0\n\n        -- Prefer acceleration over desired movement dir\n        if currentSpeed > _1kmph then\n            if not accelerationDir:IsZero() then\n                angle = accelerationDir:AngleToDeg(movementDir)\n            elseif not desiredMovementDir:IsZero() then\n                angle = desiredMovementDir:AngleToDeg(movementDir)\n            end\n        end\n\n        if angle > autoBrakeAngle then\n            autoBrakeTimer.Start()\n        else\n            autoBrakeTimer.Reset()\n        end\n\n        if autoBrakeTimer.Elapsed() > autoBrakeDelay then\n            targetSpeed = 0\n        end\n\n        local diff = currentSpeed - targetSpeed -- make PID become positive when we have too high speed.\n        pidHighSpeed:inject(diff)\n        pidLowSpeed:inject(diff)\n\n        local pid = currentSpeed > _100kmph and pidHighSpeed or pidLowSpeed\n\n        local brakeValue = Clamp(pid:get(), 0, 1)\n\n        if currentSpeed <= targetSpeed then\n            pidHighSpeed:reset()\n            pidLowSpeed:reset()\n            brakeValue = 0\n        end\n\n        brakeData.pid = brakeValue\n        brakeData.autoBrakeAngle = angle\n\n        deceleration = -movementDir * brakeValue * rawAvailableDeceleration()\n    end\n\n    function s.Active()\n        return brakeData.pid > 0\n    end\n\n    ---Gets the brake efficiency to use\n    ---@param inAtmo boolean\n    ---@param speed number\n    ---@return number\n    function s.BrakeEfficiency(inAtmo, speed)\n        if not inAtmo then\n            return spaceEfficiencyFactor\n        end\n\n        if speed <= atmoBrakeCutoffSpeed then\n            return 0.1\n        else\n            return atmoBrakeEfficiencyFactor\n        end\n    end\n\n    --- Returns the current effective brake deceleration\n    ---@return number # The deceleration, a negative value\n    function s.EffectiveBrakeDeceleration()\n        local currentSpeed = Velocity():Len()\n        local inAtmo = IsInAtmo()\n        local brakeEfficiency = s.BrakeEfficiency(inAtmo, currentSpeed)\n\n        local atmoDensity = AtmoDensity()\n        if atmoDensity > 0 then\n            brakeEfficiency = brakeEfficiency * atmoDensity\n        end\n\n        local availableBrakeDeceleration = -s.GravityInfluencedAvailableDeceleration() * brakeEfficiency\n\n        if inAtmo and currentSpeed < calc.Kph2Mps(3) then\n            -- When standing (nearly) still in atmo, assume brakes gives current g of brake acceleration (brake API gives a 0 as response in this case)\n            local maxSeen = s.MaxSeenGravityInfluencedAvailableAtmoDeceleration()\n            availableBrakeDeceleration = -max(maxSeen, G())\n        end\n\n        return availableBrakeDeceleration\n    end\n\n    --- Calculates the max allowed speed we may have while still being able to decelerate to the endSpeed\n    ---@param distance number Remaining distance to target\n    ---@param endSpeed number Desired speed when reaching target\n    ---@param brakeAcc number|nil Brake acceleration, or nil to use the currently effective deceleration. Remember to pass in a negative number.\n    ---@return number\n    function s.CalcMaxAllowedSpeed(distance, endSpeed, brakeAcc)\n        -- v^2 = v0^2 + 2a*d\n        -- v0^2 = v^2 - 2a*d\n        -- v0 = sqrt(v^2 - 2ad)\n\n        brakeAcc = brakeAcc or s.EffectiveBrakeDeceleration()\n\n        local v0 = (endSpeed * endSpeed - 2 * brakeAcc * distance) ^ 0.5\n        return v0\n    end\n\n    ---Gets the max brake acceleration\n    ---@return number\n    function s.MaxBrakeAcc()\n        return rawAvailableDeceleration()\n    end\n\n    ---Sets the auto brake angle\n    ---@param angle number\n    function s.SetAutoBrakeAngle(angle)\n        autoBrakeAngle = angle\n    end\n\n    ---Sets the auto brake angle\n    ---@param delay number\n    function s.SetAutoBrakeDelay(delay)\n        autoBrakeDelay = delay\n    end\n\n    instance = setmetatable(s, Brake)\n    return instance\nend\n\nreturn Brake\n\nend)\npackage.preload['YFS:../e/lib/src/system/locale.lua']=(function()\n---@enum\nlocal locales = {\n    \"en-US\",\n    \"fr-FR\",\n    \"de-DE\"\n}\n\n---Returns the index of the local\n---@return integer\nfunction LocaleIndex()\n    local locale = system.getLocale()\n    for index, value in ipairs(locales) do\n        if locale == value then\n            return index\n        end\n    end\n\n    return 1 -- default to en-US\nend\n\nend)\npackage.preload['YFS:../e/lib/src/universe/Body.lua']=(function()\n-- Body - stellar body\n\nrequire('YFS:../e/lib/src/system/locale.lua')\nlocal Vec3 = require('YFS:../e/lib/src/math/Vec3.lua')\nlocal abs = math.abs\n\nlocal max = math.max\n\n---@module \"Galaxy\"\n\n---@class Body\n---@field Galaxy Galaxy The galaxy the body resides in\n---@field Id number The body ID\n---@field Name string The name of the body\n---@field Type string The type of the body\n---@field Physics { Gravity:number } Physics properties\n---@field Geography { Center:Vec3, Radius:number} Geography properties\n---@field Atmosphere {Present:boolean, Thickness:number, Radius:number} Atmosphere properties\n---@field Surface {MaxAltitude:number, MinAltitude:number}} Surface properties\n---@field PvP {LocatedInSafeZone:boolean} Pvp properties\n---@field DistanceToAtmo fun(self:Body, point:Vec3):number\n---@field DistanceToAtmoEdge fun(self:Body, point:Vec3):number\n---@field HasAtmo fun():boolean\n---@field IsInAtmo fun(self:Body, point:Vec3):boolean\n---@field DistanceToHighestPossibleSurface fun(coordinate:Vec3):number\n---@field AboveSeaLevel fun(coordinate:Vec3):boolean, number\n\nlocal Body = {}\nBody.__index = Body\n\n---@param galaxy table\n---@param bodyData table\n---@return Body\nfunction Body.New(galaxy, bodyData)\n    local language = LocaleIndex()\n\n    local s = {\n        ---@type Body\n        Galaxy = galaxy,\n        Id = bodyData.id,\n        Name = bodyData.name[language],\n        Type = bodyData.type[language],\n        Physics = {\n            Gravity = bodyData.gravity\n        },\n        Geography = {\n            Center = Vec3.New(bodyData.center),\n            Radius = bodyData.radius -- This is the water level, i.e. 0 elevation\n        },\n        Atmosphere = {\n            Present = bodyData.hasAtmosphere,\n            Thickness = bodyData.atmosphereThickness,\n            Radius = bodyData.atmosphereRadius\n        },\n        Surface = {\n            MaxAltitude = bodyData.surfaceMaxAltitude,\n            MinAltitude = bodyData.surfaceMinAltitude\n        },\n        Pvp = {\n            LocatedInSafeZone = bodyData.isInSafeZone\n        }\n    }\n\n    function Body.__tostring(instance)\n        return instance.Name\n    end\n\n    ---Returns the distance between the given position and the atmosphere of the body, 0 if already in atmosphere of the body\n    ---@param coordinate Vec3\n    ---@return number\n    function s:DistanceToAtmo(coordinate)\n        return max(0, (coordinate - s.Geography.Center):Len() - s.Atmosphere.Radius)\n    end\n\n    ---Returns the distance to the edge of the atmosphere, from the given position\n    ---@param coordinate Vec3\n    function s:DistanceToAtmoEdge(coordinate)\n        local dist = s:DistanceToAtmo(coordinate)\n        if dist == 0 then\n            -- Inside atmo\n            return s.Atmosphere.Radius - (coordinate - s.Geography.Center):Len()\n        end\n\n        return dist\n    end\n\n    ---Returns true if the coordinate is within the atmosphere of the body\n    ---@param coordinate any\n    ---@return boolean\n    function s:IsInAtmo(coordinate)\n        return s:DistanceToAtmo(coordinate) == 0\n    end\n\n    ---Returns true if the body has an atmosphere\n    ---@return boolean\n    function s:HasAtmo()\n        return s.Atmosphere.Radius > 0\n    end\n\n    ---Returns the distance to the highest possible point on the body or 0 if below higest surface\n    ---@param coordinate Vec3\n    ---@return number\n    function s.DistanceToHighestPossibleSurface(coordinate)\n        return max(0, (coordinate - s.Geography.Center):Len() - s.Geography.Radius - s.Surface.MaxAltitude)\n    end\n\n    ---Returns a boolean indicating if the coordinate is above sea level and a number representing the absolute distance to the sea level\n    ---@param coordinate Vec3 The coordinate to get info on.\n    ---@return boolean, number\n    function s.AboveSeaLevel(coordinate)\n        local seaLevel = s.Geography.Radius\n        local distanceToCenter = (coordinate - s.Geography.Center):Len()\n        return distanceToCenter >= seaLevel, abs(distanceToCenter - seaLevel)\n    end\n\n    return setmetatable(s, Body)\nend\n\nreturn Body\n\nend)\npackage.preload['YFS:../e/lib/src/universe/Galaxy.lua']=(function()\n-- galaxy - utility class to manage the in-game atlas\n\nlocal Body = require('YFS:../e/lib/src/universe/Body.lua')\nlocal calc = require('YFS:../e/lib/src/util/Calc.lua')\nlocal max = math.max\n\n---@class Galaxy\n---@field New fun(galaxyId:integer, galaxyAtlas:table):Galaxy\n---@field BodyById fun(self:Galaxy, id:integer):Body Gets a body by the id\n---@field GetBodyClosestToPosition fun(self:Galaxy, position:Vec3):Body Gets the body closes to the position\n---@field BodiesInPath fun(self:Galaxy, path:Ray):Body[] Returns the bodies with which the ray intersects (including atmosphere), sorted by distance, closest first.\n---@field Id integer The id of the galaxy\n\nlocal Galaxy = {}\nGalaxy.__index = Galaxy\n\n---Creates a new Galaxy\n---@param galaxyId integer The id of the galaxy\n---@param galaxyAtlas table The lookup table from the in-game atlas.\n---@return Galaxy\nfunction Galaxy.New(galaxyId, galaxyAtlas)\n    local s = {\n        Id = galaxyId\n    }\n\n    local body = {} ---@type Body[] -- Stellar bodies by id\n\n    for bodyId, bodyData in pairs(galaxyAtlas) do\n        body[bodyId] = Body.New(s, bodyData)\n    end\n\n    function s:BodyById(id)\n        return body[id]\n    end\n\n    ---Gets the body closest to the given position\n    ---@param position Vec3 position to get closest body for\n    ---@return Body The body\n    function s:GetBodyClosestToPosition(position)\n        local closest\n        local smallestDistance\n\n        for _, b in pairs(body) do\n            local dist = (b.Geography.Center - position):Len()\n            if smallestDistance == nil or dist < smallestDistance then\n                smallestDistance = dist\n                closest = b\n            end\n        end\n\n        return closest\n    end\n\n    --- Gets the bodies the path intersects, sorted by distance, closest first.\n    ---@param ray Ray The ray to check for intersecting bodies\n    ---@return table A list of bodies that the path intersects\n    function s:BodiesInPath(ray)\n        local res = {}\n\n        local sortFunc = function(a, b)\n            return (a.Geography.Center - ray.Start):Len2() < (b.Geography.Center - ray.Start):Len2()\n        end\n\n        for _, b in pairs(body) do\n            -- If no atmosphere, then use physical body\n            local radius = max(b.Geography.Radius, b.Atmosphere.Radius)\n            local intersects, _, _ = calc.LineIntersectSphere(ray, b.Geography.Center, radius)\n\n            if intersects then\n                table.insert(res, b)\n            end\n        end\n\n        table.sort(res, sortFunc)\n\n        return res\n    end\n\n    return setmetatable(s, Galaxy)\nend\n\nreturn Galaxy\n\nend)\npackage.preload['YFS:../e/lib/src/universe/Position.lua']=(function()\n---Represents a position in the universe.\n\nlocal stringFormat = string.format\n\n---@class Position\n---@field New fun(galaxy:integer, bodyRef:Body, x:integer, y:integer, z:integer):Position Creates a new Position\n---@field AsPosString fun():string returns a ::pos{} string\n---@field Coordinates fun():Vec3 returns the coordinates\n\nlocal Position = {}\nPosition.__index = Position\n\n---Creates a new position from the galaxy, body and x,y and z coordinates\n---@param galaxy Galaxy The Galaxy the position belongs in\n---@param bodyRef Body The closest body\n---@param coordinate Vec3 World coordinates\n---@return Position\nfunction Position.New(galaxy, bodyRef, coordinate)\n    local s = {\n        Body = bodyRef,\n        Galaxy = galaxy,\n        Coords = coordinate\n    }\n\n    function s.AsPosString()\n        return tostring(s)\n    end\n\n    ---Returns the coordinates of the position\n    ---@return Vec3\n    function s.Coordinates()\n        return s.Coords\n    end\n\n    function Position.__tostring(p) -- __tostring must be in the metatable, not the instance\n        -- The game starts giving space coordinates at an altitude of 70km above\n        -- the planets radius on Alioth so we're mimicing that behaviour.\n        local altitude = (p.Coords - p.Body.Geography.Center):Len() - p.Body.Geography.Radius\n        if altitude < p.Body.Geography.Radius + 70000 then\n            -- Use a radius that includes the altitude\n            local radius = p.Body.Geography.Radius + altitude\n            -- Calculate around origo; planet center is added in Universe:ParsePosition\n            -- and we're reversing that calculation.\n            local calcPos = p.Coords - p.Body.Geography.Center\n\n            local lat = 0\n            local lon = 0\n\n            -- When the input coordinates are the same as the center of the planet, trigonomitry fails so just leave them at 0.\n            if calcPos:Len2() > 0 then\n                lat = math.asin(calcPos.z / radius)\n                lon = math.atan(calcPos.y, calcPos.x)\n            end\n\n            return stringFormat(\"::pos{%d,%d,%.4f,%.4f,%.4f}\", p.Galaxy.Id, p.Body.Id, math.deg(lat), math.deg(lon),\n                altitude)\n        else\n            return stringFormat(\"::pos{%d,0,%.4f,%.4f,%.4f}\", p.Galaxy.Id, p.Coords.x, p.Coords.y, p.Coords.z)\n        end\n    end\n\n    return setmetatable(s, Position)\nend\n\nreturn Position\n\n--[[\n---Calculates the distance 'as the crow flies' to the other position\n---using the haversine formula\n---@param other Position The position to calculate the distance to.\nfunction position:DistanceAtHeight(other)\n    -- http://www.movable-type.co.uk/scripts/latlong.html\n    if self.Body.Id == other.Body.Id then\n\n    else\n\n    end\n\n    return nil\nend\n]]\n\nend)\npackage.preload['YFS:../e/lib/src/universe/Universe.lua']=(function()\n-- Universe - utility class to manage the in-game atlas\nlocal log = require('YFS:../e/lib/src/debug/Log.lua').Instance()\nlocal Galaxy = require('YFS:../e/lib/src/universe/Galaxy.lua')\nlocal Position = require('YFS:../e/lib/src/universe/Position.lua')\nlocal Vec3 = require('YFS:../e/lib/src/math/Vec3.lua')\nlocal cos = math.cos\nlocal sin = math.sin\n\nlocal stringMatch = string.match\nlocal numberPattern = \" *([+-]?%d+%.?%d*e?[+-]?%d*)\"\nlocal posPattern = \"::pos{\" ..\n    numberPattern .. \",\" .. numberPattern .. \",\" .. numberPattern .. \",\" .. numberPattern .. \",\" .. numberPattern .. \"}\"\n\n---@class Universe\n---@field Instance fun():Universe\n---@field CurrentGalaxyId fun():integer Gets the current galaxy id\n---@field CurrentGalaxy fun():Galaxy Gets the current galaxy\n---@field ParsePosition fun(pos:string):Position|nil Parses the ::pos{} string and returns a Position or nil.\n---@field CreatePos fun(coordinate:Vec3):Position\n---@field ClosestBody fun(scoordinate:Vec3):Body Returns the closest body to the given coordinate\n---@field VerticalReferenceVector fun():Vec3\nlocal Universe = {}\nUniverse.__index = Universe\n\nlocal singleton = nil\n\nfunction Universe.Instance()\n    if singleton then\n        return singleton\n    end\n\n    local galaxy = {} -- Galaxies by id\n    local core = library.getCoreUnit()\n\n    local s = {}\n\n    local duAtlas = require(\"atlas\")\n\n    if type(duAtlas) ~= \"table\" then\n        error(\"Invalid atlas\")\n        unit.exit()\n    end\n\n    for galaxyId, galaxyData in pairs(duAtlas) do\n        galaxy[galaxyId] = Galaxy.New(galaxyId, galaxyData)\n    end\n\n    ---Gets the current galaxy id\n    ---@return number The id of the current galaxy\n    function s.CurrentGalaxyId()\n        return 0 -- Until there are more than one galaxy in the game.\n    end\n\n    ---Gets the current galaxy\n    ---@return Galaxy The current galaxy\n    function s.CurrentGalaxy()\n        return galaxy[s.CurrentGalaxyId()]\n    end\n\n    ---Parses a position string\n    ---@param pos string The \"::pos{...}\" string\n    ---@return Position|nil A position in space or on a planet\n    function s.ParsePosition(pos)\n        local x, y, z, bodyRef\n        local galaxyId, bodyId, latitude, longitude, altitude = stringMatch(pos, posPattern)\n\n        if galaxyId ~= nil then\n            galaxyId = tonumber(galaxyId)\n            bodyId = tonumber(bodyId)\n\n            --[[Positions in space, such as asteroids have no bodyId id. In this case\n            latitude, longitude, altitude are x, y, z in meters.\n\n            In either case, the closest stellar body is set as the positions body.\n            ]]\n            if bodyId == 0 then\n                x = tonumber(latitude)\n                y = tonumber(longitude)\n                z = tonumber(altitude)\n                local coordinate = Vec3.New(x, y, z)\n                bodyRef = s.CurrentGalaxy():GetBodyClosestToPosition(coordinate)\n                return Position.New(galaxy[galaxyId], bodyRef, coordinate)\n            else\n                -- https://stackoverflow.com/questions/1185408/converting-from-longitude-latitude-to-cartesian-coordinates\n                -- The x-axis goes through long,lat (0,0), so longitude 0 meets the equator\n                -- The y-axis goes through (0,90)\n                -- and the z-axis goes through the poles.\n                -- Positions on a body have lat, long in degrees and altitude in meters\n                latitude = math.rad(latitude)\n                longitude = math.rad(longitude)\n                local body = galaxy[galaxyId]:BodyById(bodyId)\n\n                local radius = body.Geography.Radius + altitude\n                local cosLat = cos(latitude)\n                local position = Vec3.New(radius * cosLat * cos(longitude), radius * cosLat * sin(longitude),\n                    radius * sin(latitude))\n                position = position + body.Geography.Center\n\n                return Position.New(galaxy[galaxyId], body, position)\n            end\n        end\n\n        log.Error(\"Invalid position string: \", pos)\n\n        return nil\n    end\n\n    ---comment Creates a :Position from the given coordinate, within the current galaxy.\n    ---@param coordinate Vec3 The coordinate to create the position for\n    ---@return Position\n    function s.CreatePos(coordinate)\n        local closestBody = s.ClosestBody(coordinate)\n        local p = Position.New(s.CurrentGalaxy(), closestBody, coordinate)\n        return p\n    end\n\n    --- Gets the information for the closest stellar body\n    ---@param coordinate Vec3 The coordinate to get the closest body for\n    ---@return Body #The Body\n    function s.ClosestBody(coordinate)\n        local g = s.CurrentGalaxy()\n        return g:GetBodyClosestToPosition(coordinate)\n    end\n\n    ---Returns a unit vector pointing towards the center of the closest 'gravity well', i.e. planet or space construct.\n    --- @return Vec3\n    function s.VerticalReferenceVector()\n        local worldGrav = Vec3.New(core.getWorldGravity())\n        local wDir, wLen = worldGrav:NormalizeLen()\n        if wLen == 0 then\n            local position = Vec3.New(construct.getWorldPosition())\n            local body = s.ClosestBody(position)\n            return (body.Geography.Center - position):Normalize()\n        else\n            return wDir\n        end\n    end\n\n    singleton = setmetatable(s, Universe)\n    return singleton\nend\n\nreturn Universe\n\nend)\npackage.preload['YFS:controller/GateControl.lua']=(function()\nlocal pub, log, Stopwatch = require('YFS:../e/lib/src/util/PubSub.lua').Instance(), require('YFS:../e/lib/src/debug/Log.lua').Instance(),\n    require('YFS:../e/lib/src/system/Stopwatch.lua')\n\n---@class GateControl\n---@field Instance fun():GateControl\n---@field Open fun()\n---@field Close fun()\n---@field Enabled fun():boolean\n---@field Enable fun(on:boolean)\n\nlocal GateControl         = {}\nGateControl.__index       = {}\n\nlocal instance\n\nfunction GateControl.Instance()\n    if instance then return instance end\n\n    local s = {}\n    local wantsOpen = false\n    local enabled = true\n    local timer = Stopwatch.New()\n    local followGate = library.getLinkByName(\"FollowGate\") ---@type any\n\n    if followGate and (type(followGate.activate) ~= \"function\" or type(followGate.deactivate) ~= \"function\") then\n        followGate = nil\n    end\n\n    if followGate then\n        log.Info(\"Found FollowGate switch\")\n    end\n\n    ---@param topic string\n    ---@param data {state:string}\n    local function onData(topic, data)\n        if data.state == wantsOpen then\n            timer.Stop()\n            log.Info(\"Gates reported in desired state\")\n        end\n    end\n\n    local function activate(open)\n        wantsOpen = open\n        timer.Restart()\n    end\n\n    function s.Open()\n        activate(true)\n    end\n\n    function s.Close()\n        activate(false)\n    end\n\n    function s.Enable(on)\n        enabled = on\n    end\n\n    function s.Enabled()\n        return enabled\n    end\n\n    function s.AreInDesiredState()\n        -- When timer no longer is running, gates are in the expected state. (Assuming Open or Closed has been called.)\n        return not enabled or not timer.IsRunning()\n    end\n\n    instance = setmetatable(s, GateControl)\n    pub.RegisterTable(\"RecData-GateControl\", onData)\n\n    system:onEvent(\"onUpdate\", function()\n        if enabled and timer.IsRunning() and timer.Elapsed() > 0.5 then\n            timer.Restart()\n            pub.Publish(\"SendData\",\n                { topic = \"GateControl\", data = { desiredState = wantsOpen } })\n\n            if followGate then\n                if wantsOpen then\n                    followGate.activate()\n                else\n                    followGate.deactivate()\n                end\n            end\n        end\n    end)\n\n    return instance\nend\n\nreturn GateControl\n\nend)\npackage.preload['YFS:../e/lib/src/element/Radar.lua']=(function()\nlocal log = require('YFS:../e/lib/src/debug/Log.lua').Instance()\n\n---@class RadarControl\n---@field Instance fun():RadarControl\n---@field Show fun(on:boolean)\n---@field Sort fun(method:integer)\n---@field IsVisible fun():boolean\n---@field NextMethod fun()\n\nlocal RadarControl = {}\nRadarControl.__index = RadarControl\n\n\n---@enum RadaraState\nRadarState = {\n    Operational = 1,\n    Broken = 0,\n    BadEnvironment = -1,\n    Obstructed = -2,\n    AlreadyInUse = -3\n}\n\nlocal radarSortMethod = {\n    \"Distance acending\",\n    \"Distance descending\",\n    \"Size ascending\",\n    \"Size descending\",\n    \"Threat ascending\",\n    \"Threat descending\"\n}\n\nlocal radarSortCount = TableLen(radarSortMethod)\n\nlocal atmoRadars = { \"RadarPvPAtmospheric\" }\nlocal spaceRadars = { \"RadarPVPSpaceSmallGroup\", \"RadarPVPSpaceMediumGroup\", \"RadarPVPSpaceLargeGroup\" }\n\n---@param names string[]\n---@return Radar\nlocal function getRadar(names)\n    local r = nil\n    for _, n in ipairs(names) do\n        r = r or library.getLinkByClass(n)\n    end\n\n    return r\nend\n\nlocal instance ---@type RadarControl\n\n---@return RadarControl\nfunction RadarControl.Instance()\n    if instance then return instance end\n\n    local s = {}\n    local showRadar = false\n    local sortMethod = 1\n\n    ---@type Radar[]\n    local radars = { getRadar(atmoRadars), getRadar(spaceRadars) }\n\n    local count = radars[1] ~= nil and 1 or 0\n    count = count + (radars[2] ~= nil and 1 or 0)\n\n    local function update()\n        for _, r in ipairs(radars) do\n            if r then\n                if not showRadar or r.getOperationalState() == RadarState.BadEnvironment then\n                    r.hideWidget()\n                else\n                    r.showWidget()\n                end\n            end\n        end\n    end\n\n    ---@param on boolean\n    function s.Show(on)\n        showRadar = on\n        log.Info(\"Radar \", on and \"shown\" or \"hidden\")\n        if on then\n            s.Sort(sortMethod)\n        end\n    end\n\n    ---@return boolean\n    function s.IsVisible()\n        return showRadar\n    end\n\n    function s.NextMethod()\n        local next = (sortMethod + 1) % (radarSortCount + 1)\n        if next == 0 then\n            next = 1\n        end\n        s.Sort(next)\n    end\n\n    ---@param method integer\n    function s.Sort(method)\n        sortMethod = method\n        for _, r in ipairs(radars) do\n            if r and r.getSortMethod() ~= radars then\n                if r.setSortMethod(sortMethod) then\n                    log.Error(\"Sort method set to \", radarSortMethod[sortMethod])\n                end\n            end\n        end\n    end\n\n    system:onEvent(\"onUpdate\", update)\n\n    instance = setmetatable(s, RadarControl)\n    return instance\nend\n\nreturn RadarControl\n\nend)\npackage.preload['YFS:../e/lib/src/element/Telemeter.lua']=(function()\nlocal Vec3 = require('YFS:../e/lib/src/math/Vec3.lua')\n\n---@alias TelemeterVec3 {x:number, y:number, z:number}\n---@alias TelemeterData {hit:boolean, distance:number, point:TelemeterVec3}\n---@alias TeleRaycast fun():TelemeterData\n---@alias TeleDist fun():number\n---@alias TeleWorldAxis fun():TelemeterVec3\n---@alias TelementerAPI {raycast:TeleRaycast, getMaxDistance:TeleDist, getRayWorldAxis:TeleWorldAxis, getRayWorldOrigin:TeleWorldAxis}\n---@alias TelemeterResult {Hit:boolean, Distance:number, Point:Vec3}\n\n---@class Telemeter\n---@field New fun(telemeter:TelementerAPI):Telemeter\n---@field Measure fun():TelemeterResult\n---@field IsTelemeter fun():boolean\n---@field MaxDistance fun():number\n\nlocal Telemeter = {}\nTelemeter.__index = Telemeter\n\n---Create a new Telemeter\n---@param api TelementerAPI\n---@return Telemeter\nfunction Telemeter.New(api)\n    local s = {}\n\n    ---Measure distance\n    ---@return TelemeterResult\n    function s.Measure()\n        local res = api.raycast()\n        return { Hit = res.hit, Point = Vec3.New(res.point), Distance = res.distance }\n    end\n\n    ---Checks if the link has the expected functions\n    ---@return boolean\n    function s.IsTelemeter()\n        return type(api.getMaxDistance) == \"function\"\n            and type(api.raycast) == \"function\"\n            and type(api.getRayWorldOrigin) == \"function\"\n    end\n\n    ---Gets the max measure distance\n    ---@return number\n    function s.MaxDistance()\n        return api.getMaxDistance()\n    end\n\n    return setmetatable(s, Telemeter)\nend\n\nreturn Telemeter\n\nend)\npackage.preload['YFS:controller/FloorDetector.lua']=(function()\nlocal Telemeter, log, Vec3 = require('YFS:../e/lib/src/element/Telemeter.lua'), require('YFS:../e/lib/src/debug/Log.lua').Instance(), require('YFS:../e/lib/src/math/Vec3.lua')\n\n---@class FloorDetector\n---@field Instance fun():FloorDetector\n---@field Measure fun():TelemeterResult\n---@field Present fun():boolean\n---@field MaxDist fun():number\n---@field IsWithinShutdownDistance fun():boolean\n---@field IsParkingEnabled fun():boolean\n---@field ReturningHome fun()\n---@field IsReturningHome fun():boolean\n\nlocal FloorDetector        = {}\nFloorDetector.__index      = FloorDetector\n\nlocal inst\nlocal floorDetectorName    = \"FloorDetector\"\n\n---@return FloorDetector\nfunction FloorDetector.Instance()\n    if inst then return inst end\n\n    inst = {}\n    local enabled = false\n\n    local teleLink = library.getLinkByName(floorDetectorName)\n    local tele ---@type Telemeter|nil\n\n    if teleLink then\n        tele = Telemeter.New(teleLink)\n        if not tele.IsTelemeter() then\n            tele = nil\n        end\n    else\n        log.Error(\"No telementer by name '\", floorDetectorName, \"' found\")\n    end\n\n    function inst.Present()\n        return tele ~= nil\n    end\n\n    ---@return TelemeterResult\n    function inst.Measure()\n        if tele then\n            return tele.Measure()\n        else\n            return { Hit = false, Distance = 0, Point = Vec3.zero }\n        end\n    end\n\n    ---@return number #Max distance or 0\n    function inst.MaxDist()\n        return tele and tele.MaxDistance() or 0\n    end\n\n    return setmetatable(inst, FloorDetector)\nend\n\nreturn FloorDetector\n\nend)\npackage.preload['YFS:../e/lib/src/system/Timer.lua']=(function()\n---@class Timer Handles function registration/deregistration of tick functions\n---@field Instance fun():Timer Returns the singleton instance\n---@field Add fun(id:string, func:function, interval:number) Adds a timer with the given interval and callback function.\n---@field Remove fun(id:string) Removes a timer with the given id.\nlocal Timer = {}\nTimer.__index = Timer\n\nlocal singleton ---@type Timer\n\n---Returns a Timer instance\n---@return Timer\nfunction Timer.Instance()\n    if singleton then\n        return singleton\n    end\n\n    local s = {}\n    local functions = {}\n    local toRemove = {} ---@type string[]\n    local toAdd = {} ---@type {id:string, f:fun(), interval:number}\n\n    function s.Add(id, func, interval)\n        s.Remove(id)\n        toAdd[#toAdd + 1] = { id = id, f = func, interval = interval }\n        functions[id] = func\n    end\n\n    function s.Remove(id)\n        if functions[id] ~= nil then\n            toRemove[#toRemove + 1] = id\n            functions[id] = nil\n        end\n    end\n\n    ---@param tickId any\n    local function run(tickId)\n        local f = functions[tickId]\n        if f ~= nil then\n            f()\n        end\n    end\n\n    -- Can't call unit.stopTimer/startTimer from flush so to anbled that possibility,\n    -- we do it via the update event. The timers are based on framerate anyhow so the\n    -- delay this induces is of no consequence.\n    system:onEvent(\"onUpdate\", function()\n        while #toRemove > 0 do\n            unit.stopTimer(table.remove(toRemove, 1))\n        end\n        while #toAdd > 0 do\n            local add = table.remove(toAdd, 1)\n            unit.setTimer(add.id, add.interval)\n        end\n    end)\n\n    -- Register with du-luac event handler\n    unit:onEvent(\"onTimer\", function(unit, id)\n        run(id)\n    end)\n\n    singleton = setmetatable(s, Timer)\n    return singleton\nend\n\nreturn Timer\n\nend)\npackage.preload['YFS:Singletons.lua']=(function()\nlocal s = {\n    constants     = require('YFS:YFSConstants.lua'),\n    log           = require('YFS:../e/lib/src/debug/Log.lua').Instance(),\n    strUtil       = require('YFS:../e/lib/src/util/StringUtil.lua'),\n    commandLine   = require('YFS:../e/lib/src/commandline/CommandLine.lua').Instance(),\n    input         = require('YFS:../e/lib/src/input/Input.lua').Instance(),\n    pub           = require('YFS:../e/lib/src/util/PubSub.lua').Instance(),\n    calc          = require('YFS:../e/lib/src/util/Calc.lua'),\n    brakes        = require('YFS:flight/Brakes.lua').Instance(),\n    universe      = require('YFS:../e/lib/src/universe/Universe.lua').Instance(),\n    keys          = require('YFS:../e/lib/src/input/Keys.lua'),\n    gateCtrl      = require('YFS:controller/GateControl.lua').Instance(),\n    radar         = require('YFS:../e/lib/src/element/Radar.lua').Instance(),\n    floorDetector = require('YFS:controller/FloorDetector.lua').Instance(),\n    timer         = require('YFS:../e/lib/src/system/Timer.lua').Instance()\n}\n\nreturn s\n\nend)\npackage.preload['YFS:../e/lib/src/math/Plane.lua']=(function()\nrequire('YFS:../e/lib/src/abstraction/Vehicle.lua')\nlocal universe = require('YFS:../e/lib/src/universe/Universe.lua').Instance()\n\n---@alias Fun3 fun():Vec3\n\n---@class Plane\n---@field Up fun():Vec3\n---@field Right fun():Vec3\n---@field Forward fun():Vec3\n---@field NewByVertialReference fun():Plane\n---@field New fun(f:Fun3):Plane\n\nlocal Plane = {}\nPlane.__index = Plane\n\n---comment\n---@param verticalFunc fun():Vec3\n---@return Plane\nfunction Plane.New(verticalFunc)\n    local s = {}\n    local constructRight = Right\n\n    s.Up = verticalFunc\n\n    function s.Forward()\n        return s.Up():Cross(constructRight())\n    end\n\n    function s.Right()\n        -- Forward x Up instead of Up x Forward to get right instead of left dir\n        return s.Forward():Cross(s.Up())\n    end\n\n    return setmetatable(s, Plane)\nend\n\nfunction Plane.NewByVertialReference()\n    return Plane.New(function() return -universe.VerticalReferenceVector() end)\nend\n\nreturn Plane\n\nend)\npackage.preload['YFS:flight/Waypoint.lua']=(function()\nrequire('YFS:../e/lib/src/abstraction/Vehicle.lua')\nlocal si                                = require('YFS:Singletons.lua')\nlocal Plane                             = require('YFS:../e/lib/src/math/Plane.lua')\nlocal calc, universe                    = si.calc, si.universe\nlocal Ternary, max, abs, BetweenOrEqual = calc.Ternary, math.max, math.abs, calc.BetweenOrEqual\n\n---@enum WPReachMode\nWPReachMode                             = {\n    ENTRY = 1,\n    EXIT = 2\n}\n\n---@class Waypoint\n---@field New fun(destination:Vec3, finalSpeed:number, maxSpeed:number, margin:number):Waypoint\n---@field Destination fun():Vec3\n---@field DirectionMargin number\n---@field DirectionTo fun():Vec3\n---@field DistanceTo fun():number\n---@field FinalSpeed fun():number\n---@field IsLastInRoute fun():boolean\n---@field IsYawLocked fun():boolean\n---@field LockYawTo fun(direction:Vec3|nil, forced:boolean?)\n---@field Margin fun():number\n---@field MaxSpeed fun():number\n---@field Pitch fun(prev:Waypoint):Vec3|nil\n---@field Roll fun(prev:Waypoint):Vec3|nil\n---@field SetAlignmentAngleLimit fun(limit:number)\n---@field SetAlignmentDistanceLimit fun(limit:number)\n---@field SetPitchAlignmentThrustLimiter fun(angle:number)\n---@field SetLastInRoute fun(lastInRoute:boolean)\n---@field WithinMargin fun(mode:WPReachMode):boolean\n---@field Yaw fun(prev:Waypoint):Vec3|nil\n---@field LockedYawDirection fun():Vec3|nil\n---@field ForceUpAlongVerticalRef fun()\n---@field PathAlignmentDistanceLimitFromSurface fun():number\n---@field PreCalc fun(prev:Waypoint)\n---@field SetAutoPitch fun(enabled:boolean)\n\n\nlocal Waypoint = {}\nWaypoint.__index = Waypoint\n\n-- Return a direction target point this far from the waypoint so that in case we overshoot\n-- we don't get the point behind us and start turning around and also reduces oscilliating yaw.\nlocal directionMargin = 1000\nWaypoint.DirectionMargin = directionMargin\nlocal pathAlignmentAngleLimit, pathAlignmentDistanceLimit, pitchAlignmentThrustLimiter, autoPitch, gravPlane =\n    0, 0, 0, false, Plane.NewByVertialReference()\n\n---@param angle number\nfunction Waypoint.SetAlignmentAngleLimit(angle)\n    pathAlignmentAngleLimit = max(0, angle)\nend\n\n---@param distance number\nfunction Waypoint.SetAlignmentDistanceLimit(distance)\n    pathAlignmentDistanceLimit = max(0, distance)\nend\n\nfunction Waypoint.SetPitchAlignmentThrustLimiter(angle)\n    pitchAlignmentThrustLimiter = angle\nend\n\nfunction Waypoint.SetAutoPitch(enable)\n    autoPitch = enable\nend\n\n---Creates a new Waypoint\n---@param destination Vec3 The destination\n---@param finalSpeed number The final speed to reach when at the waypoint (0 if stopping is intended).\n---@param maxSpeed number The maximum speed to to travel at. Less than or equal to finalSpeed.\n---@param margin number The number of meters to be within for the waypoint to be considered reached\n---@param pathAlignmentDistanceLimitFromSurface number The minimum distance to the closest body where the construct will align topside along the path\n---@return Waypoint\nfunction Waypoint.New(destination, finalSpeed, maxSpeed, margin, pathAlignmentDistanceLimitFromSurface)\n    maxSpeed = Ternary(finalSpeed > maxSpeed and maxSpeed > 0, finalSpeed, maxSpeed) -- Guard against bad settings.\n    local yawLockDir = nil ---@type Vec3|nil\n    local lastInRoute, forceUpAlongVerticalRef, currentUp, useAutoPitch = false, false, Vec3.zero, autoPitch\n    local upPlane = Plane.New(function()\n        return currentUp\n    end)\n    local s = {}\n\n    ---Gets the vertical up reference to use\n    ---@param prev Waypoint Previous waypoint\n    ---@return Vec3\n    local function getCurrentUp(prev)\n        -- When next waypoint is nearly aligned with -gravity, use the line between them as the vertical reference instead to make following the path more exact.\n        local gravUp = gravPlane.Up()\n\n        if forceUpAlongVerticalRef then\n            return gravUp\n        end\n\n        local selectedRef = gravUp\n\n        local pathDirection = (destination - prev.Destination()):Normalize()\n        local body = universe.ClosestBody(Current())\n        local distanceToSurface = body.DistanceToHighestPossibleSurface(Current())\n        local awayFromWaypoints = s.DistanceTo() > pathAlignmentDistanceLimit and\n            prev.DistanceTo() > pathAlignmentDistanceLimit\n\n        if awayFromWaypoints then\n            local farOut = pathAlignmentDistanceLimitFromSurface > 0\n                and distanceToSurface > pathAlignmentDistanceLimitFromSurface\n\n            if farOut then\n                -- We're far out from the nearest body, allow aligning topside along path, even upside down\n                selectedRef = pathDirection\n                -- Disable auto pitch when tilting along the path\n                useAutoPitch = false\n            elseif pathAlignmentAngleLimit > 0 then           -- if zero, it means the alignment is disabled\n                local sameDir = gravUp:Dot(pathDirection) > 0 -- Same direction?\n                if sameDir and gravUp:AngleToDeg(pathDirection) < pathAlignmentAngleLimit then\n                    -- If we're more aligned to the path than the threshold, then align to the path\n                    selectedRef = pathDirection\n                elseif not sameDir and gravUp:AngleToDeg(-pathDirection) < pathAlignmentAngleLimit then\n                    -- Don't flip upside down\n                    selectedRef = -pathDirection\n                end\n            end\n        end\n\n\n        return selectedRef\n    end\n\n    ---Gets the destination\n    ---@return Vec3\n    function s.Destination()\n        return destination\n    end\n\n    ---Gets the final speed for the waypoint\n    ---@return number\n    function s.FinalSpeed()\n        return finalSpeed\n    end\n\n    ---Gets the max speed for the waypoint\n    ---@return number\n    function s.MaxSpeed()\n        return maxSpeed\n    end\n\n    ---Gets the margin for the waypoint\n    ---@return number\n    function s.Margin()\n        return margin\n    end\n\n    ---Indicates if the waypoint has been reached.\n    ---@param mode WPReachMode\n    ---@return boolean\n    function s.WithinMargin(mode)\n        local m = margin\n\n        if mode == WPReachMode.ENTRY then\n            if m > 1 then\n                m = m / 2\n            end\n        end\n\n        return s.DistanceTo() <= m\n    end\n\n    ---Gets the distance to the waypoint\n    ---@return number\n    function s.DistanceTo()\n        return (destination - Current()):Len()\n    end\n\n    ---Gets the direction to the waypoint\n    ---@return Vec3\n    function s.DirectionTo()\n        return (destination - Current()):NormalizeInPlace()\n    end\n\n    function s.SetLastInRoute(last)\n        lastInRoute = last\n    end\n\n    function s.IsLastInRoute()\n        return lastInRoute\n    end\n\n    function s.PathAlignmentDistanceLimitFromSurface()\n        return pathAlignmentDistanceLimitFromSurface\n    end\n\n    ---Locks the yaw direction to the given direction\n    ---@param direction Vec3|nil\n    ---@param forced boolean? If true, existing locks are overridden\n    function s.LockYawTo(direction, forced)\n        forced = forced or false\n        if yawLockDir == nil or forced then\n            yawLockDir = direction\n        end\n    end\n\n    function s.IsYawLocked()\n        return yawLockDir ~= nil\n    end\n\n    function s.LockedYawDirection()\n        return yawLockDir\n    end\n\n    ---@param prev Waypoint\n    function s.PreCalc(prev)\n        currentUp = getCurrentUp(prev)\n    end\n\n    function s.ForceUpAlongVerticalRef()\n        forceUpAlongVerticalRef = true\n    end\n\n    local function pitchKeepOrtogonalToUp()\n        return calc.ProjectPointOnPlane(upPlane.Right(), Current(), Current() + upPlane.Forward() * directionMargin)\n    end\n\n    ---@param prev Waypoint\n    ---@return Vec3|nil\n    function s.Roll(prev)\n        return calc.ProjectPointOnPlane(upPlane.Forward(), Current(), Current() + upPlane.Up() * directionMargin)\n    end\n\n    ---@param prev Waypoint\n    ---@return Vec3|nil\n    function s.Pitch(prev)\n        if useAutoPitch then\n            local moveDir, forward = Velocity():Normalize(), upPlane.Forward()\n\n            if s.DistanceTo() > 10 and Velocity():Len() > calc.Kph2Mps(50)\n                and BetweenOrEqual(moveDir:AngleToDeg(gravPlane.Up()), 40, 140) -- Prevent flipping backwards\n                -- Not going vertically\n                and BetweenOrEqual(gravPlane.Up():AngleToDeg(s.DirectionTo()), 15, 180 - 15)\n                -- Not reversing or strafing\n                and BetweenOrEqual(forward:AngleToDeg(s.DirectionTo()), 0, 75)\n            then\n                return Current() + moveDir * directionMargin\n            end\n        end\n\n        return pitchKeepOrtogonalToUp()\n    end\n\n    ---@param prev Waypoint\n    ---@return Vec3|nil\n    function s.Yaw(prev)\n        local dir\n\n        if yawLockDir then\n            dir = yawLockDir\n        elseif s.DistanceTo() > 50 then\n            -- Point towards the next point. Use the previous point as a reference when we get close to prevent spinning.\n            dir = s.DirectionTo()\n        else\n            dir = s.Destination() - prev.Destination()\n            dir:NormalizeInPlace()\n        end\n\n        -- To prevent spinning, lock yaw if we're aligning to vertical up\n        if not yawLockDir and abs(dir:Dot(currentUp)) > 0.9 then\n            s.LockYawTo(Forward(), false)\n            dir = Forward()\n        end\n\n        return calc.ProjectPointOnPlane(currentUp, Current(), Current() + dir * directionMargin)\n    end\n\n    return setmetatable(s, Waypoint)\nend\n\nreturn Waypoint\n\nend)\npackage.preload['YFS:GlobalTypes.lua']=(function()\nCriteria     = require('YFS:../e/lib/src/input/Criteria.lua')\nVec3         = require('YFS:../e/lib/src/math/Vec3.lua')\nTask         = require('YFS:../e/lib/src/system/Task.lua')\nPoint        = require('YFS:flight/route/Point.lua')\nPointOptions = require('YFS:flight/route/PointOptions.lua')\nStopwatch    = require('YFS:../e/lib/src/system/Stopwatch.lua')\nWaypoint     = require('YFS:flight/Waypoint.lua')\nPlane        = require('YFS:../e/lib/src/math/Plane.lua')\n\nend)\npackage.preload['YFS:../e/lib/src/element/Lock.lua']=(function()\nlocal SU = require('YFS:../e/lib/src/util/StringUtil.lua')\nlocal log = require('YFS:../e/lib/src/debug/Log.lua').Instance()\n\n---@enum EngineType\nEngineType = {\n    NOT_ENGINE = 0,\n    ATMO = 1,\n    SPACE = 2,\n    ROCKET = 3\n}\n\n---@enum EngineSize\nEngineSize = {\n    XS = 1,\n    S = 2,\n    M = 3,\n    L = 4,\n    XL = 5\n}\n\n---@alias EngineLimits table<EngineType, table<EngineSize, number>>\n\n\n---@param lowerName string\n---@return EngineSize\nlocal function getSize(lowerName)\n    if SU.EndsWith(lowerName, \" xs\") then return EngineSize.XS end\n    if SU.EndsWith(lowerName, \" s\") then return EngineSize.S end\n    if SU.EndsWith(lowerName, \" m\") then return EngineSize.M end\n    if SU.EndsWith(lowerName, \" l\") then return EngineSize.L end\n    return EngineSize.XL\nend\n\n---@param lowerName string\n---@return EngineType\nlocal function getType(lowerName)\n    if lowerName:match(\"atmospheric engine\") then\n        return EngineType.ATMO\n    elseif lowerName:match(\"space engine\") then\n        return EngineType.SPACE\n    elseif lowerName:match(\"rocket engine\") then\n        return EngineType.ROCKET\n    end\n\n    return EngineType.NOT_ENGINE\nend\n\n---@param t EngineType\nlocal function typeStr(t)\n    if t == EngineType.ATMO then return \"Atmospheric\" end\n    if t == EngineType.ROCKET then return \"Rocket\" end\n    return \"Space\"\nend\n\n---@param s EngineSize\n---@return string\nlocal function sizeStr(s)\n    if s == EngineSize.XS then return \"XS\" end\n    if s == EngineSize.S then return \"S\" end\n    if s == EngineSize.M then return \"M\" end\n    if s == EngineSize.L then return \"L\" end\n    return \"XL\"\nend\n\n---@class ElementLock\n---@field New fun():ElementLock\n---@field AddLimit fun(count:number, size:EngineSize, engineType:EngineType)\n---@field ValidateCo fun():boolean\n---@field NoLimit fun()\n\nlocal Lock = {}\nLock.__index = Lock\n\nfunction Lock.New()\n    local noLimit = math.mininteger\n    local s = {}\n    local limits = {} ---@type EngineLimits\n    local atmo = {} ---@type table<EngineSize, number>\n    limits[EngineType.ATMO] = atmo\n    local space = {} ---@type table<EngineSize, number>\n    limits[EngineType.SPACE] = space\n    local rocket = {} ---@type table<EngineSize, number>\n    limits[EngineType.ROCKET] = rocket\n\n    -- Default with none allowed\n    for i = EngineSize.XS, EngineSize.XL, 1 do\n        atmo[i] = 0\n        space[i] = 0\n        rocket[i] = 0\n    end\n\n    ---Sets a limit for the number of engines allowed of the given type and size\n    ---@param engineType EngineType\n    ---@param size EngineSize\n    ---@param count integer\n    function s.AddLimit(engineType, size, count)\n        limits[engineType][size] = count\n    end\n\n    ---@return boolean\n    function s.ValidateCo()\n        local res = true\n\n        local core = library.getCoreUnit()\n        for _, localId in ipairs(core.getElementIdList()) do\n            local id = core.getElementItemIdById(localId)\n            local item = system.getItem(id)\n            local withSize = item.displayNameWithSize:lower() ---@type string\n\n            local t = getType(withSize)\n            local size = getSize(withSize)\n\n            if t ~= EngineType.NOT_ENGINE then\n                local limit = limits[t]\n                if limit[size] ~= noLimit then\n                    limit[size] = limit[size] - 1\n                end\n            end\n\n            coroutine.yield()\n        end\n\n        -- Any engine that has a count of less than 0 there are to many of\n        for t = EngineType.ATMO, EngineType.ROCKET do\n            for size = EngineSize.XS, EngineSize.XL do\n                local count = limits[t][size]\n                if count ~= noLimit and count < 0 then\n                    log.Error(math.abs(count), \" too many engines of type: \", typeStr(t), \" \", sizeStr(size))\n                    res = false\n                end\n            end\n            coroutine.yield()\n        end\n\n        return res\n    end\n\n    return setmetatable(s, Lock)\nend\n\nreturn Lock\n\nend)\npackage.preload['YFS:version_out.lua']=(function()\nlocal version =\n{\n    APP_NAME = \"Yoarii's Flight System\",\n    APP_VERSION = \"850e7fe / 20231223 22:22\"\n}\n\nreturn version\n\nend)\npackage.preload['YFS:variants/CoreLinkCheck.lua']=(function()\nlocal s   = require('YFS:Singletons.lua')\nlocal log = s.log\n\n---Ensures that the core is linked and returns true if the control unit is an ECU\n---@return boolean\n---@return boolean\nlocal function ensureCoreLink()\n    local unitInfo = system.getItem(unit.getItemId())\n    local isECU = unitInfo.displayNameWithSize:lower():match(\"emergency\")\n\n    local linked = library.getCoreUnit() ~= nil\n    if not linked then\n        log.Error(unitInfo.displayNameWithSize, \" must be linked to the core.\")\n    end\n\n    return linked, isECU\nend\n\nreturn ensureCoreLink\n\nend)\npackage.preload['YFS:controller/ControlCommands.lua']=(function()\n---@module \"commandline/CommandLine\"\n---@module \"input/Input\"\n\nrequire('YFS:../e/lib/src/abstraction/Vehicle.lua')\nrequire('YFS:GlobalTypes.lua')\nlocal s                                                             = require('YFS:Singletons.lua')\nlocal log, brakes, calc, uni, keys, pub, constants, gateCtrl, radar = s.log, s.brakes, s.calc, s.universe, s.keys, s.pub,\n    s.constants, s.gateCtrl, s.radar\nlocal VertRef, plane                                                = uni.VerticalReferenceVector,\n    Plane.NewByVertialReference()\n\n---@alias PointOptionArguments { commandValue:string, maxspeed:number, margin:number, lockdir:boolean}\n---@alias ReturnData { g1:number[], g2:number[], g3:number[], fwd:number[] }\n\n---@class ControlCommands\n---@field New fun(input:Input, cmd:Command, flightCore:FlightCore)\n---@field RegisterCommonCommands fun(isECU:boolean)\n---@field RegisterRouteCommands fun()\n---@field RegisterMoveCommands fun()\n\nlocal ControlCommands                                               = {}\nControlCommands.__index                                             = ControlCommands\n\n---Creates a new RouteModeController\n---@param input Input\n---@param cmd CommandLine\n---@param flightCore FlightCore\n---@param settings Settings\n---@param screenCtrl ScreenController\n---@param access Access\n---@param routeDb BufferedDB\n---@return ControlCommands\nfunction ControlCommands.New(input, cmd, flightCore, settings, screenCtrl, access, routeDb)\n    local s = {}\n\n    local rc = flightCore.GetRouteController()\n\n    local function holdPosition()\n        local r = rc.ActivateTempRoute().AddCurrentPos()\n        r.Options().Set(PointOptions.LOCK_DIRECTION, { Forward():Unpack() })\n        flightCore.StartFlight()\n    end\n\n    ---@param c Command\n    local function addPointOptions(c)\n        c.Option(\"-lockdir\").AsEmptyBoolean().Default(false)\n        c.Option(\"-maxspeed\").AsNumber().Default(0)\n        c.Option(\"-margin\").AsNumber().Default(0.1)\n        c.Option(\"-forceVerticalUp\").AsBoolean().Default(true)\n    end\n\n    ---@param data PointOptionArguments\n    ---@return PointOptions\n    local function createOptions(data)\n        local opt = PointOptions.New()\n        opt.Set(PointOptions.MAX_SPEED, calc.Kph2Mps(data.maxspeed))\n        opt.Set(PointOptions.MARGIN, data.margin)\n\n        if data.lockdir then\n            opt.Set(PointOptions.LOCK_DIRECTION, { Forward():Unpack() })\n        end\n        return opt\n    end\n\n    ---@param isECU boolean\n    function s.RegisterCommonCommands(isECU)\n        -- Setup brakes\n        if not isECU then\n            local function b(on)\n                -- Always allow forced mode to be turned off\n                if player.isFrozen() or not on then\n                    brakes.Forced(on)\n                end\n            end\n\n            input.Register(keys.brake, Criteria.New().LCtrl().OnPress(), function() b(true) end)\n            input.Register(keys.brake, Criteria.New().LCtrl().OnRelease(), function() b(false) end)\n        end\n\n        cmd.Accept(\"idle\", function()\n            log.Info(\"Going idle!\")\n            flightCore.GoIdle()\n        end)\n\n        cmd.Accept(\"hold\", function()\n            holdPosition()\n        end)\n\n        cmd.Accept(\"print-pos\", function(_)\n            log.Info(\"Current pos:\", uni.CreatePos(Current()):AsPosString())\n            log.Info(\"Alignment pos:\",\n                uni.CreatePos(Current() + Forward() * Waypoint.DirectionMargin):AsPosString())\n        end)\n\n        local lastWidget = settings.Boolean(\"showWidgetsOnStart\", false)\n\n        input.Register(keys.option8, Criteria.New().LShift().OnPress(), function()\n            lastWidget = not lastWidget\n            pub.Publish(\"ShowInfoWidgets\", lastWidget)\n        end)\n\n        input.Register(keys.option0, Criteria.New().LShift().OnPress(), function()\n            radar.Show(not radar.IsVisible())\n        end)\n\n        input.Register(keys.option0, Criteria.New().OnPress(), function()\n            radar.NextMethod()\n        end)\n\n        input.Register(keys.gear, Criteria.New().OnPress(), function()\n            if IsFrozen() then\n                flightCore.StartParking((Current() - uni.ClosestBody(Current()).Geography.Center):Len(), \"Parking\")\n            end\n        end)\n\n        ---@param p Point\n        ---@param gate boolean\n        ---@param direction Vec3|nil\n        local setParkOpt = function(p, gate, direction)\n            local opt = p.Options()\n            opt.Set(PointOptions.MARGIN, settings.Number(\"parkMargin\"))\n            opt.Set(PointOptions.GATE, gate)\n            if direction then\n                opt.Set(PointOptions.LOCK_DIRECTION, { direction:Unpack() })\n            end\n        end\n\n        ---@param r Route\n        local function startReturnRoute(r)\n            r.AddTag(\"ReturnTag\")\n            gateCtrl.Enable(true)\n            pub.Publish(\"ResetWSAD\", true)\n            flightCore.StartFlight()\n        end\n\n        input.Register(keys.gear, Criteria.New().LCtrl().LShift().OnPress(), function()\n            if not IsFrozen() then return end\n\n            -- Park Pos\n            local c = Current()\n\n            -- Point above/below park pos\n            local g2 = c + plane.Up() * settings.Number(\"parkVertDist\")\n\n            -- Entry point\n            local g3 = c + plane.Forward() * settings.Number(\"parkForwardDist\") +\n                plane.Up() * settings.Number(\"parkVertDist\")\n\n            local returnData = {\n                g1 = { c:Unpack() },\n                g2 = { g2:Unpack() },\n                g3 = { g3:Unpack() },\n                fwd = { plane.Forward():Unpack() }\n            }\n\n            routeDb.Put(\"returnData\", returnData)\n\n            local r = rc.ActivateTempRoute(\"Undock\")\n            setParkOpt(r.AddCoordinate(c), settings.Boolean(\"parkUseGates\"), plane.Forward()) -- Point to open gates\n            setParkOpt(r.AddCoordinate(g2), false, plane.Forward())\n            setParkOpt(r.AddCoordinate(g3), false)\n            startReturnRoute(r)\n        end)\n\n        input.Register(keys.gear, Criteria.New().LShift().OnPress(), function()\n            if not IsFrozen() then return end\n\n            local d = routeDb.Get(\"returnData\", {})\n            ---@cast d ReturnData\n\n            local g1 = Vec3.New(d.g1)\n            local g2 = Vec3.New(d.g2)\n            local g3 = Vec3.New(d.g3)\n            local fwd = Vec3.New(d.fwd)\n\n            if not (g1:IsZero() and g2:IsZero() and g3:IsZero() and fwd:IsZero()) then\n                local r = rc.ActivateTempRoute(\"Returning\")\n                setParkOpt(r.AddCoordinate(g3), false)\n                setParkOpt(r.AddCoordinate(g2), false, fwd)\n                -- Move backwards to make return to actual start position\n                setParkOpt(r.AddCoordinate(g1), settings.Boolean(\"parkUseGates\"), fwd)\n                startReturnRoute(r)\n            end\n        end)\n    end\n\n    ---Get the route being edited\n    ---@return Route|nil\n    local function getEditRoute()\n        local route = rc.CurrentEdit()\n        if route == nil then\n            log.Error(\"No route being edited\")\n        end\n\n        return route\n    end\n\n    function s.RegisterRouteCommands()\n        cmd.Accept(\"route-list\", function(data)\n            local routes = rc.GetRouteNames()\n            log.Info(#routes, \" available routes\")\n            for _, r in ipairs(routes) do\n                log.Info(r)\n            end\n        end)\n\n        cmd.Accept(\"route-edit\",\n            ---@param data {commandValue:string}\n            function(data)\n                if rc.EditRoute(data.commandValue) then\n                    log.Info(\"Route open for edit\")\n                end\n            end).AsString()\n\n        cmd.Accept(\"route-create\",\n            ---@param data {commandValue:string}\n            function(data)\n                rc.CreateRoute(data.commandValue)\n            end).AsString().Must()\n\n        cmd.Accept(\"route-save\", function(data)\n            rc.SaveRoute()\n        end).AsEmpty()\n\n        cmd.Accept(\"route-discard\", function(data)\n            rc.Discard()\n        end)\n\n        cmd.Accept(\"route-delete\",\n            ---@param data {commandValue:string}\n            function(data)\n                rc.DeleteRoute(data.commandValue)\n            end).AsString().Must()\n\n        local renameRoute = cmd.Accept(\"route-rename\",\n            ---@param data {from:string, to:string}\n            function(data)\n                rc.RenameRoute(data.from, data.to)\n            end).AsEmpty()\n        renameRoute.Option(\"from\").AsString().Must()\n        renameRoute.Option(\"to\").AsString().Must()\n\n        cmd.Accept(\"route-print\", function(data)\n            local route = getEditRoute()\n            if route == nil then\n                return\n            end\n\n            for i, p in ipairs(route.Points()) do\n                log.Info(i, \":\", calc.Ternary(p.HasWaypointRef(), p.WaypointRef(), p.Pos()))\n\n                local opts = p.Options()\n                for k, v in pairs(opts.Data()) do\n                    log.Info(\"- \", k, \": \", v)\n                end\n            end\n        end)\n\n        cmd.Accept(\"route-activate\",\n            ---@param data {commandValue:string, index:number}\n            function(data)\n                if not access.MayStartRoute(data.commandValue) then\n                    return\n                end\n\n                if rc.ActivateRoute(data.commandValue, data.index,\n                        settings.Number(\"routeStartDistanceLimit\"),\n                        settings.Number(\"gateControlDistance\")) then\n                    gateCtrl.Enable(true)\n                    flightCore.StartFlight()\n                    pub.Publish(\"ResetWSAD\", true)\n                    log.Info(\"Flight started\")\n                end\n            end).AsString().Must()\n            .Option(\"index\").AsNumber()\n\n        local addCurrentToRoute = cmd.Accept(\"route-add-current-pos\",\n            ---@param data PointOptionArguments\n            function(data)\n                local route = getEditRoute()\n                if route == nil then\n                    return\n                end\n\n                local point = route.AddCurrentPos()\n                point.SetOptions(createOptions(data))\n                log.Info(\"Added current position to route\")\n            end).AsEmpty()\n\n        addPointOptions(addCurrentToRoute)\n\n        local addNamed = cmd.Accept(\"route-add-named-pos\",\n            ---@param data PointOptionArguments\n            function(data)\n                local ref = rc.LoadWaypoint(data.commandValue)\n\n                if ref then\n                    local route = getEditRoute()\n                    if route == nil then\n                        return\n                    end\n                    local p = route.AddWaypointRef(data.commandValue, ref.Pos())\n                    if p then\n                        p.SetOptions(createOptions(data))\n                        log.Info(\"Added position to route\")\n                    else\n                        log.Error(\"Could not add postion\")\n                    end\n                end\n            end).AsString()\n        addPointOptions(addNamed)\n\n        cmd.Accept(\"route-delete-pos\",\n            ---@param data {commandValue:number}\n            function(data)\n                local route = getEditRoute()\n                if route == nil then\n                    return\n                end\n                if route.RemovePoint(data.commandValue) then\n                    log.Info(\"Point removed\")\n                else\n                    log.Error(\"Could not remove point\")\n                end\n            end).AsNumber().Must()\n\n        ---@param from integer\n        ---@param to integer\n        local function movePoint(from, to)\n            local route = getEditRoute()\n            if route == nil then\n                return\n            end\n            if route.MovePoint(from, to) then\n                log.Info(\"Point moved:\", from, \" to \", to)\n            else\n                log.Error(\"Could not move point\")\n            end\n        end\n\n        local movePos = cmd.Accept(\"route-move-pos\",\n            ---@param data {from:number, to:number}\n            function(data)\n                movePoint(data.from, data.to)\n            end)\n        movePos.Option(\"from\").AsNumber().Must()\n        movePos.Option(\"to\").AsNumber().Must()\n\n        cmd.Accept(\"route-move-pos-forward\",\n            ---@param data {commandValue:number}\n            function(data)\n                local ix = data.commandValue\n                movePoint(ix, ix + 1)\n            end).AsNumber().Must()\n\n        cmd.Accept(\"route-move-pos-back\",\n            ---@param data {commandValue:number}\n            function(data)\n                local ix = data.commandValue\n                movePoint(ix, ix - 1)\n            end).AsNumber().Must()\n\n        local cmdSetPosOption = cmd.Accept(\"route-set-pos-option\",\n            ---@param data {ix:number, endIx:number, toggleSkippable:boolean, toggleSelectable:boolean, margin:boolean, finalSpeed:number, maxSpeed:number, toggleGate:boolean}\n            function(data)\n                local route = getEditRoute()\n                if route == nil then\n                    return\n                end\n\n                if not data.endIx then\n                    data.endIx = data.ix\n                end\n\n                if data.maxSpeed and data.maxSpeed < 0 then\n                    log.Error(\"Max speed must be larger than 0\")\n                    return\n                end\n\n                if data.ix > data.endIx then\n                    log.Error(\"Start index must be less or equal to end index\")\n                    return\n                end\n\n                if not (route.CheckBounds(data.ix) and route.CheckBounds(data.endIx)) then\n                    log.Error(\"Index out of bounds\")\n                    return\n                end\n\n                if data.margin and data.margin < 0.1 then\n                    log.Error(\"Margin must be larger or equal to 0.1m\")\n                    return\n                end\n\n                if data.finalSpeed and data.finalSpeed < 0 then\n                    log.Error(\"Final speed must be >= 0\")\n                    return\n                end\n\n                log.Info(\"Setting point options for point indexes \", data.ix, \" through \", data.endIx)\n\n                for i = data.ix, data.endIx, 1 do\n                    if data.toggleSkippable then\n                        local newValue = not route.GetPointOption(i, PointOptions.SKIPPABLE, false)\n                        if route.SetPointOption(i, PointOptions.SKIPPABLE, newValue) then\n                            log.Info(\"Set skippable option to \", newValue)\n                        end\n                    end\n\n                    if data.toggleSelectable then\n                        local newValue = not route.GetPointOption(i, PointOptions.SELECTABLE, true)\n                        if route.SetPointOption(i, PointOptions.SELECTABLE, newValue) then\n                            log.Info(\"Set selectable option to \", newValue)\n                        end\n                    end\n\n                    if data.margin then\n                        route.SetPointOption(i, PointOptions.MARGIN, data.margin)\n                    end\n\n                    if data.finalSpeed then\n                        route.SetPointOption(i, PointOptions.FINAL_SPEED, calc.Kph2Mps(data.finalSpeed))\n                    end\n\n                    if data.maxSpeed then\n                        route.SetPointOption(i, PointOptions.MAX_SPEED, calc.Kph2Mps(data.maxSpeed))\n                    end\n\n                    if data.toggleGate then\n                        local newValue = not route.GetPointOption(i, PointOptions.GATE, false)\n                        route.SetPointOption(i, PointOptions.GATE, newValue)\n                        log.Info(\"Set gate option to \", newValue)\n                    end\n                end\n            end).AsEmpty()\n        cmdSetPosOption.Option(\"ix\").AsNumber().Must()\n        cmdSetPosOption.Option(\"endIx\").AsNumber()\n        cmdSetPosOption.Option(\"toggleSkippable\").AsEmptyBoolean()\n        cmdSetPosOption.Option(\"toggleSelectable\").AsEmptyBoolean()\n        cmdSetPosOption.Option(\"margin\").AsNumber()\n        cmdSetPosOption.Option(\"finalSpeed\").AsNumber()\n        cmdSetPosOption.Option(\"maxSpeed\").AsNumber()\n        cmdSetPosOption.Option(\"toggleGate\").AsEmptyBoolean()\n\n        cmd.Accept(\"route-print-pos-options\",\n            ---@param data {commandValue:number}\n            function(data)\n                local route = getEditRoute()\n                if route == nil then\n                    return\n                end\n\n                for i, k in ipairs(PointOptions.ALL) do\n                    local val = route.GetPointOption(data.commandValue, k, nil)\n                    if val ~= nil then\n                        log.Info(k, \": \", val)\n                    end\n                end\n            end).AsNumber()\n\n        local saveCurrAs = cmd.Accept(\"pos-save-current-as\",\n            ---@param data {name:string, auto:boolean}\n            function(data)\n                if data.auto then\n                    local new = rc.FirstFreeWPName()\n                    if not new then\n                        log.Error(\"Could not find a free waypoint name\")\n                        return\n                    end\n\n                    data.name = new\n                elseif not data.name then\n                    log.Error(\"No name provided\")\n                    return\n                end\n\n                local pos = uni.CreatePos(Current()).AsPosString()\n                if rc.StoreWaypoint(data.name, pos) then\n                    log.Info(\"Current position saved as \", data.name)\n                end\n            end).AsEmpty()\n        saveCurrAs.Option(\"name\").AsString()\n        saveCurrAs.Option(\"auto\").AsEmptyBoolean()\n\n        cmd.Accept(\"pos-save-as\",\n            ---@param data {commandValue:string, pos:string}\n            function(data)\n                local p = uni.ParsePosition(data.pos)\n                if p then\n                    rc.StoreWaypoint(data.commandValue, p.AsPosString())\n                end\n            end).AsString().Must().Option(\"pos\").AsString().Must()\n\n        cmd.Accept(\"pos-list\", function(_)\n            for _, data in ipairs(rc.GetWaypoints()) do\n                log.Info(data.name, \": \", data.point:Pos())\n            end\n        end)\n\n        local rename = cmd.Accept(\"pos-rename\",\n            ---@param data {old:string, new:string}\n            function(data)\n                rc.RenameWaypoint(data.old, data.new)\n            end)\n        rename.Option(\"old\").Must().AsString()\n        rename.Option(\"new\").Must().AsString()\n\n        cmd.Accept(\"pos-delete\",\n            ---@param data {commandValue:string}\n            function(data)\n                local deleted = rc.DeleteWaypoint(data.commandValue)\n                if deleted then\n                    log.Info(\"Deleted waypoint: '\", data.commandValue, \"', position was \", deleted.pos)\n                end\n            end).AsString().Must()\n\n        local alongGrav = cmd.Accept(\"pos-create-along-gravity\",\n            ---@param data {commandValue:string, u:number}\n            function(data)\n                local pos = Current() - VertRef() * data.u\n                local posStr = uni.CreatePos(pos).AsPosString()\n                if rc.StoreWaypoint(data.commandValue, posStr) then\n                    log.Info(\"Stored postion \", posStr, \" as \", data.commandValue)\n                end\n            end).AsString().Must()\n        alongGrav.Option(\"-u\").AsNumber().Must()\n\n        local relative = cmd.Accept(\"pos-create-relative\",\n            ---@param data {commandValue:string, u:number, f:number, r:number}\n            function(data)\n                local f = data.f or 0\n                local u = data.u or 0\n                local r = data.r or 0\n                if f == 0 and u == 0 and r == 0 then\n                    log.Error(\"Must provide atleast one direction distance\")\n                else\n                    local pos = Current() + Forward() * f + Right() * r + Up() * u\n                    local posStr = uni.CreatePos(pos).AsPosString()\n                    if rc.StoreWaypoint(data.commandValue, posStr) then\n                        log.Info(\"Stored postion \", posStr, \" as \", data.commandValue)\n                    end\n                end\n            end).AsString().Must()\n        relative.Option(\"u\").AsNumber()\n        relative.Option(\"f\").AsNumber()\n        relative.Option(\"r\").AsNumber()\n\n        local printRelative = cmd.Accept(\"pos-print-relative\",\n            ---@param data {u:number, f:number, r:number}\n            function(data)\n                local f = data.f or 0\n                local u = data.u or 0\n                local r = data.r or 0\n                if f == 0 and u == 0 and r == 0 then\n                    log.Error(\"Must provide atleast one direction distance\")\n                else\n                    local pos = Current() + Forward() * f + Right() * r + Up() * u\n                    local posStr = uni.CreatePos(pos).AsPosString()\n                    log.Info(\"Position is at: \", posStr)\n                end\n            end)\n        printRelative.Option(\"u\").AsNumber()\n        printRelative.Option(\"f\").AsNumber()\n        printRelative.Option(\"r\").AsNumber()\n\n\n        ---@param data {x:number, y:number, z:number}\n        ---@return number\n        local function countProvidedVectorParts(data)\n            local count = 0\n\n            for _, value in ipairs({ \"x\", \"y\", \"z\" }) do\n                if data[value] ~= nil then count = count + 1 end\n            end\n\n            return count\n        end\n\n        local createVertRoute = cmd.Accept(\"create-vertical-route\",\n            ---@param data {commandValue:string, distance:number, followGravInAtmo:boolean, extraPointMargin:number, x:number, y:number, z:number}\n            function(data)\n                local partCount = countProvidedVectorParts(data)\n                local dir ---type @Vec3\n\n                if partCount == 0 then\n                    dir = -VertRef()\n                elseif partCount ~= 3 then\n                    log.Error(\"Either none or all three vector components must be provided\")\n                    return\n                else\n                    dir = Vec3.New(data.x, data.y, data.z)\n                end\n\n                local route = rc.CreateRoute(data.commandValue)\n                if route then\n                    local startPos = route.AddCurrentPos()\n                    local startOpt = startPos.Options()\n                    startOpt.Set(PointOptions.LOCK_DIRECTION, Forward())\n                    startOpt.Set(PointOptions.MARGIN, constants.flight.defaultStartEndMargin)\n\n                    local targetPos = Current() + dir * data.distance\n\n                    local startBody = uni.ClosestBody(Current())\n                    local startInAtmo = startBody:IsInAtmo(Current())\n                    local bodyClosestToEnd = uni.ClosestBody(targetPos)\n                    local endInAtmo = bodyClosestToEnd:IsInAtmo(targetPos)\n\n                    if data.followGravInAtmo then\n                        if startInAtmo and endInAtmo then\n                            log.Warning(\n                                \"Start and end point are in atmosphere, skipping additional gravity-aligned point in space.\")\n                        elseif endInAtmo and not startInAtmo then\n                            log.Error(\n                                \"Cannot calculate extra gravity aligned point when start point is not within atmosphere\")\n                            return\n                        elseif startInAtmo and not endInAtmo then\n                            local pointInSpace = Current() -\n                                VertRef() * startBody:DistanceToAtmoEdge(Current())\n                            -- Add a precentage of the distance between target and atmosphere edge\n                            local diff = (pointInSpace - targetPos):Len() * 0.05\n                            pointInSpace = pointInSpace - VertRef() * diff\n                            local extra = route.AddCoordinate(pointInSpace)\n                            extra.Options().Set(PointOptions.LOCK_DIRECTION, Forward())\n                            extra.Options().Set(PointOptions.MARGIN, data.extraPointMargin)\n                            log.Info(\"Added extra gravity-aligned point in space at \",\n                                extra.Pos(), \"with a margin of \", data.extraPointMargin, \"m\")\n                        end\n                    end\n\n                    local endPos = route.AddCoordinate(targetPos)\n                    local endOpt = endPos.Options()\n                    endOpt.Set(PointOptions.LOCK_DIRECTION, Forward())\n                    endOpt.Set(PointOptions.MARGIN, constants.flight.defaultStartEndMargin)\n\n                    if rc.SaveRoute() then\n                        log.Info(\"Created a route by name '\", data.commandValue,\n                            \"' with start at current position and direction with the endpoint at \", endPos.Pos())\n                    else\n                        log.Error(\"Could not create the route\")\n                    end\n                end\n            end).AsString().Must()\n        createVertRoute.Option(\"distance\").AsNumber().Must()\n        createVertRoute.Option(\"followGravInAtmo\").AsEmptyBoolean()\n        createVertRoute.Option(\"extraPointMargin\").AsNumber().Default(5)\n        createVertRoute.Option(\"x\").AsNumber()\n        createVertRoute.Option(\"y\").AsNumber()\n        createVertRoute.Option(\"z\").AsNumber()\n\n        ---@param v Vec3\n        local function formatVecParts(v)\n            return string.format(\"-x %0.14f -y %0.14f -z %0.14f\", v.x, v.y, v.z)\n        end\n\n        cmd.Accept(\"print-vertical-up\", function(_)\n            log.Info(formatVecParts(-VertRef()))\n        end)\n\n        local sub = cmd.Accept(\"sub-pos\",\n            ---@param data  {commandValue:string, sub:string|nil}\n            function(data)\n                local sub\n                if data.sub then\n                    local subPos = uni.ParsePosition(data.sub)\n                    if not subPos then\n                        return\n                    end\n\n                    sub = subPos.Coordinates()\n                else\n                    log.Info(\"No subtrahend specified, using current position\")\n                    sub = Current()\n                end\n\n                local pos = uni.ParsePosition(data.commandValue)\n                if pos then\n                    local diff = pos.Coordinates() - sub\n                    local dir, dist = diff:NormalizeLen()\n                    log.Info(\"-distance \", dist, \" \", formatVecParts(dir))\n                end\n            end).AsString().Must()\n        sub.Option(\"-sub\").AsString()\n\n        local closestOnLine = cmd.Accept(\"closest-on-line\",\n            ---@param data {a:string, b:string}\n            function(data)\n                local p1 = uni.ParsePosition(data.a)\n                local p2 = uni.ParsePosition(data.b)\n\n                if not (p1 and p2) then\n                    return\n                end\n\n                local p = calc.NearestPointOnLine(p1.Coordinates(),\n                    (p1.Coordinates() - p2:Coordinates()):NormalizeInPlace(), Current())\n                local closest = uni.CreatePos(p)\n                log.Info(\"Closest point on the line passing through a and b is at \", closest.AsPosString())\n            end)\n        closestOnLine.Option(\"a\").AsString().Must()\n        closestOnLine.Option(\"b\").AsString().Must()\n\n        cmd.Accept(\"get-parallel-from-route\",\n            ---@param data {commandValue:string}\n            function(data)\n                local r = rc.LoadRoute(data.commandValue)\n                if not r then\n                    return\n                end\n\n                local points = r.Points()\n                if #points < 2 then\n                    log.Error(\"Only one point in route, can't make a parallel point from that.\")\n                end\n\n                local second = uni.ParsePosition(points[2].Pos()):Coordinates()\n                local first = uni.ParsePosition(points[1].Pos()):Coordinates()\n                local diff = second - first\n\n                local dir, dist = diff:NormalizeLen()\n                log.Info(\"-distance \", dist, \" \", formatVecParts(dir))\n            end).AsString().Must()\n\n\n        cmd.Accept(\"floor\",\n            ---@param data {commandValue:string}\n            function(data)\n                screenCtrl.ActivateFloorMode(data.commandValue)\n            end).AsString().Must()\n    end\n\n    ---@param userInput string\n    ---@return {pos: string, coord:Vec3}|nil\n    local function getPos(userInput)\n        local target\n        local point = rc.LoadWaypoint(userInput)\n        if point then\n            target = { pos = point.Pos(), coord = uni.ParsePosition(point.Pos()).Coordinates() }\n        else\n            local pos = uni.ParsePosition(userInput)\n            if pos then\n                target = { pos = pos.AsPosString(), coord = pos.Coordinates() }\n            end\n        end\n\n        if not target then\n            log.Error(\"Given input is not a :pos{} string or a named waypoint\")\n        end\n\n        return target\n    end\n\n    ---@param target Vec3\n    ---@param lockDir boolean\n    ---@param maxSpeed number\n    ---@param margin number\n    ---@param forceVerticalUp boolean\n    local function executeMove(target, lockDir, maxSpeed, margin, forceVerticalUp)\n        if maxSpeed ~= 0 then\n            maxSpeed = calc.Kph2Mps(maxSpeed)\n        end\n\n        local lockToDir = Vec3.zero\n        if lockDir then\n            lockToDir = Forward()\n        end\n\n        gateCtrl.Enable(false)\n        flightCore.GotoTarget(target, lockToDir, margin, maxSpeed, 0, false, forceVerticalUp)\n        pub.Publish(\"ResetWSAD\", true)\n        log.Info(\"Moving to \", uni.CreatePos(target).AsPosString())\n    end\n\n    function s.RegisterMoveCommands()\n        ---@param data {commandValue:string, lockdir:boolean, maxspeed:number, margin:number, u:number, r:number, f:number, forceVerticalUp:boolean}\n        local moveFunc = function(data)\n            local target = Current() + Forward() * data.f + Right() * data.r - VertRef() * data.u\n\n            executeMove(target, data.lockdir, data.maxspeed, data.margin, data.forceVerticalUp)\n        end\n\n        local moveCmd = cmd.Accept(\"move\", moveFunc)\n        moveCmd.Option(\"-u\").AsNumber().Must().Default(0)\n        moveCmd.Option(\"-r\").AsNumber().Must().Default(0)\n        moveCmd.Option(\"-f\").AsNumber().Must().Default(0)\n        addPointOptions(moveCmd)\n\n        local gotoCmd = cmd.Accept(\"goto\",\n            ---@param data {commandValue:string, lockdir:boolean, maxspeed:number, margin:number, offset:number, forceVerticalUp:boolean}\n            function(data)\n                local target = getPos(data.commandValue)\n\n                if target then\n                    -- A negative offset means on the other side of the point\n                    local direction, distance = (target.coord - Current()):NormalizeLen()\n                    local remaining = distance - data.offset\n\n                    if remaining > 0 then\n                        executeMove(Current() + direction * remaining, data.lockdir, data.maxspeed, data.margin,\n                            data.forceVerticalUp)\n                    else\n                        log.Error(\"Offset larger than distance to target\")\n                    end\n                end\n            end).AsString().Must()\n        addPointOptions(gotoCmd)\n        gotoCmd.Option(\"offset\").AsNumber().Default(0)\n\n        local turnFunc = function(data)\n            -- Turn in the expected way, i.e. clockwise on positive values.\n            local angle = -data.commandValue\n            flightCore.Turn(angle, Up())\n        end\n\n        cmd.Accept(\"turn\", turnFunc).AsNumber()\n\n        local strafeFunc = function(data)\n            local route = rc.ActivateTempRoute()\n            local point = route.AddCoordinate(Current() +\n                Right() * data.commandValue)\n            local p = point.Options()\n            p.Set(PointOptions.LOCK_DIRECTION, { Forward():Unpack() })\n            p.Set(PointOptions.MAX_SPEED, data.maxspeed or MaxSpeed())\n\n            flightCore.StartFlight()\n        end\n\n        local strafeCmd = cmd.Accept(\"strafe\", strafeFunc).AsNumber()\n        strafeCmd.Option(\"-maxspeed\").AsNumber()\n\n        ---@param pos Position|nil\n        local function alignTo(pos)\n            if pos then\n                local route = rc.ActivateTempRoute()\n                route.AddCurrentPos()\n                flightCore.StartFlight()\n                flightCore.AlignTo(pos.Coordinates())\n                log.Info(\"Aligning to \", pos.AsPosString())\n            end\n        end\n\n        cmd.Accept(\"align-to\",\n            ---@param data {commandValue:string}\n            function(data)\n                local target = getPos(data.commandValue)\n                if target then\n                    local pos = uni.ParsePosition(target.pos)\n                    alignTo(pos)\n                end\n            end).AsString().Must()\n\n        local alignToVector = cmd.Accept(\"align-to-vector\",\n            ---@param data {x:number, y:number, z:number}\n            function(data)\n                local pos = uni.CreatePos(Current() + Vec3.New(data.x, data.y, data.z))\n                alignTo(pos)\n            end)\n\n        alignToVector.Option(\"x\").AsNumber().Must()\n        alignToVector.Option(\"y\").AsNumber().Must()\n        alignToVector.Option(\"z\").AsNumber().Must()\n\n        cmd.Accept(\"set-waypoint\",\n            ---@param data {commandValue:string, notify:boolean}\n            function(data)\n                system.setWaypoint(data.commandValue, data.notify)\n            end).AsString()\n            .Option(\"notify\").AsEmptyBoolean()\n\n        local posAbove = cmd.Accept(\"position-above\",\n            ---@param data {cx:number, cy:number, cz:number, fx:number, fy:number, fz:number, heightMargin:number}\n            function(data)\n                local center = Vec3.New(data.cx, data.cy, data.cz)\n                local forward = Vec3.New(data.fx, data.fy, data.fz)\n                log.Info(\"Positioning above \", uni.CreatePos(center).AsPosString(), \", with forward direction to \",\n                    uni.CreatePos(forward).AsPosString())\n\n                --[[\n\n                Create a route:\n                - From current position\n                - 5m up\n                - 5m above center, aligned towards the forward element\n                - On center-element, plus half vertical size of construct\n\n                ]]\n\n                local r = rc.ActivateTempRoute()\n                r.AddCurrentPos()\n                r.AddCoordinate(Current() - VertRef() * data.heightMargin)\n                local upAtCenter = (center - uni.ClosestBody(center).Geography.Center):Normalize()\n                forward = calc.ProjectPointOnPlane(upAtCenter, center, forward) -- Project on same plane as center\n                local dir = (forward - center):Normalize()\n                r.AddCoordinate(center + upAtCenter * data.heightMargin).Options().Set(PointOptions.LOCK_DIRECTION, dir)\n\n                r.AddCoordinate(center).Options().Set(PointOptions.LOCK_DIRECTION, dir)\n\n                flightCore.StartFlight()\n            end).AsEmpty()\n        posAbove.Option(\"heightMargin\").AsNumber().Must()\n        posAbove.Option(\"cx\").AsNumber().Must()\n        posAbove.Option(\"cy\").AsNumber().Must()\n        posAbove.Option(\"cz\").AsNumber().Must()\n        posAbove.Option(\"fx\").AsNumber().Must()\n        posAbove.Option(\"fy\").AsNumber().Must()\n        posAbove.Option(\"fz\").AsNumber().Must()\n    end\n\n    settings.Callback(\"dockingMode\",\n        ---@param mode number\n        function(mode)\n            mode = calc.Clamp(mode, 1, 3)\n            construct.setDockingMode(mode)\n        end)\n\n    return setmetatable(s, ControlCommands)\nend\n\nreturn ControlCommands\n\nend)\npackage.preload['YFS:../e/lib/src/util/Pagination.lua']=(function()\n--local calc = requ ire(\"util/Calc\")\nlocal p = {}\n\n---Paginates the list\n---@generic T\n---@param list T[]\n---@param page integer\n---@param perPage integer\n---@return T[]\nfunction p.Paginate(list, page, perPage)\n    if #list == 0 then return {} end\n\n    local totalPages = p.GetPageCount(list, perPage)\n    --page = calc.Clamp(page, 1, totalPages)\n    page = math.min(totalPages, math.max(page, 1))\n\n    local startIx = (page - 1) * perPage + 1\n    local endIx = startIx + perPage - 1\n\n    local res = {} ---@type string[]\n    local ix = 1\n\n    for i = startIx, endIx, 1 do\n        res[ix] = list[i]\n        ix = ix + 1\n    end\n\n    return res\nend\n\n---Gets the number of pages we can make out of the list\n---@generic T\n---@param list T[]\n---@param perPage integer\n---@return integer\nfunction p.GetPageCount(list, perPage)\n    return math.ceil(#list / perPage)\nend\n\nreturn p\n\nend)\npackage.preload['YFS:flight/route/Route.lua']=(function()\n--[[\n    A route holds a series of Point that each contains the data needed to create a Waypoint.\n    When loaded, additional points may be inserted to to create a route that is smooth to fly\n    and that doesn't pass through a planetary body. Extra points are not persisted.\n]]\n\n\nrequire('YFS:../e/lib/src/abstraction/Vehicle.lua')\nrequire('YFS:GlobalTypes.lua')\nlocal s                               = require('YFS:Singletons.lua')\nlocal log, universe, calc, pagination = s.log, s.universe, s.calc, require('YFS:../e/lib/src/util/Pagination.lua')\nrequire('YFS:../e/lib/src/util/Table.lua')\n\n---@module \"Vec3\"\n\n---@alias RouteRemainingInfo {Legs:integer, TotalDistance:number}\n\n---@class Route Represents a route\n---@field New fun():Route\n---@field Points fun():Point[]\n---@field AddPos fun(positionString:string):Point\n---@field AddCoordinate fun(coord:Vec3):Point\n---@field AddWaypointRef fun(namedWaypoint:string, pos?:string):Point|nil\n---@field AddCurrentPos fun():Point\n---@field AddPoint fun(sp:Point)\n---@field CheckBounds fun(ix:integer):boolean\n---@field SetPointOption fun(pointIndex:number, optionName:string, value:string|boolean|number):boolean\n---@field GetPointOption fun(pointIndex:number, optionName:string, default:string|boolean|nil):string|number|boolean|nil\n---@field Clear fun()\n---@field Next fun():Point|nil\n---@field Peek fun():Point|nil\n---@field LastPointReached fun():boolean\n---@field AdjustRouteBasedOnTarget fun(startPos:Vec3, targetIndex:number, gateControlDistance:number)\n---@field FindClosestLeg fun(coordinate:Vec3):number,number\n---@field FindClosestPositionAlongRoute fun(coord:Vec3):Vec3\n---@field RemovePoint fun(ix:number):boolean\n---@field MovePoint fun(from:number, to:number)\n---@field GetRemaining fun(fromPos:Vec3):RouteRemainingInfo\n---@field GetPointPage fun(page:integer, perPage:integer):Point[]\n---@field GetPageCount fun(perPage:integer):integer\n---@field WaitForGate fun(current:Vec3, margin:number):boolean\n---@field HasTag fun(t:string):boolean\n---@field AddTag fun(t:string)\nlocal Route = {}\nRoute.__index = Route\n\n---Creates a new route\n---@return Route\nfunction Route.New()\n    local s = {}\n\n    local points = {} ---@type Point[]\n    local nextPointIx = 1\n    local tags = {} ---@type table<string, boolean>\n\n    ---@param ix number\n    ---@return Vec3\n    local function coordsFromPoint(ix)\n        return universe.ParsePosition(points[ix]:Pos()):Coordinates()\n    end\n\n    ---Returns true if the index is within bounds\n    ---@param ix integer\n    ---@return boolean\n    function s.CheckBounds(ix)\n        return ix > 0 and ix <= #points\n    end\n\n    ---Returns all the points in the route\n    ---@return Point[]\n    function s.Points()\n        return points\n    end\n\n    ---Adds a ::pos{} string\n    ---@param positionString string\n    ---@return Point|nil\n    function s.AddPos(positionString)\n        local pos = universe.ParsePosition(positionString)\n\n        if pos == nil then\n            log.Error(\"Could not add position to route\")\n            return nil\n        end\n\n        return s.AddPoint(Point.New(pos:AsPosString()))\n    end\n\n    ---Adds a coordinate to the route\n    ---@param coord Vec3\n    ---@return Point\n    function s.AddCoordinate(coord)\n        return s.AddPoint(Point.New(universe.CreatePos(coord):AsPosString()))\n    end\n\n    ---Adds a named waypoint to the route\n    ---@param name string\n    ---@param pos? string The ::pos{} string. This parameter is mainly used when editing routes to make the position available for the UI.\n    ---@return Point|nil\n    function s.AddWaypointRef(name, pos)\n        if name == nil or #name == 0 then\n            return nil\n        end\n        return s.AddPoint(Point.New(pos or \"\", name))\n    end\n\n    ---Adds the current postion to the route\n    ---@return Point\n    function s.AddCurrentPos()\n        return s.AddCoordinate(Current())\n    end\n\n    ---Adds a Point to the route\n    ---@param point Point\n    ---@return Point\n    function s.AddPoint(point)\n        points[#points + 1] = point\n        return point\n    end\n\n    ---@param pointIndex integer\n    ---@param optionName string\n    ---@param value string|boolean|number\n    ---@return boolean\n    function s.SetPointOption(pointIndex, optionName, value)\n        if s.CheckBounds(pointIndex) then\n            points[pointIndex].Options().Set(optionName, value)\n            return true\n        else\n            log.Error(\"Point index outside bounds\")\n            return false\n        end\n    end\n\n    ---@param pointIndex number\n    ---@param optionName string\n    ---@param default string|number|boolean|nil\n    ---@return string|number|boolean|nil\n    function s.GetPointOption(pointIndex, optionName, default)\n        if s.CheckBounds(pointIndex) then\n            local opt = points[pointIndex].Options()\n            return opt.Get(optionName, default)\n        else\n            log.Error(\"Point index outside bounds\")\n        end\n\n        return default\n    end\n\n    ---Clears the route\n    function s.Clear()\n        points = {}\n        nextPointIx = 1\n    end\n\n    ---Returns the next point in the route or nil if the end has been reached\n    ---@return Point|nil\n    function s.Next()\n        if s.LastPointReached() then return nil end\n\n        local p = points[nextPointIx]\n        nextPointIx = nextPointIx + 1\n\n        return p\n    end\n\n    function s.LastPointReached()\n        return nextPointIx > #points\n    end\n\n    local function reverse()\n        -- To ensure that we hold the same direction going backwards as we did when going forward,\n        -- we must shift the directions one step left before reversing.\n        -- Note that this is a destructive operation as we loose the original direction on the first point.\n        for i = 1, #points - 1 do\n            points[i].Options().Set(PointOptions.LOCK_DIRECTION, points[i + 1].Options().Get(PointOptions.LOCK_DIRECTION))\n        end\n\n        ReverseInplace(points)\n    end\n\n    ---Finds the closest point on the route\n    ---@param probeCoord Vec3\n    ---@param margin number\n    ---@return Point[]\n    function s.FindPointsWithin(probeCoord, margin)\n        local found = {} ---@type Point[]\n\n        for i, p in ipairs(points) do\n            local coords = coordsFromPoint(i)\n            if probeCoord:Dist(coords) <= margin then\n                found[#found + 1] = p\n            end\n        end\n\n        return found\n    end\n\n    ---@param coordinate Vec3\n    ---@return number # Start index\n    ---@return number # End index\n    function s.FindClosestLeg(coordinate)\n        local startIx = 1\n        local endIx = 2\n\n        local closest = math.maxinteger\n        local prev = coordsFromPoint(1)\n\n        for i = 2, #points, 1 do\n            local next = coordsFromPoint(i)\n\n            local dist = coordinate:Dist(calc.NearestOnLineBetweenPoints(prev, next, coordinate))\n\n            -- Find the first closest leg. If a second leg at the same distance is found, it will be ignored.\n            if dist < closest then\n                closest = dist\n                startIx = i - 1\n                endIx = i\n            end\n\n            prev = next\n        end\n\n        return startIx, endIx\n    end\n\n    ---@param coord Vec3\n    ---@return Vec3\n    function s.FindClosestPositionAlongRoute(coord)\n        local startIx, endIx = s.FindClosestLeg(coord)\n        return calc.NearestOnLineBetweenPoints(coordsFromPoint(startIx), coordsFromPoint(endIx), coord)\n    end\n\n    ---@param startIx number First index to keep\n    ---@param endIx number Last index to keep\n    ---@param currentLegStartIx number Start index of leg we're currently on\n    ---@param currentLegEndIx number End index of the leg we're currently on\n    local function keep(startIx, endIx, currentLegStartIx, currentLegEndIx)\n        local toKeep = {}\n\n        for i = startIx, endIx do\n            local skippable = points[i].Options().Get(PointOptions.SKIPPABLE, false)\n            if i == startIx\n                or i == endIx\n                or i == currentLegStartIx\n                or i == currentLegEndIx\n                or not skippable then\n                toKeep[#toKeep + 1] = points[i]\n            end\n        end\n\n        points = toKeep\n    end\n\n    ---Replaces a point in the route, keping options from original point\n    ---@param currentPos Vec3 Current position\n    ---@param gateControlDistance number\n    local function replaceStartPoint(currentPos, gateControlDistance)\n        local nearestPos = s.FindClosestPositionAlongRoute(currentPos)\n        local opt = points[1].Options().Clone()\n        opt.Set(PointOptions.GATE,\n            opt.Get(PointOptions.GATE, false) and coordsFromPoint(1):Dist(currentPos) < gateControlDistance)\n\n        -- Also take direction of the next point, so that when moving to the path we orient in the direction we're going to travel.\n        opt.Set(PointOptions.LOCK_DIRECTION, points[2].Options().Get(PointOptions.LOCK_DIRECTION))\n\n        points[1] = Point.New(universe.CreatePos(nearestPos):AsPosString(), nil, opt)\n    end\n\n    ---Adjust the route so that it will be traveled in the correct direction.\n    ---@param startPos Vec3\n    ---@param targetIndex number\n    ---@param gateControlDistance number\n    function s.AdjustRouteBasedOnTarget(startPos, targetIndex, gateControlDistance)\n        -- Determine if we are before or after the target point\n        local legStartIx, legEndIx = s.FindClosestLeg(startPos)\n\n        local adjChar\n        local orgCount = #points\n\n        if legEndIx <= targetIndex then\n            -- Our current pos is on an earlier or same leg as the one that has the target index\n            adjChar = \"A\"\n            keep(legStartIx, targetIndex, legStartIx, legEndIx)\n        else\n            -- We're currently on a leg after the target index\n            adjChar = \"B\"\n            keep(targetIndex, legEndIx, legStartIx, legEndIx)\n            reverse()\n        end\n\n        replaceStartPoint(startPos, gateControlDistance)\n\n        log.Info(\"Route adjusted (\", adjChar, \": \", orgCount, \" -> \", #points, \")\")\n    end\n\n    ---Remove the point at index ix\n    ---@param ix number\n    function s.RemovePoint(ix)\n        if not s.CheckBounds(ix) then return false end\n\n        table.remove(points, ix)\n        return true\n    end\n\n    ---Move a point from index 'from' to index 'to'\n    ---@param from number\n    ---@param to number\n    function s.MovePoint(from, to)\n        if not s.CheckBounds(from) or not s.CheckBounds(to) or to == from then return false end\n\n        local v = table.remove(points, from)\n        table.insert(points, to, v)\n\n        return true\n    end\n\n    ---@param fromPos Vec3\n    ---@return RouteRemainingInfo\n    function s.GetRemaining(fromPos)\n        local total = 0\n        local prev\n\n        for i = nextPointIx, #points, 1 do\n            local pos = universe.ParsePosition(points[i].Pos())\n            if pos then\n                if prev then\n                    total = total + (prev - pos.Coordinates()):Len()\n                end\n\n                prev = pos.Coordinates()\n            end\n        end\n\n        -- Add distance to next point in route\n        local ix = calc.Ternary(s.LastPointReached(), -1, 0)\n        local next = coordsFromPoint(nextPointIx + ix)\n        total = total + (fromPos - next):Len()\n\n        return { Legs = #points - nextPointIx, TotalDistance = total }\n    end\n\n    ---@param page integer\n    ---@param perPage integer\n    ---@return Point[]\n    function s.GetPointPage(page, perPage)\n        return pagination.Paginate(s.Points(), page, perPage)\n    end\n\n    ---@param perPage integer\n    ---@return integer\n    function s.GetPageCount(perPage)\n        return pagination.GetPageCount(s.Points(), perPage)\n    end\n\n    ---Determines if we should wait for gates at the current position.\n    ---@param current Vec3\n    ---@param margin number\n    ---@return boolean\n    function s.WaitForGate(current, margin)\n        -- Find the points within margin\n        local closest = s.FindPointsWithin(current, margin)\n\n        -- If any point has gate option set then we should wait for the gate.\n        for _, p in ipairs(closest) do\n            if p.Options().Get(PointOptions.GATE, false) then\n                return true\n            end\n        end\n\n        return false\n    end\n\n    ---@param t string\n    function s.AddTag(t)\n        tags[t] = true\n    end\n\n    ---@param t string\n    ---@return boolean\n    function s.HasTag(t)\n        return tags[t] ~= nil\n    end\n\n    return setmetatable(s, Route)\nend\n\nreturn Route\n\nend)\npackage.preload['YFS:../e/lib/src/util/DistanceFormat.lua']=(function()\nlocal oneSU = 200000\nlocal oneKm = 1000\n\n---@param distance number\n---@return {value:number, unit:string}\nfunction DistanceFormat(distance)\n    if distance >= oneSU then\n        return { value = distance / oneSU, unit = \"su\" }\n    elseif distance >= oneKm then\n        return { value = distance / oneKm, unit = \"km\" }\n    else\n        return { value = distance, unit = \"m\" }\n    end\nend\n\nreturn DistanceFormat\n\nend)\npackage.preload['YFS:flight/route/RouteController.lua']=(function()\nrequire('YFS:../e/lib/src/abstraction/Vehicle.lua')\nrequire('YFS:GlobalTypes.lua')\nlocal s                                 = require('YFS:Singletons.lua')\nlocal log, pub, universe, constants     = s.log, s.pub, s.universe, s.constants\n\nlocal Route, pagination, distanceFormat = require('YFS:flight/route/Route.lua'), require('YFS:../e/lib/src/util/Pagination.lua'),\n    require('YFS:../e/lib/src/util/DistanceFormat.lua')\nrequire('YFS:../e/lib/src/util/Table.lua')\n\n---@alias NamedWaypoint {name:string, point:Point}\n---@alias WaypointMap table<string,PointPOD>\n---@alias RouteData {points:PointPOD[], gateControl:{waitAtStart:boolean, waitAtEnd:boolean}}\n---@alias SelectablePoint {visible:boolean, name:string, activate:string, index:number}\n---@module \"storage/BufferedDB\"\n\n---@class RouteController\n---@field GetRouteNames fun():string[]\n---@field GetPageCount fun(perPage:integer):integer\n---@field GetRoutePage fun(page:integer, perPage:integer):string[]\n---@field LoadRoute fun(name:string):Route|nil\n---@field LoadFloorRoute fun(name:string):Route\n---@field DeleteRoute fun(name:string)\n---@field StoreRoute fun(name:string, route:Route):boolean\n---@field RenameRoute fun(from:string, to:string)\n---@field StoreWaypoint fun(name:string, pos:string):boolean\n---@field GetWaypoints fun():NamedWaypoint[]\n---@field LoadWaypoint fun(name:string, waypoints?:table<string,Point>):Point|nil\n---@field DeleteWaypoint fun(name:string):PointPOD|nil\n---@field CurrentRoute fun():Route|nil\n---@field CurrentEdit fun():Route|nil\n---@field CurrentEditName fun():string|nil\n---@field ActivateRoute fun(name:string, destinationWayPointIndex?:number, startMargin?:number, gateControlDistance?:number):boolean\n---@field ActivateTempRoute fun(name:string|nil):Route\n---@field CreateRoute fun(name:string):Route|nil\n---@field SaveRoute fun():boolean\n---@field Discard fun()\n---@field Count fun():integer\n---@field ActiveRouteName fun():string|nil\n---@field ActivateHoldRoute fun()\n---@field GetWaypointPage fun(page:integer, perPage:integer):NamedWaypoint[]\n---@field GetWaypointPages fun(perPage:integer):integer\n---@field FloorRoute fun():Route\n---@field FloorRouteName fun():string|nil\n---@field EditRoute fun(name:string):Route|nil\n---@field SelectableFloorPoints fun():SelectablePoint[]\n---@field CalculateDistances fun(points:Point[]):number[]\n---@field FirstFreeWPName fun():string|nil\n---@field RenameWaypoint fun(old:string, new:string):boolean\n\nlocal RouteController = {}\nRouteController.__index = RouteController\nlocal singleton\n\nRouteController.NAMED_POINTS = \"NamedPoints\"\nRouteController.NAMED_ROUTES = \"NamedRoutes\"\n\n---Create a new route controller instance\n---@param bufferedDB BufferedDB\n---@return RouteController\nfunction RouteController.Instance(bufferedDB)\n    if singleton then\n        return singleton\n    end\n\n    local s = {}\n\n    local db = bufferedDB\n    local current ---@type Route|nil\n    local edit ---@type Route|nil\n    local editName ---@type string|nil\n    local activeRouteName ---@type string|nil\n    local floorRoute ---@type Route|nil\n    local floorRouteName ---@type string|nil\n\n    ---Returns the the name of all routes, with \"(editing)\" appended to the one currently being edited.\n    ---@return string[]\n    function s.GetRouteNames()\n        local routes = db.Get(RouteController.NAMED_ROUTES) or {}\n        local res = {} ---@type string[]\n        ---@cast routes table\n        for name, _ in pairs(routes) do\n            if name == editName then\n                name = name .. \" (editing)\"\n            end\n            table.insert(res, name)\n        end\n\n        table.sort(res)\n\n        return res\n    end\n\n    ---@param page integer\n    ---@param perPage integer\n    ---@return string[]\n    function s.GetRoutePage(page, perPage)\n        return pagination.Paginate(s.GetRouteNames(), page, perPage)\n    end\n\n    ---@param perPage integer\n    ---@return integer\n    function s.GetPageCount(perPage)\n        return pagination.GetPageCount(s.GetRouteNames(), perPage)\n    end\n\n    ---@param page integer\n    ---@param perPage integer\n    ---@return NamedWaypoint[]\n    function s.GetWaypointPage(page, perPage)\n        return pagination.Paginate(s.GetWaypoints(), page, perPage)\n    end\n\n    ---@param perPage integer\n    ---@return integer\n    function s.GetWaypointPages(perPage)\n        return pagination.GetPageCount(s.GetWaypoints(), perPage)\n    end\n\n    ---@return table<string, NamedWaypoint>\n    local function makeWPLookup()\n        -- Make a table for quick lookup\n        local wps = {}\n        for _, p in ipairs(s.GetWaypoints()) do\n            wps[p.name] = p\n        end\n\n        return wps\n    end\n\n    ---@return string|nil\n    function s.FirstFreeWPName()\n        local wps = makeWPLookup()\n\n        for i = 1, 999 do\n            local new = string.format(\"WP%0.3d\", i)\n            if wps[new] == nil then\n                return new\n            end\n        end\n\n        return nil\n    end\n\n    ---@param old string\n    ---@param new string\n    function s.RenameWaypoint(old, new)\n        local wps = makeWPLookup()\n        local oldFound = wps[old]\n        local newFound = wps[new]\n\n        if not oldFound then\n            log.Info(\"No waypoint by that name found\")\n            return\n        elseif newFound then\n            log.Info(\"A waypoint by that name already exists\")\n        end\n\n        Task.New(\"RenameWaypoint\", function()\n            if edit ~= nil then\n                log.Error(\"Can't rename a waypoint when a route is being edited\")\n                return\n            end\n\n            s.StoreWaypoint(new, oldFound.point:Pos())\n\n            for _, name in pairs(s.GetRouteNames()) do\n                local r = s.LoadRoute(name)\n                if r then\n                    local switched = false\n                    for _, p in ipairs(r.Points()) do\n                        if p.HasWaypointRef() and p.WaypointRef() == old then\n                            switched = true\n                            p.SetWaypointRef(new)\n                            log.Info(\"Waypoint ref. updated in route '\", name, \"': '\", old, \"' -> '\", new, \"'\")\n                        end\n                    end\n\n                    if switched then\n                        s.StoreRoute(name, r)\n                    end\n                end\n                coroutine.yield()\n            end\n\n            -- Delete last so that routes using it can be loaded.\n            s.DeleteWaypoint(old)\n        end)\n    end\n\n    ---Returns the number of routes\n    ---@return integer\n    function s.Count()\n        return TableLen(s.GetRouteNames())\n    end\n\n    ---Indicates if the route exists\n    ---@param name string\n    ---@return boolean\n    function s.routeExists(name)\n        local routes = db.Get(RouteController.NAMED_ROUTES) or {}\n        return routes[name] ~= nil\n    end\n\n    ---Loads a named route\n    ---@param name string The name of the route to load\n    ---@return Route|nil\n    function s.LoadRoute(name)\n        local routes = db.Get(RouteController.NAMED_ROUTES) or {}\n        local data = routes[name] ---@type RouteData\n\n        if data == nil then\n            log.Error(\"No route by name '\", name, \"' found.\")\n            return nil\n        end\n\n        local route = Route.New()\n\n        -- For backwards compatibility, check if we have points as a sub property or not.\n        -- This can be removed once all the development constructs have had their routes resaved.\n        if not data.points then\n            log.Warning(\"Route is in an old format, please re-save it!\")\n            data.points = data\n        end\n\n        for _, point in ipairs(data.points) do\n            local p = Point.LoadFromPOD(point)\n\n            if p.HasWaypointRef() then\n                local wpName = p.WaypointRef()\n                log.Debug(\"Loading waypoint reference '\", wpName, \"'\")\n                local wp = s.LoadWaypoint(wpName)\n                if wp == nil then\n                    log.Error(\"The referenced waypoint '\", wpName, \"' in route '\", name, \"' was not found\")\n                    return nil\n                end\n\n                -- Replace the point\n                p = Point.New(wp.Pos(), wpName, p.Options())\n            end\n\n            route.AddPoint(p)\n        end\n\n        log.Info(\"Route '\", name, \"' loaded\")\n\n        return route\n    end\n\n    ---@return Route|nil\n    function s.LoadFloorRoute(name)\n        floorRoute = s.LoadRoute(name)\n        if s then\n            floorRouteName = name\n        else\n            floorRouteName = nil\n        end\n\n        return floorRoute\n    end\n\n    ---@return Route|nil\n    function s.FloorRoute()\n        return floorRoute\n    end\n\n    ---@return string|nil\n    function s.FloorRouteName()\n        return floorRouteName\n    end\n\n    ---@return SelectablePoint[]\n    function s.SelectableFloorPoints()\n        local selectable = {} ---@type SelectablePoint[]\n\n        if floorRoute then\n            local points = floorRoute.Points()\n            local distances = s.CalculateDistances(points)\n            for i, p in ipairs(points) do\n                if p.Options().Get(PointOptions.SELECTABLE, true) then\n                    selectable[#selectable + 1] = {\n                        visible = true,\n                        name = (function()\n                            if p.HasWaypointRef() then\n                                -- Silence warning of string vs. nil, we've already checked if it has a waypoint reference\n                                return p.WaypointRef() or \"\"\n                            end\n                            local d = distanceFormat(distances[i])\n                            return string.format(\"%0.1f%s\", d.value, d.unit)\n                        end)(),\n                        activate = string.format(\"route-activate '%s' -index %d\", floorRouteName, i),\n                        index = i\n                    }\n                end\n            end\n        end\n\n        return selectable\n    end\n\n    ---Loads a named route and makes it available for editing\n    ---@param name string The name of the route to load\n    ---@return Route|nil\n    function s.EditRoute(name)\n        if edit ~= nil then\n            log.Error(\"A route is already being edited.\")\n            return nil\n        end\n\n        edit = s.LoadRoute(name)\n\n        if edit == nil then return end\n        editName = name\n\n        pub.Publish(\"RouteOpenedForEdit\", true)\n\n        return edit\n    end\n\n    ---Deletes the named route\n    ---@param name string\n    function s.DeleteRoute(name)\n        local routes = db.Get(RouteController.NAMED_ROUTES) or {}\n        local route = routes[name]\n\n        if route == nil then\n            log.Error(\"No route by name '\", name, \"' found.\")\n            return\n        end\n\n        routes[name] = nil\n        db.Put(RouteController.NAMED_ROUTES, routes)\n        log.Info(\"Route '\", name, \"' deleted\")\n\n        if name == editName then\n            edit = nil\n            editName = nil\n            log.Info(\"No route is currently being edited\")\n        end\n    end\n\n    ---Store the route under the given name\n    ---@param name string The name to store the route as\n    ---@param route Route The route to store\n    ---@return boolean\n    function s.StoreRoute(name, route)\n        local routes = db.Get(RouteController.NAMED_ROUTES) or {}\n        local data = { points = {} } ---@type RouteData\n\n        for _, p in ipairs(route.Points()) do\n            data.points[#data.points + 1] = p.Persist()\n        end\n\n        routes[name] = data\n        db.Put(RouteController.NAMED_ROUTES, routes)\n        log.Info(\"Route '\", name, \"' saved.\")\n        return true\n    end\n\n    ---@param from string\n    ---@param to string\n    function s.RenameRoute(from, to)\n        if s.routeExists(to) then\n            log.Error(\"Route already exists\")\n        else\n            local r = s.LoadRoute(from)\n            if r then\n                s.StoreRoute(to, r)\n                s.DeleteRoute(from)\n                log.Info(\"Route renamed from \", from, \" to \", to)\n                return true\n            end\n        end\n\n        return false\n    end\n\n    ---Stores a waypoint under the given name\n    ---@param name string The name of the waypoint\n    ---@param pos string A ::pos string\n    ---@return boolean\n    function s.StoreWaypoint(name, pos)\n        local p = universe.ParsePosition(pos)\n        if p == nil then return false end\n\n        if name == nil or string.len(name) == 0 then\n            log.Error(\"No name provided\")\n            return false\n        end\n\n        local waypoints = db.Get(RouteController.NAMED_POINTS) or {}\n        waypoints[name] = Point.New(pos).Persist()\n\n        db.Put(RouteController.NAMED_POINTS, waypoints)\n        log.Info(\"Waypoint saved as '\", name, \"'\")\n        return true\n    end\n\n    ---Gets the named waypoints\n    ---@return WaypointMap\n    local function getNamedPoints()\n        local w = db.Get(RouteController.NAMED_POINTS) or {}\n        ---@cast w WaypointMap\n        return w\n    end\n\n    ---Returns a list of all waypoints\n    ---@return NamedWaypoint[]\n    function s.GetWaypoints()\n        local namedPositions = getNamedPoints()\n\n        local names = {}\n\n        -- Create a list of the names\n        for name, _ in pairs(namedPositions) do\n            table.insert(names, name)\n        end\n\n        table.sort(names)\n\n        local res = {} ---@type NamedWaypoint[]\n        for _, name in pairs(names) do\n            table.insert(res, { name = name, point = s.LoadWaypoint(name, namedPositions) })\n        end\n\n        return res\n    end\n\n    ---Loads a waypoint by the given name\n    ---@param name string|nil Name of waypoint to load\n    ---@param waypoints? WaypointMap An optional table to load from\n    ---@return Point|nil\n    function s.LoadWaypoint(name, waypoints)\n        if not name then return nil end\n        waypoints = waypoints or getNamedPoints()\n        local pointData = waypoints[name]\n\n        if pointData == nil then\n            return nil\n        end\n\n        return Point.LoadFromPOD(pointData)\n    end\n\n    ---Deletes a waypoint\n    ---@param name string\n    ---@return PointPOD|nil #The removed point\n    function s.DeleteWaypoint(name)\n        local waypoints = getNamedPoints()\n        local found = waypoints[name]\n        if found then\n            waypoints[name] = nil\n            db.Put(RouteController.NAMED_POINTS, waypoints)\n        else\n            log.Error(\"No waypoint by name '\", name, \"' found.\")\n        end\n\n        return found\n    end\n\n    ---Returns the current route or nil if none is active\n    ---@return Route|nil\n    function s.CurrentRoute()\n        return current\n    end\n\n    ---Returns the route currently being edited or nil\n    ---@return Route|nil\n    function s.CurrentEdit()\n        return edit\n    end\n\n    ---Returns the name of the route currently being edited, or nil\n    ---@return string|nil\n    function s.CurrentEditName()\n        return editName\n    end\n\n    ---@param name string\n    ---@param destinationWayPointIndex number\n    ---@return Route|nil\n    function s.doBasicCheckesOnActivation(name, destinationWayPointIndex)\n        if not name or string.len(name) == 0 then\n            log.Error(\"No route name provided\")\n            return nil\n        end\n\n        if editName ~= nil and name == editName and edit ~= nil then\n            log.Info(\"Cannot activate route currently being edited, please save first.\")\n            return nil\n        end\n\n        local route = s.LoadRoute(name)\n\n        if route == nil then\n            return nil\n        elseif #route.Points() < 2 then\n            log.Error(\"Less than 2 points in route '\", name, \"'\")\n            return nil\n        end\n\n        if destinationWayPointIndex < 1 or destinationWayPointIndex > #route.Points() then\n            log.Error(\"Destination index must be >= 1 and <= \", #route.Points(), \" it was: \", destinationWayPointIndex)\n            return nil\n        end\n\n        return route\n    end\n\n    ---Activate the route by the given name\n    ---@param name string\n    ---@param destinationWayPointIndex? number The index of the waypoint we wish to move to. 0 means the last one in the route. This always counts in the original order of the route.\n    ---@param startMargin? number The route will only be activated if within this distance.\n    ---@param gateControlDistance? number Gate control will only be activated if this close to a controlled point in the route\n    ---@return boolean\n    function s.ActivateRoute(name, destinationWayPointIndex, startMargin, gateControlDistance)\n        startMargin = startMargin or 0\n        gateControlDistance = gateControlDistance or constants.route.gateControlDistance\n        local candidate = s.doBasicCheckesOnActivation(name, destinationWayPointIndex or 1)\n\n        if candidate == nil then\n            return false\n        end\n\n        local currentPos = Current()\n        destinationWayPointIndex = destinationWayPointIndex or #candidate.Points()\n        candidate.AdjustRouteBasedOnTarget(currentPos, destinationWayPointIndex, gateControlDistance)\n\n        -- Check we're close enough to the closest point\n        local closestPosInRoute = candidate.FindClosestPositionAlongRoute(currentPos)\n\n        local distance = closestPosInRoute:Dist(currentPos)\n        if startMargin > 0 and distance > startMargin then\n            log.Error(string.format(\n                \"Currently %0.2fm from closest point in route. Please move within %0.2fm of %s and try again.\"\n                , distance, startMargin, universe.CreatePos(closestPosInRoute):AsPosString()))\n            return false\n        end\n\n        current = candidate\n        activeRouteName = name\n\n        log.Info(\"Route '\", name, \"' activated at index \" .. destinationWayPointIndex)\n\n        return true\n    end\n\n    ---Activate a temporary, empty, route\n    ---@param name string|nil\n    ---@return Route\n    function s.ActivateTempRoute(name)\n        current = Route.New()\n        activeRouteName = name or \"---\"\n        return current\n    end\n\n    ---Creates a route\n    ---@param name string\n    ---@return Route|nil\n    function s.CreateRoute(name)\n        if edit ~= nil then\n            log.Error(\"A route is being edited, can't create a new one.\")\n            return nil\n        end\n\n        if name == nil or #name == 0 then\n            log.Error(\"No name provided for route\")\n            return nil\n        end\n\n        if s.routeExists(name) then\n            log.Error(\"Route already exists\")\n            return nil\n        end\n\n        edit = Route.New()\n        editName = name\n        s.SaveRoute()\n\n        log.Info(\"Route '\", name, \"' created\")\n        edit = s.EditRoute(name)\n        return edit\n    end\n\n    ---Saves the currently edited route\n    ---@return boolean\n    function s.SaveRoute()\n        local res = false\n        if edit and editName ~= nil then\n            res = s.StoreRoute(editName, edit)\n            editName = nil\n            edit = nil\n            log.Info(\"Route saved\")\n            res = true\n        else\n            log.Error(\"No route currently opened for edit.\")\n        end\n\n        return res\n    end\n\n    ---Discards and currently made changes and closes the edited route\n    function s.Discard()\n        if edit and editName ~= nil then\n            edit = nil\n            editName = nil\n            log.Info(\"All changes discarded.\")\n        else\n            log.Error(\"No route currently opened for edit, nothing to discard.\")\n        end\n    end\n\n    ---Returns the current name\n    ---@return string|nil\n    function s.ActiveRouteName()\n        return activeRouteName\n    end\n\n    ---Activates a route to hold position\n    function s.ActivateHoldRoute()\n        local route = s.ActivateTempRoute()\n        local p = route.AddCurrentPos()\n        local opt = p.Options()\n        opt.Set(PointOptions.LOCK_DIRECTION, { Forward():Unpack() })\n        opt.Set(PointOptions.FORCE_VERT, true)\n    end\n\n    ---Returns a list of point distances\n    ---@param points Point[]\n    function s.CalculateDistances(points)\n        local d = {}\n\n        if #points > 0 then\n            local prev = universe.ParsePosition(points[1].Pos()):Coordinates()\n            d[#d + 1] = 0\n            for i = 2, #points do\n                local curr = universe.ParsePosition(points[i].Pos()):Coordinates()\n                local diff = (curr - prev):Len()\n                d[#d + 1] = d[#d] + diff\n                prev = curr\n            end\n        end\n\n        return d\n    end\n\n    singleton = setmetatable(s, RouteController)\n    return singleton\nend\n\nreturn RouteController\n\nend)\npackage.preload['YFS:../e/lib/src/storage/DBStoredData.lua']=(function()\nlocal json = require(\"json\")\n\nlocal function findAnyFunction(o)\n    if type(o) ~= \"table\" then\n        return nil\n    end\n\n    local found = nil\n\n    for key, value in pairs(o) do\n        local t = type(value)\n\n        if t == \"function\" then\n            return key\n        else\n            found = findAnyFunction(value)\n        end\n\n        if found then\n            return found\n        end\n    end\n\n    return found\nend\n\n---@class DBStoredData\n---@field value string|number|table The data to save\n---@field valueType string The type of data held\n---@field dirty boolean True if it should be marked as dirty\n---@field Persist fun():table Returns an opaque table to serialize for storage. Also marks the item as clean.\nlocal DBStoredData = {}\nDBStoredData.__index = DBStoredData\n\nfunction DBStoredData.New(value, dirty)\n    local t = type(value)\n    local foundFunctionName = findAnyFunction(value)\n    if foundFunctionName then\n        error(string.format(\"Functions not allowed in PODs: '%s'\", foundFunctionName))\n    end\n\n    local s = {\n        valueType = t,\n        value = value,\n        dirty = dirty or false\n    }\n\n    function s.Persist()\n        s.dirty = false\n        local str = json.encode(\n            {\n                t = s.valueType,\n                v = s.value\n            })\n        return str\n    end\n\n    return setmetatable(s, DBStoredData)\nend\n\n---Creates a new DBStoreData from data read from databank\n---@param readData string\n---@return DBStoredData|nil\nfunction DBStoredData.NewFromDB(readData)\n    if readData ~= nil then\n        local decoded\n\n        -- Suppress decoding errors\n        xpcall(function()\n            decoded = json.decode(readData)\n        end, traceback)\n\n        if decoded ~= nil\n            and type(decoded) == \"table\"\n            and decoded.t\n            and decoded.v ~= nil -- must check against nil, as v may be boolean 'false'\n        then\n            return DBStoredData.New(decoded.v)\n        end\n    end\n\n    return nil\nend\n\nreturn DBStoredData\n\nend)\npackage.preload['YFS:../e/lib/src/storage/BufferedDB.lua']=(function()\nlocal Task = require('YFS:../e/lib/src/system/Task.lua')\nlocal log = require('YFS:../e/lib/src/debug/Log.lua').Instance()\nrequire('YFS:../e/lib/src/util/Table.lua')\nlocal DBStoredData = require('YFS:../e/lib/src/storage/DBStoredData.lua')\n\n---@class BufferedDB\n---@field BeginLoad fun() Starts loading keys into memory\n---@field Clear fun() Clears the databank\n---@field IsLoaded fun():boolean Returns true when all keys have been loaded.\n---@field IsDirty fun():boolean Returns true when a key has not yet been persisted\n---@field Get fun(key:string, default:any):number|string|boolean|table|nil Returns the value of the key, or the default value\n---@field Number fun(key:string, default:number):number Returns the value, or default\n---@field Boolean fun(key:string, default:boolean):boolean Returns the value, or default\n---@field Put fun(key:string, data:number|string|boolean|table) Stores the data in key. data can be string, number or (plain data) table.\n---@field Size fun():number Returns the number of keys\n\nlocal BufferedDB = {}\nBufferedDB.__index = BufferedDB\n\n---Creates a new BufferedDB\n---@param databank table|nil The link to the the databank element we're expecting to be connected to.\n---@return BufferedDB\nfunction BufferedDB.New(databank)\n    if type(databank) ~= \"table\" or not databank.getStringValue then\n        error(\"databank parameter of BufferedDB.New must be a link to a databank\")\n    end\n\n    local s = {}\n\n    local buffer = {} ---@type {[string]:DBStoredData}\n    local db = databank\n    local loaded = false\n    local dirtyCount = 0\n    local task\n\n    local function persist()\n        loaded = true\n        while true do\n            if s.IsDirty() then\n                for key, data in pairs(buffer) do\n                    coroutine.yield()\n\n                    if data.dirty then\n                        db.setStringValue(key, data.Persist())\n                        dirtyCount = dirtyCount - 1\n                    end\n                end\n            end\n            coroutine.yield()\n        end\n    end\n\n    ---Begins loading keys\n    function s.BeginLoad()\n        if task then\n            return\n        end\n\n        task = Task.New(\"BufferedDB\", function()\n            local keys = db.getKeyList()\n            for i, k in ipairs(keys) do\n                local d = DBStoredData.NewFromDB(db.getStringValue(k))\n\n                if d then\n                    buffer[k] = d\n                else\n                    log.Error(\"Could not load key '\", k, \"'\")\n                end\n\n                if i % 20 == 0 then\n                    coroutine.yield()\n                end\n            end\n        end).Then(persist).Catch(function(t)\n            log.Error(\"Error in BeginLoad:\", t.Error())\n        end)\n    end\n\n    function s.Clear()\n        if loaded then\n            buffer = {}\n            dirtyCount = 0\n            db.clear()\n        else\n            error(\"Call to Clear before loading is completed\")\n        end\n    end\n\n    ---Checks if all keys are loaded\n    ---@return boolean\n    function s.IsLoaded()\n        return loaded\n    end\n\n    ---Checks if all data has been persisted\n    ---@return boolean\n    function s.IsDirty()\n        return dirtyCount > 0\n    end\n\n    ---Gets data from key or default\n    ---@param key string\n    ---@param default number|string|boolean|table\n    ---@return number|string|boolean|table|nil\n    function s.Get(key, default)\n        if loaded then\n            local entry = buffer[key]\n            if entry then\n                return entry.value\n            end\n        else\n            error(\"Call to Get before loading is completed\")\n        end\n\n        return default\n    end\n\n    ---@param key string\n    ---@param default number\n    function s.Number(key, default)\n        return s.Get(key, default)\n    end\n\n    ---@param key string\n    ---@param default boolean\n    function s.Boolean(key, default)\n        return s.Get(key, default)\n    end\n\n    ---Puts data in key\n    ---@param key string\n    ---@param data number|string|boolean|table|boolean\n    function s.Put(key, data)\n        if loaded then\n            buffer[key] = DBStoredData.New(data, true)\n            dirtyCount = dirtyCount + 1\n        else\n            error(\"Call to Put before loading is completed\")\n        end\n    end\n\n    function s.Size()\n        return TableLen(buffer)\n    end\n\n    return setmetatable(s, BufferedDB)\nend\n\nreturn BufferedDB\n\nend)\npackage.preload['YFS:../e/lib/src/element/Container.lua']=(function()\n---@module \"element/ContainerTalents\")\n\n---@class Container\n---@field New fun(itemId:integer):Container\n---@field Name fun():string\n---@field GetAll fun():Container[]\n---@field FuelFillFactor fun(talents:ContainerTalents)\n---@field ActualContentMass fun(talents:ContainerTalents)\n\nlocal core = library.getCoreUnit()\nlocal nitronMass = 4\nlocal kergonMass = 6\nlocal xeronMass = 0.8\n\nif core == nil then\n    error(\"No core linked\")\nend\n\n---@alias ContainerData {Cap:number, Factor:number, FuelMass:number}\nlocal sizes = {} ---@type table<string,ContainerData>\nsizes[\"basic container xs\"] = { Cap = 1000, Factor = 1 }\nsizes[\"uncommon optimised container xs\"] = { Cap = 1300, Factor = 1 }\nsizes[\"advanced optimised container xs\"] = { Cap = 1690, Factor = 1 }\nsizes[\"rare optimised container xs\"] = { Cap = 2197, Factor = 1 }\nsizes[\"exotic optimised container xs\"] = { Cap = 2856, Factor = 1 }\nsizes[\"uncommon gravity-inverted container xs\"] = { Cap = 900, Factor = 0.9 }\nsizes[\"advanced gravity-inverted container xs\"] = { Cap = 810, Factor = 0.81 }\nsizes[\"rare gravity-inverted container xs\"] = { Cap = 729, Factor = 0.73 }\nsizes[\"exotic gravity-inverted container xs\"] = { Cap = 656, Factor = 0.66 }\n\nsizes[\"basic container s\"] = { Cap = 8000, Factor = 1 }\nsizes[\"uncommon optimised container s\"] = { Cap = 10400, Factor = 1 }\nsizes[\"advanced optimised container s\"] = { Cap = 13520, Factor = 1 }\nsizes[\"rare optimised container s\"] = { Cap = 17576, Factor = 1 }\nsizes[\"exotic optimised container s\"] = { Cap = 22849, Factor = 1 }\nsizes[\"uncommon gravity-inverted container s\"] = { Cap = 7200, Factor = 0.9 }\nsizes[\"advanced gravity-inverted container s\"] = { Cap = 6480, Factor = 0.81 }\nsizes[\"rare gravity-inverted container s\"] = { Cap = 5832, Factor = 0.73 }\nsizes[\"exotic gravity-inverted container s\"] = { Cap = 5249, Factor = 0.66 }\n\nsizes[\"basic container m\"] = { Cap = 64000, Factor = 1 }\nsizes[\"uncommon optimised container m\"] = { Cap = 83200, Factor = 1 }\nsizes[\"advanced optimised container m\"] = { Cap = 108160, Factor = 1 }\nsizes[\"rare optimised container m\"] = { Cap = 140608, Factor = 1 }\nsizes[\"exotic optimised container m\"] = { Cap = 182790, Factor = 1 }\nsizes[\"uncommon gravity-inverted container m\"] = { Cap = 57600, Factor = 0.9 }\nsizes[\"advanced gravity-inverted container m\"] = { Cap = 51840, Factor = 0.81 }\nsizes[\"rare gravity-inverted container m\"] = { Cap = 46656, Factor = 0.73 }\nsizes[\"exotic gravity-inverted container m\"] = { Cap = 41990, Factor = 0.66 }\n\nsizes[\"basic container l\"] = { Cap = 128000, Factor = 1 }\nsizes[\"uncommon optimised container l\"] = { Cap = 166400, Factor = 1 }\nsizes[\"advanced optimised container l\"] = { Cap = 216320, Factor = 1 }\nsizes[\"rare optimised container l\"] = { Cap = 281216, Factor = 1 }\nsizes[\"exotic optimised container l\"] = { Cap = 365581, Factor = 1 }\nsizes[\"uncommon gravity-inverted container l\"] = { Cap = 115200, Factor = 0.9 }\nsizes[\"advanced gravity-inverted container l\"] = { Cap = 103680, Factor = 0.81 }\nsizes[\"rare gravity-inverted container l\"] = { Cap = 93312, Factor = 0.73 }\nsizes[\"exotic gravity-inverted container l\"] = { Cap = 83981, Factor = 0.66 }\n\nsizes[\"basic container xl\"] = { Cap = 256000, Factor = 1 }\nsizes[\"uncommon optimised container xl\"] = { Cap = 332800, Factor = 1 }\nsizes[\"advanced optimised atmoFuelTankHandlingcontainer xl\"] = { Cap = 432640, Factor = 1 }\nsizes[\"rare optimised container xl\"] = { Cap = 562432, Factor = 1 }\nsizes[\"exotic optimised container xl\"] = { Cap = 731162, Factor = 1 }\nsizes[\"uncommon gravity-inverted container xl\"] = { Cap = 230400, Factor = 0.9 }\nsizes[\"advanced gravity-inverted container xl\"] = { Cap = 207360, Factor = 0.81 }\nsizes[\"rare gravity-inverted container xl\"] = { Cap = 186624, Factor = 0.73 }\nsizes[\"exotic gravity-inverted container xl\"] = { Cap = 167962, Factor = 0.66 }\n\nsizes[\"expanded basic container xxl\"] = { Cap = 512000, Factor = 1 }\nsizes[\"expanded uncommon optimised container xxl\"] = { Cap = 665600, Factor = 1 }\nsizes[\"expanded advanced optimised container xxl\"] = { Cap = 865280, Factor = 1 }\nsizes[\"expanded rare optimised container xxl\"] = { Cap = 1124864, Factor = 1 }\nsizes[\"expanded exotic optimised container xxl\"] = { Cap = 1462323, Factor = 1 }\nsizes[\"expanded uncommon gravity-inverted container xxl\"] = { Cap = 460800, Factor = 0.9 }\nsizes[\"expanded advanced gravity-inverted container xxl\"] = { Cap = 414720, Factor = 0.81 }\nsizes[\"expanded rare gravity-inverted container xxl\"] = { Cap = 373248, Factor = 0.73 }\nsizes[\"expanded exotic gravity-inverted container xxl\"] = { Cap = 335923, Factor = 0.66 }\n\nsizes[\"atmospheric fuel tank xs\"] = { Cap = 100, Factor = 1, FuelMass = nitronMass }\nsizes[\"atmospheric fuel tank s\"] = { Cap = 400, Factor = 1, FuelMass = nitronMass }\nsizes[\"atmospheric fuel tank m\"] = { Cap = 1600, Factor = 1, FuelMass = nitronMass }\nsizes[\"atmospheric fuel tank l\"] = { Cap = 12800, Factor = 1, FuelMass = nitronMass }\n\nsizes[\"space fuel tank xs\"] = { Cap = 100, Factor = 1, FuelMass = kergonMass }\nsizes[\"space fuel tank s\"] = { Cap = 400, Factor = 1, FuelMass = kergonMass }\nsizes[\"space fuel tank m\"] = { Cap = 1600, Factor = 1, FuelMass = kergonMass }\nsizes[\"space fuel tank l\"] = { Cap = 12800, Factor = 1, FuelMass = kergonMass }\n\nsizes[\"rocket fuel tank xs\"] = { Cap = 400, Factor = 1, FuelMass = xeronMass }\nsizes[\"rocket fuel tank s\"] = { Cap = 800, Factor = 1, FuelMass = xeronMass }\nsizes[\"rocket fuel tank m\"] = { Cap = 6400, Factor = 1, FuelMass = xeronMass }\nsizes[\"rocket fuel tank l\"] = { Cap = 50000, Factor = 1, FuelMass = xeronMass }\n\n---Looksup the container data, or errors if not found\n---@param name string\n---@return ContainerData\nlocal function lookupContainerData(name)\n    local d = sizes[name]\n    if not d then\n        error(string.format(\"Unknown container: %s\", name))\n    end\n\n    return d\nend\n\n---@enum ContainerType\nContainerType = {\n    Standard = 1,\n    Atmospheric = 2,\n    Space = 4,\n    Rocket = 8,\n    Fuel = 14,\n    All = 15\n}\n\nlocal Container = {}\nContainer.__index = Container\nlocal preFiltered ---@type table<ContainerType, Container[]>\n\n\n---Creates a new container\n---@param localId integer The local id of the container\n---@param containerData ContainerData\n---@return Container\nfunction Container.New(localId, unitMass, containerData)\n    local s = {\n        ---@type string\n        name = core.getElementNameById(localId)\n    }\n\n    local function standardVolume(containerProficiency)\n        return containerData.Cap * (1 + containerProficiency / 10) -- 10% per level\n    end\n\n    local function fuelVolume(containerProficiency)\n        return containerData.Cap * (1 + containerProficiency / 5) -- 20% per level\n    end\n\n    local function rawContentMass()\n        return core.getElementMassById(localId) - unitMass;\n    end\n\n    ---Returns to which factor (0...1) the container is filled, if it is a fuel tank; otherwise 0.\n    ---@param talents ContainerTalents\n    function s.FuelFillFactor(talents)\n        if not containerData.FuelMass then return 0 end\n\n        local reducedMass = rawContentMass()\n        local actualMass = reducedMass\n\n        if talents.FuelTankOptimization > 0 or talents.ContainerOptimization > 0 then\n            actualMass = reducedMass / (1 - (talents.FuelTankOptimization + talents.ContainerOptimization) * 0.05)\n        end\n\n        local volume\n        if containerData.FuelMass == xeronMass then\n            volume = standardVolume(talents.RocketFuelTankHandling)\n        elseif containerData.FuelMass == kergonMass then\n            volume = fuelVolume(talents.SpaceFuelTankHandling)\n        else\n            volume = fuelVolume(talents.AtmoFuelTankHandling)\n        end\n\n        local currentLiters = actualMass / containerData.FuelMass\n        local fillFactor = currentLiters / volume\n\n        return fillFactor\n    end\n\n    ---@param talents ContainerTalents\n    function s.ActualContentMass(talents)\n        local reducedMass = rawContentMass()\n        local actualMass = reducedMass\n        if talents.ContainerOptimization > 0 then\n            actualMass = reducedMass / (1 - talents.ContainerOptimization * 0.05)\n        end\n\n        return actualMass\n    end\n\n    ---Gets the container name\n    ---@return string\n    function s.Name()\n        return s.name\n    end\n\n    return setmetatable(s, Container)\nend\n\n---@param localId number\n---@return Container\nlocal function makeContainer(localId)\n    local itemId = core.getElementItemIdById(localId)\n    ---@type {name:string, unitMass:number, unitVolume:number, displayNameWithSize:string}\n    local data = system.getItem(itemId)\n    local lowerName = data.displayNameWithSize:lower()\n    local containerData = lookupContainerData(lowerName)\n    return Container.New(localId, data.unitMass, containerData)\nend\n\n---@param input ContainerType\n---@param wanted ContainerType\nlocal function hasBit(input, wanted)\n    return (input & wanted) == wanted\nend\n\n---Gets all containers. Only call from a coroutine\n---@param filter ContainerType|integer\n---@return Container[]\nfunction Container.GetAllCo(filter)\n    local containers = {} ---@type Container[]\n\n    if not preFiltered then\n        preFiltered = {}\n        preFiltered[ContainerType.Standard] = {}\n        preFiltered[ContainerType.Atmospheric] = {}\n        preFiltered[ContainerType.Space] = {}\n        preFiltered[ContainerType.Rocket] = {}\n\n\n        ---@diagnostic disable-next-line: undefined-field\n        for i, localId in ipairs(core.getElementIdList()) do\n            local elementClass = core.getElementClassById(localId) ---@type string\n            elementClass = elementClass:lower()\n\n            if not elementClass:find(\"itemcontainer\") then -- filter hubs\n                if elementClass:find(\"atmofuelcontainer\") then\n                    table.insert(preFiltered[ContainerType.Atmospheric], makeContainer(localId))\n                elseif elementClass:find(\"spacefuelcontainer\") then\n                    table.insert(preFiltered[ContainerType.Space], makeContainer(localId))\n                elseif elementClass:find(\"rocketfuelcontainer\") then\n                    table.insert(preFiltered[ContainerType.Rocket], makeContainer(localId))\n                elseif elementClass:find(\"container\") and elementClass:find(\"fuel\") then\n                    table.insert(preFiltered[ContainerType.Standard], makeContainer(localId))\n                end\n            end\n\n            if i % 10 == 0 then\n                coroutine.yield()\n            end\n        end\n    end\n\n    if (hasBit(filter, ContainerType.Atmospheric)) then\n        CopyList(containers, preFiltered[ContainerType.Atmospheric])\n    end\n\n    if (hasBit(filter, ContainerType.Space)) then\n        CopyList(containers, preFiltered[ContainerType.Space])\n    end\n\n    if (hasBit(filter, ContainerType.Rocket)) then\n        CopyList(containers, preFiltered[ContainerType.Rocket])\n    end\n\n    if (hasBit(filter, ContainerType.Standard)) then\n        CopyList(containers, preFiltered[ContainerType.Standard])\n    end\n\n    return containers\nend\n\nreturn Container\n\nend)\npackage.preload['YFS:../e/lib/src/element/ContainerTalents.lua']=(function()\n---@class ContainerTalents\n---@field New fun(containerProficiency:integer, fuelTankOptimization:integer,containerOptimization:integer,atmoFuelTankHandling:integer,spaceFuelTankHandling:integer,rocketFuelTankHandling:integer):ContainerSkills\n---@field ContainerProficiency integer\n---@field FuelTankOptimization integer\n---@field ContainerOptimization integer\n---@field AtmoFuelTankHandling integer\n---@field SpaceFuelTankHandling integer\n---@field RocketFuelTankHandling integer\n\nlocal ContainerSkills = {}\nContainerSkills.__index = ContainerSkills\n\n---@param containerProficiency integer,\n---@param fuelTankOptimization integer,\n---@param containerOptimization integer,\n---@param atmoFuelTankHandling integer,\n---@param spaceFuelTankHandling integer,\n---@param rocketFuelTankHandling integer\n---@return ContainerTalents\nfunction ContainerSkills.New(containerProficiency, fuelTankOptimization, containerOptimization, atmoFuelTankHandling,\n                             spaceFuelTankHandling, rocketFuelTankHandling)\n    local s = {\n        ContainerProficiency = containerProficiency or 0,\n        FuelTankOptimization = fuelTankOptimization or 0,\n        ContainerOptimization = containerOptimization or 0,\n        AtmoFuelTankHandling = atmoFuelTankHandling or 0,\n        SpaceFuelTankHandling = spaceFuelTankHandling or 0,\n        RocketFuelTankHandling = rocketFuelTankHandling or 0\n    }\n\n    return setmetatable(s, ContainerSkills)\nend\n\nreturn ContainerSkills\n\nend)\npackage.preload['YFS:../e/render/src/native/Vec2.lua']=(function()\n--- A 2 component vector based on cpml/Vec2\n--- https://github.com/excessive/cpml/blob/master/modules/Vec2.lua\n\nlocal atan2 = math.atan\nlocal sqrt  = math.sqrt\nlocal cos   = math.cos\nlocal sin   = math.sin\nlocal abs   = math.abs\n\n---@class Vec2\n---@field x number\n---@field y number\n---@field New fun(x:number|{x:number,y:number}|number[], y:number|nil):Vec2\n---@field unit_x Vec2 X axis of rotation\n---@field unit_y Vec2 Y axis of rotation\n---@field zero Vec2 Empty vector\n---@field FromCartesian fun(radius:number, theta:number):Vec2\n---@field Clone fun(v:Vec2):Vec2\n---@field Add fun(a:Vec2, b:Vec2):Vec2 Add two vectors.\n---@field Sub fun(a:Vec2, b:Vec2):Vec2 Subtract two vectors.\n---@field Mul fun(a:Vec2, b:Vec2):Vec2 Multiply two vectors.\n---@field Div fun(a:Vec2, b:Vec2):Vec2 Divide two vectors.\n---@field Normalize fun(a:Vec2):Vec2\n---@field Trim fun(a:Vec2, len:number):Vec2\n---@field Cross fun(a:Vec2, b:Vec2):number\n---@field Dot fun(a:Vec2, b:Vec2):number\n---@field Len fun(a:Vec2):number\n---@field Len2 fun(a:Vec2):number\n---@field Dist fun(a:Vec2, b:Vec2):number\n---@field Dist2 fun(a:Vec2, b:Vec2):number\n---@field Scale fun(a:Vec2, b:number):Vec2\n---@field Rotate fun(a:Vec2, phi:number)\n---@field Perpendicular fun(a:Vec2):Vec2\n---@field AngleTo fun(a:Vec2, b:Vec2):number\n---@field Lerp fun(a:Vec2, b:Vec2, s:number):Vec2\n---@field Unpack fun(a:Vec2):number, number\n---@field ComponentMin fun(a:Vec2, b:Vec2):Vec2\n---@field ComponentMax fun(a:Vec2, b:Vec2):Vec2\n---@field IsVec2 fun(a:Vec2):boolean\n---@field IsZero fun(a:Vec2):boolean\n---@field ToPolar fun(a:Vec2):number, number\n---@field FlipX fun(a:Vec2):Vec2\n---@field FlipY fun(a:Vec2):Vec2\n---@field Abs fun(a:Vec2):Vec2\n---@field ToString fun(a:Vec2):string\n---@operator add(Vec2):Vec2\n---@operator sub(Vec2):Vec2\n---@operator div(Vec2):Vec2\n---@operator div(number):Vec2\n---@operator mul(Vec2):Vec2\n---@operator mul(number):Vec2\n---@operator unm:Vec2\n\nlocal Vec2 = {}\nVec2.__index = Vec2\n\n---Create a new Vec2\n---@param x number|{x:number,y:number}|number[]|nil\n---@param y number|nil\n---@return Vec2\nfunction Vec2.New(x, y)\n    local s = {}\n\n    if x and y then\n        s.x = x\n        s.y = y\n        -- {x, y} or {x=x, y=y}\n    elseif type(x) == \"table\" then\n        s.x, s.y = x.x or x[1], x.y or x[2]\n    elseif type(x) == \"number\" then\n        s.x = x\n        s.y = x\n    else\n        s.x = 0\n        s.y = 0\n    end\n\n    return setmetatable(s, Vec2)\nend\n\nVec2.unit_x = Vec2.New(1, 0)\nVec2.unit_y = Vec2.New(0, 1)\nVec2.zero   = Vec2.New(0, 0)\n\n---Convert point from polar to cartesian.\n---@param radius number Radius of the point\n---@param theta number Angle of the point (in radians)\n---@return Vec2\nfunction Vec2.FromCartesian(radius, theta)\n    return Vec2.New(radius * cos(theta), radius * sin(theta))\nend\n\n---Clone a vector.\n---@param a Vec2 Vector to be cloned\n---@return Vec2\nfunction Vec2.Clone(a)\n    return Vec2.New(a.x, a.y)\nend\n\n---Add two vectors.\n---@param a Vec2 Left hand operand\n---@param b Vec2 Right hand operand\n---@return Vec2 out\nfunction Vec2.Add(a, b)\n    return Vec2.New(\n        a.x + b.x,\n        a.y + b.y\n    )\nend\n\n---Subtract one vector from another.\n---Order: If a and b are positions, computes the direction and distance from b\n---to a.\n---@param a Vec2 Left hand operand\n---@param b Vec2 Right hand operand\n---@return Vec2 out\nfunction Vec2.Sub(a, b)\n    return Vec2.New(\n        a.x - b.x,\n        a.y - b.y\n    )\nend\n\n--- Multiply a vector by another vector.\n-- Component-size multiplication not matrix multiplication.\n---@param a Vec2  Left hand operand\n---@param b Vec2  Right hand operand\n---@return Vec2 out\nfunction Vec2.Mul(a, b)\n    return Vec2.New(\n        a.x * b.x,\n        a.y * b.y\n    )\nend\n\n--- Divide a vector by another vector.\n-- Component-size inv multiplication. Like a non-uniform scale().\n---@param a Vec2  Left hand operand\n---@param b Vec2  Right hand operand\n---@return Vec2 out\nfunction Vec2.Div(a, b)\n    return Vec2.New(\n        a.x / b.x,\n        a.y / b.y\n    )\nend\n\n--- Get the normal of a vector.\n---@param a Vec2  Vector to normalize\n---@return Vec2 out\nfunction Vec2.Normalize(a)\n    if a:IsZero() then\n        return Vec2.New()\n    end\n    return a:Scale(1 / a:Len())\nend\n\n--- Trim a vector to a given length.\n---@param a Vec2  Vector to be trimmed\n---@param len number Length to trim the vector to\n---@return Vec2\nfunction Vec2.Trim(a, len)\n    return a:Normalize():Scale(math.min(a:Len(), len))\nend\n\n--- Get the cross product of two vectors.\n-- Order: Positive if a is clockwise from b. Magnitude is the area spanned by\n-- the parallelograms that a and b span.\n---@param a Vec2  Left hand operand\n---@param b Vec2  Right hand operand\n---@return number\nfunction Vec2.Cross(a, b)\n    return a.x * b.y - a.y * b.x\nend\n\n--- Get the dot product of two vectors.\n---@param a Vec2  Left hand operand\n---@param b Vec2  Right hand operand\n---@return number\nfunction Vec2.Dot(a, b)\n    return a.x * b.x + a.y * b.y\nend\n\n--- Get the length of a vector.\n---@param a Vec2  Vector to get the length of\n---@return number\nfunction Vec2.Len(a)\n    return sqrt(a.x * a.x + a.y * a.y)\nend\n\n--- Get the squared length of a vector.\n---@param a Vec2  Vector to get the squared length of\n---@return number\nfunction Vec2.Len2(a)\n    return a.x * a.x + a.y * a.y\nend\n\n--- Get the distance between two vectors.\n---@param a Vec2  Left hand operand\n---@param b Vec2  Right hand operand\n---@return number\nfunction Vec2.Dist(a, b)\n    local dx = a.x - b.x\n    local dy = a.y - b.y\n    return sqrt(dx * dx + dy * dy)\nend\n\n--- Get the squared distance between two vectors.\n---@param a Vec2  Left hand operand\n---@param b Vec2  Right hand operand\n---@return number\nfunction Vec2.Dist2(a, b)\n    local dx = a.x - b.x\n    local dy = a.y - b.y\n    return dx * dx + dy * dy\nend\n\n--- Scale a vector by a scalar.\n---@param a Vec2  Left hand operand\n---@param b number Right hand operand\n---@return Vec2 out\nfunction Vec2.Scale(a, b)\n    return Vec2.New(\n        a.x * b,\n        a.y * b\n    )\nend\n\n--- Rotate a vector.\n---@param a Vec2  Vector to rotate\n---@param phi number Angle to rotate vector by (in radians)\n---@return Vec2 out\nfunction Vec2.Rotate(a, phi)\n    local c = cos(phi)\n    local s = sin(phi)\n    return Vec2.New(\n        c * a.x - s * a.y,\n        s * a.x + c * a.y\n    )\nend\n\n--- Get the perpendicular vector of a vector.\n---@param a Vec2  Vector to get perpendicular axes from\n---@return Vec2 out\nfunction Vec2.Perpendicular(a)\n    return Vec2.New(-a.y, a.x)\nend\n\n--- Signed angle from one vector to another.\n-- Rotations from +x to +y are positive.\n---@param a Vec2  Vector\n---@param b Vec2  Vector\n---@return number angle in [-pi, pi]\nfunction Vec2.AngleTo(a, b)\n    if b then\n        local angle = atan2(b.y, b.x) - atan2(a.y, a.x)\n        -- convert to (-pi, pi]\n        if angle > math.pi then\n            angle = angle - 2 * math.pi\n        elseif angle <= -math.pi then\n            angle = angle + 2 * math.pi\n        end\n        return angle\n    end\n\n    return atan2(a.y, a.x)\nend\n\n--- Lerp between two vectors.\n---@param a Vec2  Left hand operand\n---@param b Vec2  Right hand operand\n---@param s number Step value\n---@return Vec2\nfunction Vec2.Lerp(a, b, s)\n    return a + (b - a) * s\nend\n\n--- Unpack a vector into individual components.\n---@param a Vec2  Vector to unpack\n---@return number x\n---@return number y\nfunction Vec2.Unpack(a)\n    return a.x, a.y\nend\n\n--- Return the component-wise minimum of two vectors.\n---@param a Vec2  Left hand operand\n---@param b Vec2  Right hand operand\n---@return Vec2 A vector where each component is the lesser value for that component between the two given vectors.\nfunction Vec2.ComponentMin(a, b)\n    return Vec2.New(math.min(a.x, b.x), math.min(a.y, b.y))\nend\n\n--- Return the component-wise maximum of two vectors.\n---@param a Vec2  Left hand operand\n---@param b Vec2  Right hand operand\n---@return Vec2 A vector where each component is the lesser value for that component between the two given vectors.\nfunction Vec2.ComponentMax(a, b)\n    return Vec2.New(math.max(a.x, b.x), math.max(a.y, b.y))\nend\n\n--- Return a boolean showing if a table is or is not a Vec2.\n---@param a any  Vector to be tested\n---@return boolean is_Vec2\nfunction Vec2.IsVec2(a)\n    return type(a) == \"table\" and\n        type(a.x) == \"number\" and\n        type(a.y) == \"number\"\nend\n\n--- Return a boolean showing if a table is or is not a zero Vec2.\n---@param a Vec2  Vector to be tested\n---@return boolean is_zero\nfunction Vec2.IsZero(a)\n    return a.x == 0 and a.y == 0\nend\n\n--- Convert point from cartesian to polar.\n---@param a Vec2  Vector to convert\n---@return number radius\n---@return number theta\nfunction Vec2.ToPolar(a)\n    local radius = sqrt(a.x ^ 2 + a.y ^ 2)\n    local theta  = atan2(a.y, a.x)\n    theta        = theta > 0 and theta or theta + 2 * math.pi\n    return radius, theta\nend\n\n-- Negate x axis only of vector.\n---@param a Vec2  Vector to x-flip.\n---@return Vec2 x-flipped vector\nfunction Vec2.FlipX(a)\n    return Vec2.New(-a.x, a.y)\nend\n\n-- Negate y axis only of vector.\n---@param a Vec2  Vector to y-flip.\n---@return Vec2 y-flipped vector\nfunction Vec2.FlipY(a)\n    return Vec2.New(a.x, -a.y)\nend\n\n-- Returns the absolute value\n---@param a Vec2  Vector to abs\n---@return Vec2\nfunction Vec2.Abs(a)\n    return Vec2.New(abs(a.x), abs(a.y))\nend\n\n--- Return a formatted string.\n---@param a Vec2  Vector to be turned into a string\n---@return string formatted\nfunction Vec2.ToString(a)\n    return string.format(\"(%+0.3f,%+0.3f)\", a.x, a.y)\nend\n\nfunction Vec2.__tostring(a)\n    return a:ToString()\nend\n\n---Negation operator\n---@param a Vec2\n---@return Vec2\nfunction Vec2.__unm(a)\n    return Vec2.New(-a.x, -a.y)\nend\n\n---Equality operator\n---@param a Vec2|any\n---@param b Vec2|any\n---@return boolean\nfunction Vec2.__eq(a, b)\n    if not Vec2.IsVec2(a) or not Vec2.IsVec2(b) then\n        return false\n    end\n    return a.x == b.x and a.y == b.y\nend\n\n---Addition operator\n---@param a Vec2\n---@param b Vec2\n---@return Vec2\nfunction Vec2.__add(a, b)\n    return a:Add(b)\nend\n\n---Subtraction operator\n---@param a Vec2\n---@param b Vec2\n---@return Vec2\nfunction Vec2.__sub(a, b)\n    return a:Sub(b)\nend\n\n---Multiplication operator\n---@param a Vec2\n---@param b Vec2|number\n---@return Vec2\nfunction Vec2.__mul(a, b)\n    if Vec2.IsVec2(b) then\n        ---@cast b Vec2\n        return a:Mul(b)\n    end\n\n    ---@cast b number\n    return a:Scale(b)\nend\n\n---Division operator\n---@param a Vec2\n---@param b Vec2|number\n---@return Vec2\nfunction Vec2.__div(a, b)\n    if Vec2.IsVec2(b) then\n        ---@cast b Vec2\n        return a:Div(b)\n    end\n\n    return a:Scale(1 / b)\nend\n\n---Creates a Vec2 from a string\n---@param s string\n---@return Vec2|nil\nfunction Vec2.FromString(s)\n    if s then\n        local x, y = s:match(\"^%(%s?([+-]*%d*%.?%d+)%s?,%s?([+-]*%d*%.?%d+)%s?%)$\")\n        x = tonumber(x)\n        y = tonumber(y)\n        if x and y then\n            return Vec2.New(x, y)\n        end\n    end\n    return nil\nend\n\nreturn Vec2\n\nend)\npackage.preload['YFS:info/Fuel.lua']=(function()\nrequire('YFS:GlobalTypes.lua')\nlocal s                                       = require('YFS:Singletons.lua')\nlocal log, pub                                = s.log, s.pub\n\nlocal Container, ContainerTalents, Task, Vec2 = require('YFS:../e/lib/src/element/Container.lua'), require('YFS:../e/lib/src/element/ContainerTalents.lua'),\n    require('YFS:../e/lib/src/system/Task.lua'), require('YFS:../e/render/src/native/Vec2.lua')\nrequire('YFS:../e/lib/src/util/Table.lua')\n\n---@alias FuelTankInfo {name:string, factorBar:Vec2, percent:number, visible:boolean, type:string}\n\n---@class Fuel\n---@field Instance fun():Fuel\n\nlocal Fuel   = {}\nFuel.__index = Fuel\nlocal instance\n\n---@param settings Settings\n---@return Fuel\nfunction Fuel.New(settings)\n    if instance then\n        return instance\n    end\n\n    local talents = ContainerTalents.New(\n        settings.Number(\"containerProficiency\", 0),\n        settings.Number(\"fuelTankOptimization\", 0),\n        settings.Number(\"containerOptimization\", 0),\n        settings.Number(\"atmoFuelTankHandling\", 0),\n        settings.Number(\"spaceFuelTankHandling\", 0),\n        settings.Number(\"rocketFuelTankHandling\", 0))\n\n    local s = {}\n\n    Task.New(\"FuelMonitor\", function()\n        local sw = Stopwatch.New()\n        sw.Start()\n\n        local fuelTanks = {\n            atmo = Container.GetAllCo(ContainerType.Atmospheric),\n            space = Container.GetAllCo(ContainerType.Space),\n            rocket = Container.GetAllCo(ContainerType.Rocket)\n        }\n\n        while true do\n            if sw.IsRunning() and sw.Elapsed() < 2 then\n                coroutine.yield()\n            else\n                local byType = {} ---@type table<string,FuelTankInfo[]>\n\n                for fuelType, tanks in pairs(fuelTanks) do\n                    for _, tank in ipairs(tanks) do\n                        local factor = tank.FuelFillFactor(talents)\n                        local curr = {\n                            name = tank.Name(),\n                            factorBar = Vec2.New(1, factor),\n                            percent = factor * 100,\n                            visible = true,\n                            type = fuelType\n                        }\n\n                        local bt = byType[fuelType] or {}\n                        bt[#bt + 1] = curr\n                        byType[fuelType] = bt\n                    end\n\n                    -- Sort tanks for HUD in alphabetical order\n                    if byType[fuelType] then\n                        table.sort(byType[fuelType], function(a, b)\n                            return a.name < b.name\n                        end)\n                    end\n                end\n\n                pub.Publish(\"FuelByType\", DeepCopy(byType))\n\n                sw.Restart()\n            end\n        end\n    end).Then(function(...)\n        log.Info(\"No fuel tanks detected\")\n    end).Catch(function(t)\n        log.Error(t.Name(), t.Error())\n    end)\n\n    settings.Callback(\"containerProficiency\", function(value)\n        talents.ContainerProficiency = value\n    end)\n\n    settings.Callback(\"fuelTankOptimization\", function(value)\n        talents.FuelTankOptimization = value\n    end)\n\n    settings.Callback(\"containerOptimization\", function(value)\n        talents.ContainerOptimization = value\n    end)\n\n    settings.Callback(\"atmoFuelTankHandling\", function(value)\n        talents.AtmoFuelTankHandling = value\n    end)\n\n    settings.Callback(\"spaceFuelTankHandling\", function(value)\n        talents.SpaceFuelTankHandling = value\n    end)\n\n    settings.Callback(\"rocketFuelTankHandling\", function(value)\n        talents.RocketFuelTankHandling = value\n    end)\n\n    instance = setmetatable(s, Fuel)\n    return instance\nend\n\nreturn Fuel\n\nend)\npackage.preload['YFS:Settings.lua']=(function()\nlocal log, cmd, constants = require('YFS:../e/lib/src/debug/Log.lua').Instance(),\n    require('YFS:../e/lib/src/commandline/CommandLine.lua').Instance(),\n    require('YFS:YFSConstants.lua')\n\n---@module \"storage/BufferedDB\"\n\n---@class Settings\n---@field Create fun(db:BufferedDB):Settings\n---@field Instance fun():Settings\n---@field Callback fun(key:string, f:fun(any))\n---@field Reload fun()\n---@field Get fun(key:string, default?:any):string|number|table|nil\n---@field Number fun(key:string, default?:number):number\n---@field Boolean fun(key:string, default?:boolean):boolean\n---@field String fun(key:string, default?:string):string\n\nlocal singleton\nlocal Settings            = {}\nSettings.__index          = Settings\n\n---Creates a new Setting\n---@param db BufferedDB\n---@return Settings\nfunction Settings.Create(db)\n    if singleton then\n        return singleton\n    end\n\n    local s = {}\n\n    local subscribers = {} ---@type table<string,fun(any)[]>\n\n    local function publishToSubscribers(key, value)\n        -- Notify subscribers for the key\n        local subs = subscribers[key]\n        if subs then\n            for _, f in pairs(subs) do\n                f(value)\n            end\n        end\n    end\n\n    local containerSettings = {\n        containerProficiency = { default = 0 },\n        fuelTankOptimization = { default = 0 },\n        containerOptimization = { default = 0 },\n        atmoFuelTankHandling = { default = 0 },\n        spaceFuelTankHandling = { default = 0 },\n        rocketFuelTankHandling = { default = 0 },\n    }\n\n    local f = constants.flight\n    local speedPid = f.speedPid\n    local lightPid = f.axis.light\n    local heavyPid = f.axis.heavy\n    local routeDefaults = constants.route\n    ---@type {default:string|number|boolean}\n    local settings = {\n        engineWarmup = { default = 1 },\n        speedp = { default = speedPid.p },\n        speedi = { default = speedPid.i },\n        speedd = { default = speedPid.d },\n        speeda = { default = speedPid.a },\n        lightp = { default = lightPid.p },\n        lighti = { default = lightPid.i },\n        lightd = { default = lightPid.d },\n        lighta = { default = lightPid.a },\n        heavyp = { default = heavyPid.p },\n        heavyi = { default = heavyPid.i },\n        heavyd = { default = heavyPid.d },\n        heavya = { default = heavyPid.a },\n        autoShutdownFloorDistance = { default = routeDefaults.autoShutdownFloorDistance },\n        autoBrakeDelay = { default = 1 },\n        yawAlignmentThrustLimiter = { default = routeDefaults.yawAlignmentThrustLimiter },\n        pitchAlignmentThrustLimiter = { default = routeDefaults.pitchAlignmentThrustLimiter },\n        rollAlignmentThrustLimiter = { default = routeDefaults.rollAlignmentThrustLimiter },\n        autoPitch = { default = false },\n        routeStartDistanceLimit = { default = routeDefaults.routeStartDistanceLimit },\n        showWidgetsOnStart = { default = constants.widgets.showOnStart },\n        throttleStep = { default = constants.flight.throttleStep },\n        manualControlOnStartup = { default = false },\n        turnAngle = { default = constants.flight.defaultTurnAngle },\n        minimumPathCheckOffset = { default = f.minimumPathCheckOffset },\n        showFloor = { default = \"-\" },\n        pathAlignmentAngleLimit = { default = f.pathAlignmentAngleLimit },\n        pathAlignmentDistanceLimit = { default = f.pathAlignmentDistanceLimit },\n        pathAlignmentDistanceLimitFromSurface = { default = 0 },\n        setWaypointAlongRoute = { default = false },\n        commChannel = { default = \"\" },\n        shutdownDelayForGate = { default = 2 },\n        openGateWaitDelay = { default = 3 },\n        gateControlDistance = { default = routeDefaults.gateControlDistance },\n        dockingMode = { default = 1 }, -- 1 = Manual, 2 = Automatic, 3 = Only own constructs,\n        globalMaxSpeed = { default = 0 },\n        showRadarOnStart = { default = false },\n        defaultRadarMode = { default = 1 },\n        allowForwardToggle = { default = false },\n        autoBrakeAngle = { default = 45 },\n        parkMaxSpeed = { default = 50 },\n        parkMargin = { default = 0.5 },\n        parkVertDist = { default = 0 },\n        parkForwardDist = { default = 0 },\n        parkUseGates = { default = false }\n    }\n\n    for k, v in pairs(containerSettings) do\n        settings[k] = v\n    end\n\n    local set = cmd.Accept(\"set\",\n        ---@param data table\n        function(data)\n            for key, _ in pairs(settings) do\n                local val = data[key]\n                if val ~= nil then\n                    db.Put(key, val)\n                    publishToSubscribers(key, val)\n                    log.Info(\"Set '\", key, \"' to '\", val, \"'\")\n                end\n            end\n        end)\n\n    for key, v in pairs(settings) do\n        local opt = string.format(\"-%s\", key)\n        if type(v.default) == \"number\" then\n            set.Option(opt).AsNumber()\n        elseif type(v.default) == \"string\" then\n            set.Option(opt).AsString()\n        elseif type(v.default) == \"boolean\" then\n            set.Option(opt).AsBoolean()\n        end\n    end\n\n    cmd.Accept(\"reset-settings\", function(_)\n        for key, value in pairs(settings) do\n            db.Put(key, value.default)\n            log.Info(\"Reset '\", key, \"' to '\", value.default, \"'\")\n        end\n\n        s.Reload()\n    end)\n\n\n    local freeModeSettings = {\n        autoBrakeDelay = 0,\n        allowForwardToggle = true,\n        manualControlOnStartup = true,\n        minimumPathCheckOffset = 5000,\n        turnAngle = 8,\n        yawAlignmentThrustLimiter = 360,\n        pitchAlignmentThrustLimiter = 360,\n        rollAlignmentThrustLimiter = 360,\n        pathAlignmentDistanceLimitFromSurface = 0,\n        autoPitch = true\n    }\n\n    local function setModeOpts(useDefault)\n        for k, v in pairs(freeModeSettings) do\n            if useDefault then\n                v = settings[k].default\n            end\n            db.Put(k, v)\n            log.Info(\"Set \", k, \" to \", v)\n        end\n        s.Reload()\n    end\n\n    cmd.Accept(\"strict-mode\", function()\n        setModeOpts(true)\n        log.Info(\"Settings adjusted for strict mode\")\n    end)\n\n    cmd.Accept(\"free-mode\", function()\n        setModeOpts(false)\n        log.Info(\"Settings adjusted for free mode\")\n    end)\n\n    cmd.Accept(\"get\",\n        ---@param data {commandValue:string}\n        function(data)\n            local setting = settings[data.commandValue]\n\n            if setting == nil then\n                log.Error(\"Unknown setting: \", data.commandValue)\n                return\n            end\n\n\n            log.Info(data.commandValue, \": \", s.Get(data.commandValue, setting.default))\n        end).AsString().Must()\n\n    cmd.Accept(\"get-all\", function(_)\n        local keys = {} ---@type string[]\n        for key, _ in pairs(settings) do\n            keys[#keys + 1] = key\n        end\n\n        table.sort(keys)\n\n        for _, key in pairs(keys) do\n            log.Info(key, \": \", s.Get(key))\n        end\n    end)\n\n    cmd.Accept(\"set-full-container-boosts\", function(_)\n        for key, _ in pairs(containerSettings) do\n            cmd.Exec(string.format(\"set -%s %d\", key, 5))\n        end\n    end)\n\n    ---@param key string The key to get notified of\n    ---@param func fun(any) A function with signature function(value)\n    function s.Callback(key, func)\n        if not subscribers[key] then\n            subscribers[key] = {}\n        end\n\n        table.insert(subscribers[key], func)\n    end\n\n    ---@param key string\n    ---@param default? string|number|table|boolean|nil\n    ---@return string|number|table|boolean|nil\n    function s.Get(key, default)\n        local setting = settings[key]\n\n        -- If no default is provided, use the one in the definition\n        if default == nil then\n            return db.Get(key, setting.default)\n        end\n\n        return db.Get(key, default)\n    end\n\n    ---@param key string\n    ---@param default? boolean\n    ---@return boolean\n    function s.Boolean(key, default)\n        local v = s.Get(key, default)\n        ---@cast v boolean\n        return v\n    end\n\n    ---@param key string\n    ---@param default? number\n    ---@return number\n    function s.Number(key, default)\n        local v = s.Get(key, default)\n        ---@cast v number\n        return v\n    end\n\n    ---@param key string\n    ---@param default? string\n    ---@return string\n    function s.String(key, default)\n        local v = s.Get(key, default)\n        ---@cast v string\n        return v\n    end\n\n    function s.Reload()\n        for key, _ in pairs(settings) do\n            local stored = s.Get(key)\n            publishToSubscribers(key, stored)\n        end\n    end\n\n    singleton = setmetatable(s, Settings)\n    return singleton\nend\n\n---@return Settings\nfunction Settings.Instance()\n    if not singleton then\n        error(\"Settings not yet created\")\n    end\n\n    return singleton\nend\n\nreturn Settings\n\nend)\npackage.preload['YFS:flight/AxisControl.lua']=(function()\nrequire('YFS:../e/lib/src/abstraction/Vehicle.lua')\nlocal si, Vec3, PID                     = require('YFS:Singletons.lua'), require('YFS:../e/lib/src/math/Vec3.lua'), require(\"cpml/pid\")\nlocal yfsC, pub, calc                   = si.constants, si.pub, si.calc\n\nlocal SignLargestAxis, SignedRotationAngle, setEngineCommand,\nLightConstructMassThreshold, nullVec    =\n    calc.SignLargestAxis,\n    calc.SignedRotationAngle,\n    unit.setEngineCommand,\n    yfsC.flight.lightConstructMassThreshold,\n    Vec3.zero\n\nlocal rad2deg                           = 180 / math.pi\n\nlocal control                           = {}\ncontrol.__index                         = control\n\n---@enum ControlledAxis\nControlledAxis                          = {\n    Pitch = 1,\n    Roll = 2,\n    Yaw = 3,\n}\n\nlocal finalAcceleration                 = {} ---@type Vec3[]\nfinalAcceleration[ControlledAxis.Pitch] = nullVec\nfinalAcceleration[ControlledAxis.Roll]  = nullVec\nfinalAcceleration[ControlledAxis.Yaw]   = nullVec\n\n---@class AxisControl\n---@field ReceiveEvents fun()\n---@field StopEvents fun()\n---@field Disable fun()\n---@field Speed fun():number\n---@field Acceleration fun():number\n---@field AxisFlush fun(deltaTime:number)\n---@field Update fun()\n---@field SetTarget fun(target:Vec3)\n---@field OffsetDegrees fun():number\n---@field Apply fun()\n\nlocal AxisControl                       = {}\nAxisControl.__index                     = AxisControl\n\n\n---Creates a new AxisControl\n---@param axis ControlledAxis\n---@return AxisControl A new AxisControl\nfunction AxisControl.New(axis)\n    local s = {}\n\n    local reference = nil ---@type fun():Vec3\n    local normal = nil ---@type fun():Vec3\n    local localNormal = nil ---@type fun():Vec3\n\n    local updateHandlerId = nil\n    local targetCoordinate = nil ---@type Vec3|nil\n\n    -- taylor local lightPid = PID(1, 10, 100, 0.1)\n\n    local set, axisPids = require('YFS:Settings.lua').Instance(), yfsC.flight.axis\n    local l = axisPids.light\n    local h = axisPids.heavy\n\n    local lightPid = PID(l.p, l.i, l.d, l.a)\n    local heavyPid = PID(h.p, h.i, h.d, h.a)\n    set.Callback(\"lightp\", function(v) lightPid = PID(v, lightPid.i, lightPid.d, lightPid.amortization) end)\n    set.Callback(\"lighti\", function(v) lightPid = PID(lightPid.p, v, lightPid.d, lightPid.amortization) end)\n    set.Callback(\"lightd\", function(v) lightPid = PID(lightPid.p, lightPid.i, v, lightPid.amortization) end)\n    set.Callback(\"lighta\", function(v) lightPid = PID(lightPid.p, lightPid.i, lightPid.d, v) end)\n\n    set.Callback(\"heavyp\", function(v) heavyPid = PID(v, heavyPid.i, heavyPid.d, heavyPid.amortization) end)\n    set.Callback(\"heavyi\", function(v) heavyPid = PID(heavyPid.p, v, heavyPid.d, heavyPid.amortization) end)\n    set.Callback(\"heavyd\", function(v) heavyPid = PID(heavyPid.p, heavyPid.i, v, heavyPid.amortization) end)\n    set.Callback(\"heavya\", function(v) heavyPid = PID(heavyPid.p, heavyPid.i, heavyPid.d, v) end)\n\n    local pubTopic\n    local lastReadMass = TotalMass()\n\n    local axisData = {\n        speed = 0,\n        acceleration = 0,\n        offset = 0 -- in degrees\n    }\n\n    if axis == ControlledAxis.Pitch then\n        reference = Forward\n        normal = Right\n        localNormal = LocalRight\n        pubTopic = \"PitchData\"\n    elseif axis == ControlledAxis.Roll then\n        reference = Up\n        normal = Forward\n        localNormal = LocalForward\n        pubTopic = \"RollData\"\n    elseif axis == ControlledAxis.Yaw then\n        reference = Forward\n        normal = Up\n        localNormal = LocalUp\n        pubTopic = \"YawData\"\n    end\n\n    function s.ReceiveEvents()\n        updateHandlerId = system:onEvent(\"onUpdate\", s.Update, s)\n    end\n\n    function s.StopEvents()\n        system:clearEvent(\"update\", updateHandlerId)\n    end\n\n    ---Set the alignment target/point\n    ---@param target Vec3\n    function s.SetTarget(target)\n        if target == nil then\n            s.Disable()\n        else\n            targetCoordinate = target\n        end\n    end\n\n    function s.Disable()\n        targetCoordinate = nil\n        finalAcceleration[axis] = nullVec\n    end\n\n    ---Returns the current signed angular velocity, in degrees per seconds.\n    ---@return number\n    function s.Speed()\n        local vel = LocalAngVel() * rad2deg\n        vel = vel * localNormal()\n\n        -- The normal vector gives the correct x, y or z axis part of the speed\n        -- We need the sign of the speed\n        return vel:Len() * SignLargestAxis(vel)\n    end\n\n    function s.Acceleration()\n        local vel = LocalAngAcc() * rad2deg\n        -- The normal vector gives the correct x, y or z axis part of the acceleration\n        return (vel * localNormal()):Len()\n    end\n\n    ---@param deltaTime number\n    function s.AxisFlush(deltaTime)\n        if targetCoordinate then\n            -- Positive offset means we're right of target, clock-wise\n            -- Positive acceleration turns counter-clockwise\n            -- Positive velocity means we're turning counter-clockwise\n\n            local vecToTarget = (targetCoordinate - Current()):Normalize()\n            local offset = SignedRotationAngle(normal(), reference(), vecToTarget)\n            axisData.offset = offset * rad2deg\n\n            lightPid:inject(offset)\n            heavyPid:inject(offset)\n\n            local v\n            if lastReadMass > LightConstructMassThreshold then\n                v = heavyPid:get()\n            else\n                v = lightPid:get()\n            end\n\n            finalAcceleration[axis] = normal() * v\n        end\n    end\n\n    function s.Apply()\n        local acc = finalAcceleration[ControlledAxis.Pitch] + finalAcceleration[ControlledAxis.Roll] +\n            finalAcceleration[ControlledAxis.Yaw]\n        setEngineCommand(\"torque\", { 0, 0, 0 }, { acc:Unpack() }, true, true, \"\", \"\", \"\", 0.1)\n    end\n\n    function s.Update()\n        axisData.speed = s.Speed()\n        axisData.acceleration = s.Acceleration()\n        pub.Publish(pubTopic, axisData)\n        lastReadMass = TotalMass()\n    end\n\n    ---Returns the current offset, in degrees\n    ---@return number\n    function s.OffsetDegrees()\n        return axisData.offset\n    end\n\n    return setmetatable(s, control)\nend\n\nreturn AxisControl\n\nend)\npackage.preload['YFS:flight/AxisManager.lua']=(function()\nlocal AxisControl = require('YFS:flight/AxisControl.lua')\n\n---@class AxisManager\n---@field Pitch fun():AxisControl\n---@field Yaw fun():AxisControl\n---@field Roll fun():AxisControl\n---@field Flush fun(deltaTime:number)\n---@field ReceiveEvents fun()\n---@field StopEvents fun()\n---@field SetYawTarget fun(target:Vec3?)\n---@field SetPitchTarget fun(target:Vec3?)\n---@field SetRollTarget fun(target:Vec3?)\n\nlocal AxisManager = {}\nAxisManager.__index = AxisManager\nlocal instance ---@type AxisManager\n\n---@return AxisManager\nfunction AxisManager.Instance()\n    if instance then return instance end\n\n    local s = {}\n\n    local pitch, roll, yaw = AxisControl.New(ControlledAxis.Pitch), AxisControl.New(ControlledAxis.Roll),\n        AxisControl.New(ControlledAxis.Yaw)\n\n    function s.ReceiveEvents()\n        pitch.ReceiveEvents()\n        roll.ReceiveEvents()\n        yaw.ReceiveEvents()\n    end\n\n    function s.StopEvents()\n        pitch.StopEvents()\n        roll.StopEvents()\n        yaw.StopEvents()\n    end\n\n    ---@param target Vec3?\n    function s.SetYawTarget(target)\n        if target then yaw.SetTarget(target) else yaw.Disable() end\n    end\n\n    ---@param target Vec3?\n    function s.SetPitchTarget(target)\n        if target then pitch.SetTarget(target) else pitch.Disable() end\n    end\n\n    ---@param target Vec3?\n    function s.SetRollTarget(target)\n        if target then roll.SetTarget(target) else roll.Disable() end\n    end\n\n    ---@param deltaTime number\n    function s.Flush(deltaTime)\n        -- Enabling this causes an uninteded roll when making hard turns.\n        --if abs(yaw.OffsetDegrees()) > 20 then\n        --roll.Disable()\n        --end\n\n        pitch.AxisFlush(deltaTime)\n        roll.AxisFlush(deltaTime)\n        yaw.AxisFlush(deltaTime)\n\n        -- Can call apply on any of the axes, it doesn't matter\n        yaw.Apply()\n    end\n\n    function s.Yaw() return yaw end\n\n    function s.Pitch() return pitch end\n\n    function s.Roll() return roll end\n\n    instance = setmetatable(s, AxisManager)\n    return instance\nend\n\nreturn AxisManager\n\nend)\npackage.preload['YFS:flight/AdjustmentTracker.lua']=(function()\nlocal PID = require(\"cpml/pid\")\n\n---@class AdjustmentTracker\n---@field Feed fun(distance:number):number\n---@field LastDistance fun():number\n---@field ResetPID fun()\n\nlocal AdjustmentTracker = {}\nAdjustmentTracker.__index = AdjustmentTracker\n\n---@param lightConstruct boolean True if the construct is light\n---@return AdjustmentTracker\nfunction AdjustmentTracker.New(lightConstruct)\n    local s = {}\n    local pid\n    if lightConstruct then\n        pid = PID(0.01, 0.1, 5, 0.5)\n    else\n        pid = PID(1, 0.5, 5, 0.5)\n    end\n\n    local lastDistance = 0\n\n    ---@return number\n    function s.LastDistance()\n        return lastDistance\n    end\n\n    ---@param distance number\n    ---@return number\n    function s.Feed(distance)\n        lastDistance = distance\n        pid:inject(distance)\n        return pid:get()\n    end\n\n    function s.ResetPID()\n        pid:reset()\n    end\n\n    return setmetatable(s, AdjustmentTracker)\nend\n\nreturn AdjustmentTracker\n\nend)\npackage.preload['YFS:../e/lib/src/abstraction/Constants.lua']=(function()\nlocal constants = {\n    PHYSICS_INTERVAL = 1 / 60\n}\n\nreturn constants\n\nend)\npackage.preload['YFS:../e/lib/src/abstraction/Engine.lua']=(function()\nrequire('YFS:../e/lib/src/abstraction/Vehicle.lua')\nlocal calc      = require('YFS:../e/lib/src/util/Calc.lua')\nlocal constants = require('YFS:../e/lib/src/abstraction/Constants.lua')\nlocal Ternary   = calc.Ternary\nlocal abs       = math.abs\nlocal min       = math.min\nlocal mtaa      = construct.getMaxThrustAlongAxis\n\nlocal function getLongitudinalForce()\n    return mtaa(\n        IsInAtmo() and \"longitudinal atmospheric_engine\" or \"longitudinal space_engine\",\n        { LocalForward():Unpack() })\nend\n\nlocal function getLateralForce()\n    return mtaa(IsInAtmo() and \"lateral atmospheric_engine\" or \"lateral space_engine\",\n        { LocalRight():Unpack() })\nend\n\nlocal function getVerticalForce()\n    return mtaa(IsInAtmo() and \"vertical atmospheric_engine\" or \"vertical space_engine\",\n        { LocalUp():Unpack() })\nend\n\nlocal function getVerticalHoverForce()\n    return mtaa(\"vertical hover_engine\", { LocalUp():Unpack() })\nend\n\nlocal function getVerticalBoosterForce()\n    return mtaa(\"vertical booster_engine\", { LocalUp():Unpack() })\nend\n\nlocal atmoRangeFMaxPlus = 1\nlocal atmoRangeFMaxMinus = 2\nlocal spaceRangeFMaxPlus = 3\nlocal spaceRangeFMaxMinus = 4\n\n---@alias rangeFunc fun():number[]\n---@alias rangeFuncArr rangeFunc[]\n\n---@param ranges rangeFunc[] The functions to call to get atmo and space forces. First one should be the regular engines, next hovers and vertical boosters\n---@param positive boolean\n---@return number\nlocal function getCurrent(ranges, positive)\n    local plus, minus\n    if IsInAtmo() then\n        plus = atmoRangeFMaxPlus\n        minus = atmoRangeFMaxMinus\n    else\n        plus = spaceRangeFMaxPlus\n        minus = spaceRangeFMaxMinus\n    end\n\n    local r = { FMaxPlus = 0, FMaxMinus = 0 }\n\n    for i, range in ipairs(ranges) do\n        local curr = range()\n\n        -- Only fallback to secondary ranges if first one doesn't have any force\n        r.FMaxPlus = r.FMaxPlus == 0 and curr[plus] or r.FMaxPlus\n        r.FMaxMinus = r.FMaxMinus == 0 and curr[minus] or r.FMaxMinus\n    end\n\n    return positive and r.FMaxPlus or r.FMaxMinus\nend\n\n---@class EngineAbs\n---@field Instance fun():EngineAbs\n---@field GetAvailableThrust fun(reduceMode:boolean, direction:Vec3, considerAtmoDensity?:boolean):number\n\nlocal Engine = {}\nEngine.__index = Engine\nlocal s\n\n---Gets the Engine instance\n---@return EngineAbs\nfunction Engine.Instance()\n    if s then\n        return s\n    end\n\n    s = {}\n\n    ---The maximum acceleration the construct can give without pushing itself more in one direction than the others.\n    ---@param reduceMode boolean If true, returns the available thust while taking the weaker engines into account\n    ---@param direction Vec3 Direction to move\n    ---@param considerAtmoDensity? boolean If true, consider atmo influence on engine power\n    ---@return number # Avaliable acceleration\n    function s.GetAvailableThrust(reduceMode, direction, considerAtmoDensity)\n        if direction:IsZero() then\n            return 0\n        end\n\n        direction = calc.WorldDirectionToLocal(direction)\n        local totalMass = TotalMass()\n\n        -- Add current gravity influence as force in Newtons\n\n        local gravDir = calc.WorldDirectionToLocal(GravityDirection())\n\n        local gravityForce = Vec3.zero\n        if gravDir:Dot(direction) > 0 then\n            -- Moving along gravity, consider it as an engine.\n            -- Note to self: Don't add gravity if not travelling along it, that will reduce reported available engine force.\n            gravityForce = gravDir * G() * totalMass\n        end\n\n        -- Setup engines using the thrust for the direction they make the construct move (i.e. opposite to thrust direction)\n        ---@alias ThrustAndDir { dir:Vec3, thrust:number }\n        ---@type ThrustAndDir\n        local engines = {\n            { dir = -LocalRight(),   thrust = abs(s:MaxLeftwardThrust()) },\n            { dir = LocalRight(),    thrust = abs(s:MaxRightwardThrust()) },\n            { dir = -LocalUp(),      thrust = abs(s:MaxDownwardThrust()) },\n            { dir = LocalUp(),       thrust = abs(s:MaxUpwardThrust()) },\n            { dir = -LocalForward(), thrust = abs(s:MaxBackwardThrust()) },\n            { dir = LocalForward(),  thrust = abs(s:MaxForwardThrust()) }\n        }\n\n        -- Find engines that contribute to the movement in the desired direction\n        local minThrust = math.huge\n        local mainEngine = nil ---@type ThrustAndDir|nil\n\n        for _, engine in ipairs(engines) do\n            local dot = engine.dir:Dot(direction)\n\n            -- Add gravity before any use of the engine (or we'll think we can't move downward due to \"no engine\")\n            engine.thrust = engine.thrust + gravityForce:Dot(engine.dir)\n            -- Compare with a near-zero value for dot as we get values like 1e-11 which are still > 0 but too small to use.\n\n            if dot > 0.001 and engine.thrust > 0.01 then\n                -- Calculate the thrust this engine can give for the direction and add the gravity force\n                local thrust = engine.thrust\n                if thrust < minThrust then\n                    minThrust = thrust\n                end\n\n                -- Find \"main\" engine closest to direction\n                if not mainEngine then\n                    mainEngine = engine\n                elseif engine.dir:AngleTo(direction) < mainEngine.dir:AngleTo(direction) then\n                    mainEngine = engine\n                end\n            end\n        end\n\n        -- No engine?\n        if not mainEngine then\n            return 0\n        end\n\n        local availableForce = mainEngine.thrust\n\n        -- Should we limit thrust to weaker engine?\n        if reduceMode and mainEngine.dir:AngleToDeg(direction) > 10 then\n            -- Closest engine is outside limit so limit to weakest\n            availableForce = minThrust\n        end\n\n        local availableThrust = direction * availableForce\n\n        -- When space engines kick in, don't consider atmospheric density.\n        if considerAtmoDensity and IsInAtmo() then\n            availableThrust = availableThrust * AtmoDensity()\n        end\n\n        -- Remember that this value is the acceleration, m/s2, not how many g:s we can give. To get that, divide by the current world gravity.\n        return availableThrust:Len() / totalMass\n    end\n\n    function s:MaxForwardThrust()\n        return getCurrent({ getLongitudinalForce }, true)\n    end\n\n    function s:MaxBackwardThrust()\n        return getCurrent({ getLongitudinalForce }, false)\n    end\n\n    function s:MaxRightwardThrust()\n        return getCurrent({ getLateralForce }, true)\n    end\n\n    function s:MaxLeftwardThrust()\n        return getCurrent({ getLateralForce }, false)\n    end\n\n    function s:MaxUpwardThrust()\n        return getCurrent({ getVerticalForce, getVerticalHoverForce, getVerticalBoosterForce }, true)\n    end\n\n    function s:MaxDownwardThrust()\n        return getCurrent({ getVerticalForce }, false)\n    end\n\n    return setmetatable(s, Engine)\nend\n\nreturn Engine\n\nend)\npackage.preload['YFS:../e/lib/src/util/Ray.lua']=(function()\nlocal Vec3 = require('YFS:../e/lib/src/math/Vec3.lua')\n\n---@class Ray\n---@field New fun(start:Vec3, direction:Vec3):Ray\n---@field Start Vec3 The start point of the ray\n---@field Dir Vec3 The direction the ray points\n\nlocal Ray = {}\nRay.__index = Ray\nfunction Ray.New(start, direction)\n    local s = {\n        Start = start,\n        Dir = direction\n    }\n\n    return setmetatable(s, Ray)\nend\n\nreturn Ray\n\nend)\npackage.preload['YFS:flight/state/Hold.lua']=(function()\n---@module \"flight/state/Travel\"\n---@module \"element/Telemeter\"\n\nrequire('YFS:../e/lib/src/abstraction/Vehicle.lua')\nlocal s                            = require('YFS:Singletons.lua')\nlocal log, pub, gateControl, timer = s.log, s.pub, s.gateCtrl, s.timer\n\n\n---@class Hold\n---@field New fun(fsm:FlightFSM):FlightState\n---@field Enter fun()\n---@field Leave fun()\n---@field Flush fun(deltaTime:number, next:Waypoint, previous:Waypoint, nearestPointOnPath:Vec3)\n---@field AtWaypoint fun(isLastWaypoint:boolean, next:Waypoint, previous:Waypoint)\n---@field Update fun()\n---@field Name fun():string\n\nlocal Hold = {}\nHold.__index = Hold\n\nlocal name = \"Hold\"\n\n---Creates a new Hold state\n---@param fsm FlightFSM\n---@return FlightState\nfunction Hold.New(fsm)\n    local s = {}\n    local isLastWaypoint = false\n    local settings = fsm.GetSettings()\n    local rc = fsm.GetRouteController()\n\n    local function waitForGatesToClose()\n        if fsm.GetFlightCore().WaitForGate() then\n            timer.Add(\"WaitForGatesToClose\", function()\n                    unit.exit()\n                end,\n                settings.Number(\"shutdownDelayForGate\"))\n        else\n            unit.exit()\n        end\n    end\n\n    function s.Enter()\n        pub.RegisterTable(\"FloorMonitor\", s.floorMonitor)\n        if fsm.GetFlightCore().WaitForGate() then\n            gateControl.Close()\n        end\n    end\n\n    function s.Leave()\n        pub.Unregister(\"FloorMonitor\", s.floorMonitor)\n    end\n\n    ---@param deltaTime number\n    ---@param next Waypoint\n    ---@param previous Waypoint\n    ---@param nearestPointOnPath Vec3\n    function s.Flush(deltaTime, next, previous, nearestPointOnPath)\n        if not next.WithinMargin(WPReachMode.EXIT) then\n            fsm.SetState(Travel.New(fsm))\n        end\n    end\n\n    function s.Update()\n    end\n\n    function s.AtWaypoint(lastWaypoint, next, previous)\n        isLastWaypoint = lastWaypoint\n    end\n\n    function s.Name()\n        return name\n    end\n\n    ---@param topic string\n    ---@param hit TelemeterResult\n    function s.floorMonitor(topic, hit)\n        local r = rc.CurrentRoute()\n        local hasTag = true\n\n        if r then\n            hasTag = r.HasTag(\"ReturnTag\") or r.HasTag(\"RegularParkingTag\")\n        end\n\n        if (not IsFrozen() or hasTag) -- hasTag overrides frozen\n            and isLastWaypoint\n            and hit.Hit\n            and hit.Distance <= settings.Get(\"autoShutdownFloorDistance\")\n        then\n            log.Info(\"Floor detected at last waypoint, going idle.\")\n            fsm.SetState(Idle.New(fsm))\n            waitForGatesToClose()\n        end\n    end\n\n    function s.DisablesAllThrust()\n        return false\n    end\n\n    function s.PreventNextWp()\n        return false\n    end\n\n    setmetatable(s, Hold)\n    return s\nend\n\nreturn Hold\n\nend)\npackage.preload['YFS:flight/state/Idle.lua']=(function()\nlocal s        = require('YFS:Singletons.lua')\nlocal log, pub = s.log, s.pub\n\n---@class Idle\n---@field New fun(fsm:FlightFSM):FlightState\n---@field Enter fun()\n---@field Leave fun()\n---@field Flush fun(deltaTime:number, next:Waypoint, previous:Waypoint, nearestPointOnPath:Vec3)\n---@field AtWaypoint fun(isLastWaypoint:boolean, next:Waypoint, previous:Waypoint)\n---@field Update fun()\n---@field Name fun():string\n\nlocal Idle     = {}\nIdle.__index   = Idle\n\nlocal name     = \"Idle\"\n\n---Creates a new Idle state\n---@param fsm FlightFSM\n---@return FlightState\nfunction Idle.New(fsm)\n    local s = {}\n\n    local settings = fsm.GetSettings()\n\n    function s.Enter()\n        pub.RegisterTable(\"FloorMonitor\", s.floorMonitor)\n    end\n\n    function s.Leave()\n        pub.Unregister(\"FloorMonitor\", s.floorMonitor)\n    end\n\n    ---@param deltaTime number\n    ---@param next Waypoint\n    ---@param previous Waypoint\n    ---@param nearestPointOnPath Vec3\n    function s.Flush(deltaTime, next, previous, nearestPointOnPath)\n\n    end\n\n    function s.Update()\n    end\n\n    function s.AtWaypoint(isLastWaypoint, next, previous)\n    end\n\n    function s.Name()\n        return name\n    end\n\n    function s.DisablesAllThrust()\n        return true\n    end\n\n    ---@param topic string\n    ---@param hit TelemeterResult\n    function s.floorMonitor(topic, hit)\n        if not hit.Hit or hit.Distance > settings.Get(\"autoShutdownFloorDistance\") then\n            log.Info(\"Floor not detected, holding position.\")\n            fsm.GetRouteController().ActivateHoldRoute()\n            fsm.GetFlightCore().StartFlight()\n        end\n    end\n\n    function s.PreventNextWp()\n        return false\n    end\n\n    return setmetatable(s, Idle)\nend\n\nreturn Idle\n\nend)\npackage.preload['YFS:flight/state/Travel.lua']=(function()\nrequire('YFS:../e/lib/src/abstraction/Vehicle.lua')\nlocal s        = require('YFS:Singletons.lua')\nlocal floor    = s.floorDetector\n\n---@class Travel\n---@field New fun(fsm:FlightFSM):FlightState\n\nlocal Travel   = {}\nTravel.__index = Travel\n\nlocal name     = \"Travel\"\n\n---Creates a new Travel state\n---@param fsm FlightFSM\n---@return FlightState\nfunction Travel.New(fsm)\n    local s = {}\n    local rc = fsm.GetRouteController()\n    local route ---@type Route|nil\n\n    function s.Enter()\n        route = rc.CurrentRoute()\n    end\n\n    function s.Leave()\n    end\n\n    ---Flush\n    ---@param deltaTime number\n    ---@param next Waypoint\n    ---@param previous Waypoint\n    ---@param nearestPointOnPath Vec3\n    function s.Flush(deltaTime, next, previous, nearestPointOnPath)\n        -- Are we on the the desired path?\n        if not fsm.CheckPathAlignment(Current(), nearestPointOnPath, previous, next) then\n            fsm.SetState(ReturnToPath.New(fsm, nearestPointOnPath))\n        end\n    end\n\n    function s.Update()\n        if route and route.HasTag(\"RegularParkingTag\") then\n            local m = floor.Measure()\n            if m.Hit then\n                fsm.GetFlightCore().StartParking(m.Distance, \"Settling\")\n            end\n        end\n    end\n\n    function s.AtWaypoint(isLastWaypoint, next, previous)\n        if isLastWaypoint then\n            fsm.SetState(Hold.New(fsm))\n        end\n    end\n\n    function s.Name()\n        return name\n    end\n\n    function s.DisablesAllThrust()\n        return false\n    end\n\n    function s.PreventNextWp()\n        return false\n    end\n\n    return setmetatable(s, Travel)\nend\n\nreturn Travel\n\nend)\npackage.preload['YFS:flight/state/ReturnToPath.lua']=(function()\nrequire('YFS:GlobalTypes.lua')\n\n---@class ReturnToPath\n---@field New fun(fsm:FlightFSM, returnPoint:Vec3):FlightState\n---@field Enter fun()\n---@field Leave fun()\n---@field Flush fun(deltaTime:number, next:Waypoint, previous:Waypoint, nearestPointOnPath:Vec3)\n---@field Update fun()\n---@field Name fun():string\n\nlocal ReturnToPath = {}\nReturnToPath.__index = ReturnToPath\nlocal name = \"ReturnToPath\"\n\n---Creates a new ReturnPath\n---@param fsm FlightFSM\n---@param returnPoint Vec3\n---@return FlightState\nfunction ReturnToPath.New(fsm, returnPoint)\n    local s = {}\n    local temporaryWP = nil ---@type Waypoint|nil\n\n    function s.Enter()\n    end\n\n    function s.Leave()\n        fsm.SetTemporaryWaypoint()\n    end\n\n    ---Flush\n    ---@param deltaTime number\n    ---@param next Waypoint\n    ---@param previous Waypoint\n    ---@param nearestPointOnPath Vec3\n    function s.Flush(deltaTime, next, previous, nearestPointOnPath)\n        if not temporaryWP then\n            temporaryWP = Waypoint.New(returnPoint, 0, 0, fsm.GetSettings().Number(\"minimumPathCheckOffset\", 2), 0)\n            temporaryWP.LockYawTo(next.LockedYawDirection() or Plane.NewByVertialReference().Forward())\n            temporaryWP.ForceUpAlongVerticalRef()\n            fsm.SetTemporaryWaypoint(temporaryWP)\n        end\n\n        if temporaryWP.WithinMargin(WPReachMode.ENTRY) then\n            fsm.SetState(Travel.New(fsm))\n        end\n    end\n\n    function s.Update()\n    end\n\n    function s.AtWaypoint(isLastWaypoint, next, previous)\n    end\n\n    function s.Name()\n        return name\n    end\n\n    function s.DisablesAllThrust()\n        return false\n    end\n\n    function s.PreventNextWp()\n        return false\n    end\n\n    return setmetatable(s, ReturnToPath)\nend\n\nreturn ReturnToPath\n\nend)\npackage.preload['YFS:flight/state/OpenGates.lua']=(function()\nrequire('YFS:GlobalTypes.lua')\nlocal s                       = require('YFS:Singletons.lua')\nlocal log, gateControl, timer = s.log, s.gateCtrl, s.timer\n\n---@class OpenGates\n---@field New fun(fsm:FlightFSM, holdPoint:Vec3, holdDir:Vec3):FlightState\n\nlocal OpenGates               = {}\nOpenGates.__index             = OpenGates\n\nlocal name                    = \"OpenGates\"\n\n---Creates a new OpenGates state\n---@param fsm FlightFSM\n---@param holdPoint Vec3\n---@param holdDir Vec3\n---@return FlightState\nfunction OpenGates.New(fsm, holdPoint, holdDir)\n    local s = {}\n    local temporaryWP = nil ---@type Waypoint|nil\n    local commEnabled = fsm.GetSettings().String(\"commChannel\") ~= \"\"\n    local timeToWaitForOpen = fsm.GetSettings().Number(\"openGateWaitDelay\")\n    local waitToOpen = Stopwatch.New()\n\n    function s.Enter()\n        if commEnabled then\n            gateControl.Open()\n            log.Info(\"Requesting gates to open.\")\n            timer.Add(\"WaitOnGate\", function() log.Info(\"Waiting on gates to open\") end, 2)\n        end\n    end\n\n    function s.Leave()\n        timer.Remove(\"WaitOnGate\")\n        fsm.SetTemporaryWaypoint()\n    end\n\n    ---Flush\n    ---@param deltaTime number\n    ---@param next Waypoint\n    ---@param previous Waypoint\n    ---@param nearestPointOnPath Vec3\n    function s.Flush(deltaTime, next, previous, nearestPointOnPath)\n        if not temporaryWP then\n            temporaryWP = Waypoint.New(holdPoint, 0, 0, next.Margin(), 0)\n            temporaryWP.LockYawTo(holdDir)\n            fsm.SetTemporaryWaypoint(temporaryWP)\n        end\n    end\n\n    function s.Update()\n        if commEnabled then\n            if gateControl.AreInDesiredState() then\n                if waitToOpen.Elapsed() > timeToWaitForOpen then\n                    fsm.SetState(Travel.New(fsm))\n                elseif not waitToOpen.IsRunning() then\n                    waitToOpen.Start()\n                    log.Info(\"Giving gates \", timeToWaitForOpen, \" seconds to be fully open\")\n                end\n            end\n        else\n            fsm.SetState(Travel.New(fsm))\n        end\n    end\n\n    function s.AtWaypoint(isLastWaypoint, next, previous)\n\n    end\n\n    function s.Name()\n        return name\n    end\n\n    function s.DisablesAllThrust()\n        return false\n    end\n\n    function s.PreventNextWp()\n        return true\n    end\n\n    return setmetatable(s, OpenGates)\nend\n\nreturn OpenGates\n\nend)\npackage.preload['YFS:flight/state/Require.lua']=(function()\n-- Make states globally available so they can all reference each other without creating require-loops\nif not FLIGHT_STATES_INCLUDED then\n    FLIGHT_STATES_INCLUDED = true\n    Hold = require('YFS:flight/state/Hold.lua') ---@type Hold\n    Idle = require('YFS:flight/state/Idle.lua') ---@type Idle\n    Travel = require('YFS:flight/state/Travel.lua') ---@type Travel\n    ReturnToPath = require('YFS:flight/state/ReturnToPath.lua') ---@type ReturnToPath\n    OpenGates = require('YFS:flight/state/OpenGates.lua') ---@type OpenGates\nend\n\nend)\npackage.preload['YFS:flight/FlightFSM.lua']=(function()\nrequire('YFS:../e/lib/src/abstraction/Vehicle.lua')\nrequire('YFS:GlobalTypes.lua')\n\nlocal Vec3, AxisManager, AdjustmentTracker, engine, PID, Ray, s                                                    =\n    require('YFS:../e/lib/src/math/Vec3.lua'), require('YFS:flight/AxisManager.lua'), require('YFS:flight/AdjustmentTracker.lua'),\n    require('YFS:../e/lib/src/abstraction/Engine.lua').Instance(), require(\"cpml/pid\"),\n    require('YFS:../e/lib/src/util/Ray.lua'), require('YFS:Singletons.lua')\nlocal log, universe, calc, yfsConstants, pub, input, brakes                                                        = s\n    .log, s.universe, s.calc, s.constants, s.pub,\n    s.input,\n    s.brakes\n\nlocal AirFrictionAcc, LightConstructMassThreshold, DefaultMargin, Sign, nullVec, SetEngineCommand, SetEngineThrust =\n    AirFrictionAcceleration,\n    yfsConstants.flight.lightConstructMassThreshold, yfsConstants.flight.defaultMargin, calc.Sign, Vec3.zero,\n    unit.setEngineCommand, unit.setEngineThrust\n\nrequire('YFS:flight/state/Require.lua')\n\nlocal Clamp               = calc.Clamp\nlocal abs                 = math.abs\nlocal min                 = math.min\nlocal max                 = math.max\nlocal MAX_INT             = math.maxinteger\nlocal adjustmentThreshold = calc.AngleToDot(45)\n\nlocal brakeDegradeSpeed   = calc.Kph2Mps(360)\n\nlocal deadZoneFactor      = 0.8 -- Consider the inner edge of the dead zone where we can't brake to start at this percentage of the atmosphere.\n\n---@class FlightFSM\n---@field New fun(settings:Settings):FlightFSM\n---@field FsmFlush fun(deltaTime:number, next:Waypoint, previous:Waypoint)\n---@field SetState fun(newState:FlightState)\n---@field SetEngineWarmupTime fun(t50:number)\n---@field CheckPathAlignment fun(currentPos:Vec3, nearestPointOnPath:Vec3, previousWaypoint:Waypoint, nextWaypoint:Waypoint)\n---@field SetTemporaryWaypoint fun(wpNext:Waypoint|nil)\n---@field Update fun()\n---@field AtWaypoint fun(isLastWaypoint:boolean, next:Waypoint, previous:Waypoint)\n---@field GetSettings fun():Settings\n---@field GetRouteController fun():RouteController\n---@field SetFlightCore fun(fc:FlightCore)\n---@field GetFlightCore fun():FlightCore\n---@field DisablesAllThrust fun():boolean\n---@field PreventNextWp fun():boolean\n---@field SelectWP fun(orgNext:Waypoint):Waypoint, boolean\n---@field ToggleBoster fun()\n---@field SetBooster fun(activate:boolean)\n\nlocal FlightFSM           = {}\nFlightFSM.__index         = FlightFSM\n\n---Creates a new FligtFSM\n---@param settings Settings\n---@param routeController RouteController\n--- @param geo GeoFence\n---@return FlightFSM\nfunction FlightFSM.New(settings, routeController, geo)\n    local minimumPathCheckOffset = settings.Number(\"minimumPathCheckOffset\")\n    settings.Callback(\"minimumPathCheckOffset\", function(number)\n        minimumPathCheckOffset = number\n    end)\n\n    local globalMaxSpeed = calc.Kph2Mps(settings.Number(\"globalMaxSpeed\"))\n    settings.Callback(\"globalMaxSpeed\", function(gMax)\n        globalMaxSpeed = calc.Kph2Mps(gMax)\n    end)\n\n    settings.Callback(\"pathAlignmentAngleLimit\", Waypoint.SetAlignmentAngleLimit)\n    settings.Callback(\"pathAlignmentDistanceLimit\", Waypoint.SetAlignmentDistanceLimit)\n    settings.Callback(\"pitchAlignmentThrustLimiter\", Waypoint.SetPitchAlignmentThrustLimiter)\n    settings.Callback(\"autoPitch\", Waypoint.SetAutoPitch)\n    settings.Callback(\"autoBrakeAngle\", brakes.SetAutoBrakeAngle)\n    settings.Callback(\"autoBrakeDelay\", brakes.SetAutoBrakeDelay)\n\n    local warmupTime                  = 1\n    local lastReadMass                = TotalMass()\n    local axisMgr                     = AxisManager.Instance()\n    local yaw                         = axisMgr.Yaw()\n    local roll                        = axisMgr.Roll()\n    local pitch                       = axisMgr.Pitch()\n    local yawAlignmentThrustLimiter   = 1\n    local rollAlignmentThrustLimiter  = 1\n    local pitchAlignmentThrustLimiter = 1\n    local boosterActive               = false\n    local boosterStateChanged         = false\n    local isFrozen                    = false\n\n    local longAdjData                 = AdjustmentTracker.New(lastReadMass < LightConstructMassThreshold)\n    local latAdjData                  = AdjustmentTracker.New(lastReadMass < LightConstructMassThreshold)\n    local vertAdjData                 = AdjustmentTracker.New(lastReadMass < LightConstructMassThreshold)\n\n    ---@type FlightData\n    local flightData                  = {\n        targetSpeed = 0,\n        targetSpeedReason = \"\",\n        finalSpeed = 0,\n        finalSpeedDistance = 0,\n        distanceToAtmo = -1,\n        atmoDistance = 0,\n        brakeMaxSpeed = 0,\n        waypointDist = 0,\n        speedDiff = 0,\n        pid = 0,\n        fsmState = \"No state\",\n        acceleration = 0,\n        controlAcc = 0,\n        absSpeed = 0\n    }\n\n    local adjustData                  = {\n        long = 0,\n        lat = 0,\n        ver = 0\n    }\n\n\n    local currentState ---@type FlightState\n    local temporaryWaypoint ---@type Waypoint|nil\n    local pidValues = yfsConstants.flight.speedPid\n    local speedPid = PID(pidValues.p, pidValues.i, pidValues.d, pidValues.a)\n\n    local s = {}\n\n    ---@param active boolean\n    function s.SetBooster(active)\n        if active ~= boosterActive then\n            boosterActive = active\n            boosterStateChanged = true\n            log.Info(\"Boosters \", boosterActive and \"activated\" or \"deactivated\")\n        end\n    end\n\n    ---Selects the waypoint to go to\n    ---@param orgNext Waypoint\n    ---@return Waypoint\n    ---@return boolean\n    function s.SelectWP(orgNext)\n        if temporaryWaypoint then\n            return temporaryWaypoint, true\n        end\n\n        return orgNext, false\n    end\n\n    ---Calculates the width of the dead zone\n    ---@param body Body\n    local function deadZoneThickness(body)\n        local atmo = body.Atmosphere\n        local thickness = atmo.Present and (atmo.Thickness * (1 - deadZoneFactor)) or 0\n        return thickness\n    end\n\n    ---Indicates if the coordinate is within the atmospheric dead zone of the body\n    ---@param coordinate Vec3\n    ---@param body Body\n    ---@return boolean\n    local function isWithinDeadZone(coordinate, body)\n        if not body.Atmosphere.Present then return false end\n\n        -- If the point is within the atmospheric radius and outside the inner radius, then it is within the dead zone.\n        local outerBorder = body.Atmosphere.Radius\n        local innerBorder = outerBorder - deadZoneThickness(body)\n        local distanceToCenter = (coordinate - body.Geography.Center):Len()\n\n        return distanceToCenter < outerBorder and distanceToCenter >= innerBorder\n    end\n\n    ---Determines if the construct will enter atmo if continuing on the current path\n    ---If already in atmo it returns false\n    ---@param waypoint Waypoint\n    ---@param body Body\n    ---@return boolean, Vec3, number\n    local function willEnterAtmo(waypoint, body)\n        local pos = Current()\n        local center = body.Geography.Center\n        local intersects, point, dist = calc.LineIntersectSphere(Ray.New(pos, waypoint.DirectionTo()), center,\n            body.Atmosphere.Radius)\n        intersects = intersects and not body:IsInAtmo(pos)\n        return intersects, point, dist\n    end\n\n    ---Evaluates the new speed limit and sets that, if lower than the current one\n    ---@param currentLimit number Current speed limit\n    ---@param newLimit number New speed limit\n    ---@param reason string Text to display in the widget\n    ---@return number\n    local function evaluateNewLimit(currentLimit, newLimit, reason)\n        if newLimit >= 0 and newLimit < currentLimit then\n            flightData.targetSpeed = newLimit\n            flightData.targetSpeedReason = reason\n            return newLimit\n        end\n\n        return currentLimit\n    end\n\n    ---@param remainingDistance number Remaining distance\n    local function linearSpeed(remainingDistance)\n        -- 1000m -> 1000km/h, 500m -> 500km/h etc.\n        local speed = calc.Kph2Mps(remainingDistance)\n\n        if remainingDistance < 2 then\n            speed = speed * 2\n        end\n\n        return speed\n    end\n\n    ---Adjust the speed to be linear based on the remaining distance\n    ---@param currentTargetSpeed number Current target speed\n    ---@param remainingDistance number Remaining distance\n    ---@return number Speed\n    local function linearApproach(currentTargetSpeed, remainingDistance)\n        local startDist\n        local stopDist\n\n        if IsInAtmo() then\n            if lastReadMass > LightConstructMassThreshold then\n                startDist = 20\n                stopDist = 0.3\n            else\n                startDist = 0.5\n                stopDist = 0\n            end\n        else\n            startDist = 20\n            stopDist = 0.0 -- This used to be 0.5, but that caused problems holding position.\n        end\n\n        if remainingDistance > startDist\n            or remainingDistance <= stopDist then -- To not make it painfully slow in reaching the final position we let it go when it is this close from the target\n            return currentTargetSpeed\n        end\n\n        return evaluateNewLimit(currentTargetSpeed, linearSpeed(remainingDistance), \"Approaching\")\n    end\n\n\n    ---@param waypoint Waypoint\n    ---@return boolean\n    local function outsideAdjustmentMargin(waypoint)\n        local margin = waypoint.Margin()\n        return longAdjData.LastDistance() > margin\n            or latAdjData.LastDistance() > margin\n            or vertAdjData.LastDistance() > margin\n    end\n\n    local function burnSpeed()\n        return construct.getFrictionBurnSpeed() * 0.98\n    end\n\n    ---Gets the maximum speed we may have and still be able to stop\n    ---@param deltaTime number Time since last tick, seconds\n    ---@param velocity Vec3 Current velocity\n    ---@param waypoint Waypoint Current waypoint\n    ---@param previousWaypoint Waypoint Previous waypoint\n    ---@return number\n    local function getSpeedLimit(deltaTime, velocity, waypoint, previousWaypoint)\n        local currentSpeed = velocity:Len()\n        -- Look ahead at how much there is left at the next tick. If we're decelerating, don't allow values less than 0\n        -- This is inaccurate if acceleration isn't in the same direction as our movement vector, but it is gives a safe value.\n        local remainingDistance = max(0,\n            waypoint.DistanceTo() - (currentSpeed * deltaTime + 0.5 * Acceleration():Len() * deltaTime * deltaTime))\n\n        -- Calculate max speed we may have with available brake force to to reach the final speed.\n        local pos = Current()\n        local firstBody = universe.CurrentGalaxy():BodiesInPath(Ray.New(pos, velocity:Normalize()))[1]\n        local inAtmo = false\n        local willLeaveAtmo = false\n        local atmoDensity = AtmoDensity()\n\n        flightData.finalSpeed = waypoint.FinalSpeed()\n        flightData.finalSpeedDistance = remainingDistance\n\n        local willHitAtmo = false\n        local distanceToAtmo = -1\n\n        local targetSpeed = evaluateNewLimit(MAX_INT, construct.getMaxSpeed(), \"Construct max\")\n\n        if firstBody then\n            willHitAtmo, _, distanceToAtmo = willEnterAtmo(waypoint, firstBody)\n            inAtmo = firstBody:IsInAtmo(pos)\n            willLeaveAtmo = inAtmo and not firstBody:IsInAtmo(waypoint.Destination())\n            flightData.distanceToAtmo = distanceToAtmo\n        end\n\n        if waypoint.MaxSpeed() > 0 then\n            targetSpeed = evaluateNewLimit(targetSpeed, waypoint.MaxSpeed(), \"Route\")\n        end\n\n        --- Don't allow us to burn\n        if atmoDensity > 0 then\n            targetSpeed = evaluateNewLimit(targetSpeed, burnSpeed(), \"Burn speed\")\n        end\n\n        local inDeadZone = firstBody and isWithinDeadZone(pos, firstBody)\n        local fallingInDeadZone = inDeadZone and waypoint.DirectionTo():Dot(GravityDirection()) > 0.7\n        if fallingInDeadZone then\n            remainingDistance = max(remainingDistance, remainingDistance - deadZoneThickness(firstBody))\n        end\n\n        -- Ensure slowdown before we hit atmo and assume we're going to fall through the dead zone.\n        local atmosphericEntrySpeed = burnSpeed()\n        if willHitAtmo then\n            flightData.finalSpeed = atmosphericEntrySpeed\n            flightData.finalSpeedDistance = distanceToAtmo\n\n            -- Are actually intending to enter atmo?\n            if distanceToAtmo <= waypoint.DistanceTo() then\n                local entrySpeed = brakes.CalcMaxAllowedSpeed(distanceToAtmo, atmosphericEntrySpeed)\n                targetSpeed = evaluateNewLimit(targetSpeed, entrySpeed, \"Atmo entry\")\n            end\n        elseif fallingInDeadZone then\n            targetSpeed = evaluateNewLimit(targetSpeed, atmosphericEntrySpeed, \"Dead Zone\")\n        end\n\n        -- Ensure that we have a speed at which we can come to a stop with 10% of the brake force when we hit 360km/h, which is the speed at which brakes start to degrade down to 10% at 36km/h.\n        if inAtmo and not willLeaveAtmo and waypoint.FinalSpeed() <= brakeDegradeSpeed then\n            local tenPercent = brakes.MaxSeenGravityInfluencedAvailableAtmoDeceleration() * 0.1\n            if tenPercent > 0 then\n                local endSpeed = waypoint.FinalSpeed()\n\n                local finalApproachDistance = calc.CalcBrakeDistance(brakeDegradeSpeed, tenPercent)\n                local toBrakePoint = remainingDistance - finalApproachDistance\n\n                if toBrakePoint > 0 then\n                    -- Not yet reached the break point\n                    targetSpeed = evaluateNewLimit(targetSpeed,\n                        brakes.CalcMaxAllowedSpeed(toBrakePoint, brakeDegradeSpeed, -tenPercent), \"Appr. fin.\")\n                    flightData.finalSpeed = brakeDegradeSpeed\n                    flightData.finalSpeedDistance = toBrakePoint\n                else\n                    -- Within\n                    targetSpeed = evaluateNewLimit(targetSpeed,\n                        brakes.CalcMaxAllowedSpeed(remainingDistance, endSpeed, -tenPercent), \"Final atmo\")\n                end\n            end\n        end\n\n        if inAtmo and abs(brakes.EffectiveBrakeDeceleration()) <= G() then\n            -- Brakes have become so inefficient at the current altitude or speed they are useless, use linear speed\n            -- This state can be seen when entering atmo for example.\n            targetSpeed = evaluateNewLimit(targetSpeed, linearSpeed(remainingDistance), \"Brake/ineff\")\n            -- Does final speed override?\n            local finalSpeed = waypoint.FinalSpeed()\n            if targetSpeed < finalSpeed and finalSpeed > 0 then\n                targetSpeed = evaluateNewLimit(finalSpeed + 1, finalSpeed, \"Final spd\")\n            end\n        elseif inAtmo and willLeaveAtmo then\n            -- No need to further reduce\n        else\n            local brakeMaxSpeed = brakes.CalcMaxAllowedSpeed(remainingDistance, waypoint.FinalSpeed())\n            targetSpeed = evaluateNewLimit(targetSpeed, brakeMaxSpeed, \"Brake\")\n            flightData.brakeMaxSpeed = brakeMaxSpeed\n        end\n\n        if not inAtmo then\n            -- Braking in space\n            -- Space engines take a while to turn off so if we'd reach the end point within that time, adjust speed\n            -- so we brake earlier, but only if we're coming to a stop (finalSpeed == 0)\n            if currentSpeed > 0 and waypoint.FinalSpeed() == 0 then\n                local timeToStarget = remainingDistance / currentSpeed\n                -- These 10 seconds are totally arbitrary, but seems safe enough.\n                if timeToStarget <= 10 then\n                    targetSpeed = evaluateNewLimit(targetSpeed, targetSpeed * 0.5, \"Brake/red\")\n                end\n            end\n        end\n\n        flightData.waypointDist = remainingDistance\n\n        if waypoint.FinalSpeed() == 0 then\n            targetSpeed = linearApproach(targetSpeed, remainingDistance)\n\n            local dirBetweenWP = (waypoint.Destination() - previousWaypoint.Destination()):Normalize()\n            local ver = universe.VerticalReferenceVector()\n            -- Both up up and down\n            local approachingVertically = dirBetweenWP:AngleToDeg(ver) < 5 or\n                dirBetweenWP:AngleToDeg(-ver) < 5\n\n            -- When approching the final parking position vertically, move extra slow so that there is enough time to adjust sideways.\n            if waypoint.IsLastInRoute()\n                and outsideAdjustmentMargin(waypoint)\n                and approachingVertically -- within this angle\n                and remainingDistance < 400 then\n                targetSpeed = evaluateNewLimit(targetSpeed, targetSpeed * 0.5, \"Adj. apr.\")\n            end\n        end\n\n        if globalMaxSpeed > 0 then\n            targetSpeed = evaluateNewLimit(targetSpeed, globalMaxSpeed, \"Global max\")\n        end\n\n        if geo.Limited(waypoint.DirectionTo()) then\n            targetSpeed = evaluateNewLimit(targetSpeed, 0, \"Geofence\")\n        end\n\n        return targetSpeed\n    end\n\n    ---@param axis Vec3\n    ---@param currentPos Vec3\n    ---@param nextWaypoint Waypoint\n    ---@param previousWaypoint Waypoint\n    ---@param t number Time interval in seconds\n    ---@return Vec3 direction\n    ---@return number length\n    local function getAdjustmentDataInFuture(axis, currentPos, nextWaypoint, previousWaypoint, t)\n        -- Don't make adjustments in the travel direction.\n        if abs(axis:Dot(nextWaypoint:DirectionTo())) < adjustmentThreshold then\n            local posInFuture = currentPos + Velocity() * t + 0.5 * Acceleration() * t * t\n            local targetFuture = calc.NearestOnLineBetweenPoints(previousWaypoint.Destination(),\n                nextWaypoint.Destination(),\n                posInFuture)\n            local toTargetFuture = (targetFuture - posInFuture):ProjectOn(axis)\n            return toTargetFuture:NormalizeLen()\n        else\n            return Vec3.zero, 0\n        end\n    end\n\n    ---@param axis Vec3\n    ---@param currentPos Vec3\n    ---@param data AdjustmentTracker\n    ---@param nextWaypoint Waypoint\n    ---@param previousWaypoint Waypoint\n    ---@return Vec3 acceleration\n    ---@return number distance\n    ---@return integer Sign Positive if we need to move in the axis direction\n    local function calcAdjustAcceleration(axis, data, currentPos, nextWaypoint, previousWaypoint)\n        local directionNow, distanceNow = getAdjustmentDataInFuture(axis, currentPos, nextWaypoint, previousWaypoint, 0)\n        local directionFuture, distanceFuture = getAdjustmentDataInFuture(axis, currentPos, nextWaypoint,\n            previousWaypoint, 4)\n\n        local acc = Vec3.zero\n\n        if directionNow:Dot(directionFuture) < 0 then\n            -- Will have passed the path, break if we'll be outside the margin;\n            -- we check this so that we don't prevent ourselves from moving sideways etc.\n            if distanceFuture > DefaultMargin\n                and lastReadMass > LightConstructMassThreshold -- Don't do the braking on light constructs, it causes jitter.\n            then\n                acc = directionFuture * calc.CalcBrakeAcceleration(Velocity():Dot(axis), distanceNow)\n            end\n        else\n            local mul = Clamp(data.Feed(distanceNow), 0, 1)\n            acc = directionNow * mul * engine.GetAvailableThrust(false, directionNow)\n        end\n\n        return acc, distanceNow, Sign(directionNow:Dot(axis))\n    end\n\n    ---Adjust for deviation from the desired path\n    ---@param currentPos Vec3\n    ---@param nextWaypoint Waypoint\n    ---@param previousWaypoint Waypoint\n    ---@return Vec3\n    local function adjustForDeviation(currentPos, nextWaypoint, previousWaypoint)\n        local vertAcc, vertDist, vertDistSign = calcAdjustAcceleration(Up(), vertAdjData, currentPos, nextWaypoint,\n            previousWaypoint)\n        local latAcc, latDist, latDistSign = calcAdjustAcceleration(Right(), latAdjData, currentPos, nextWaypoint,\n            previousWaypoint)\n        local longAcc, longDist, longDistSign = calcAdjustAcceleration(Forward(), longAdjData, currentPos, nextWaypoint,\n            previousWaypoint)\n\n        adjustData.lat = latDist * latDistSign\n        adjustData.long = longDist * longDistSign\n        adjustData.ver = vertDist * vertDistSign\n\n        return vertAcc + latAcc + longAcc\n    end\n\n    ---Applies the acceleration to the engines\n    ---@param acceleration Vec3|nil\n    ---@param adjustmentAcc Vec3\n    local function applyAcceleration(acceleration, adjustmentAcc)\n        if acceleration == nil then\n            SetEngineCommand(\"thrust\", { 0, 0, 0 }, { 0, 0, 0 }, true, true, \"\", \"\", \"\", 1)\n            return\n        end\n\n        -- Counter gravity pull and air friction\n        local acc = adjustmentAcc - universe:VerticalReferenceVector() * G() - AirFrictionAcc()\n\n        if abs(yaw.OffsetDegrees()) < yawAlignmentThrustLimiter\n            and abs(pitch.OffsetDegrees()) < pitchAlignmentThrustLimiter\n            and abs(roll.OffsetDegrees()) < rollAlignmentThrustLimiter then\n            acc = acc + acceleration * input.Throttle() -- throttle also affects brake acceleration using engines\n        end\n\n        -- Make sure that engine tags only include the absolute minimum number of engines as it\n        -- is the first command to the engine that takes effect, not the last one. For example,\n        -- lateral engines must be adressed with 'lateran AND analog' or a lateral rocket engine\n        -- also gets the command.\n\n        -- You can mix space (AND) and comma (OR), AND groups will be evaluated first so you can do\n        -- \"A B, C D\", meaning (A and B) or (C and D)\n\n        -- Vertical AND analog.\n        SetEngineCommand(\"vertical analog\", { acc:ProjectOn(Up()):Unpack() }, { 0, 0, 0 }, true, true, \"airfoil\",\n            \"ground\", \"analog\", 0.1)\n\n        -- longitudinal AND analog\n        SetEngineCommand(\"longitudinal analog\", { acc:ProjectOn(Forward()):Unpack() }, { 0, 0, 0 }, true, true, \"\",\n            \"\", \"\", 0.1)\n\n        -- When in manual mode we want to counter lateral drift by the same amount of force as air friction.\n        -- Note the two-multiplier to counter it already being subtracted above\n        local driftComp = AirFrictionAcc():ProjectOn(Right()) * ((isFrozen and IsInAtmo()) and 2 or 0)\n\n        -- Lateral AND analog\n        SetEngineCommand(\"lateral analog\", { (acc:ProjectOn(Right()) + driftComp):Unpack() }, { 0, 0, 0 }, true,\n            true, \"\", \"\", \"\", 0.1)\n\n        if boosterStateChanged then\n            boosterStateChanged = false\n            SetEngineThrust(\"rocket_engine\", boosterActive and 1 or 0)\n        end\n    end\n\n    ---@param deltaTime number The time since last Flush\n    ---@param waypoint Waypoint The next waypoint\n    ---@param previousWaypoint Waypoint The next waypoint\n    ---@return Vec3 #The acceleration\n    ---@return number #The speed limit\n    local function move(deltaTime, waypoint, previousWaypoint)\n        local direction = waypoint.DirectionTo()\n        local velocity = Velocity()\n        local currentSpeed = velocity:Len()\n\n        local speedLimit = getSpeedLimit(deltaTime, velocity, waypoint, previousWaypoint)\n\n        local diff = speedLimit - currentSpeed\n        flightData.speedDiff = diff\n\n        -- Only feed speed pid when not going fast enough to avoid accelerating when speed is too high\n        if diff >= 0 then\n            -- Feed the pid with 1/100:th to give it a wider working range.\n            speedPid:inject(diff / 100)\n        else\n            speedPid:reset()\n        end\n\n        -- Don't let the pid value go outside 0 ... 1 - that would cause the calculated thrust to get\n        -- skewed outside its intended values and push us off the path, or make us fall when holding position (if pid gets <0)\n        local pidValue = Clamp(speedPid:get(), 0, 1)\n\n        flightData.pid = pidValue\n\n        local acceleration\n        if waypoint.DistanceTo() <= DefaultMargin then\n            -- At this point we let the adjustment code control\n            acceleration = Vec3.zero\n        else\n            acceleration = direction * pidValue * engine.GetAvailableThrust(not isFrozen, direction)\n        end\n\n        flightData.controlAcc = acceleration:Len()\n        return acceleration, speedLimit\n    end\n\n    ---Flush method for the FSM\n    ---@param deltaTime number\n    ---@param next Waypoint\n    ---@param previous Waypoint\n    function s.FsmFlush(deltaTime, next, previous)\n        if currentState.DisablesAllThrust() then\n            applyAcceleration(nil, nullVec)\n            brakes.Feed(nullVec, nullVec, 0)\n        else\n            local pos = Current()\n            local nearest = calc.NearestOnLineBetweenPoints(previous.Destination(), next.Destination(), pos)\n\n            currentState.Flush(deltaTime, next, previous, nearest)\n\n            if brakes.Active() then\n                s.SetBooster(false)\n            end\n\n            local acceleration, speedLimit = move(deltaTime, next, previous)\n            local adjustmentAcc = adjustForDeviation(pos, next, previous)\n\n            -- Feed the break the acceleration vector only, not including the adjustments - we might not be accelerating at all but still adjusting for gravity pull.\n            brakes.Feed(next.DirectionTo(), acceleration:Normalize(), speedLimit)\n\n            applyAcceleration(acceleration, adjustmentAcc)\n        end\n    end\n\n    ---Sets a new state\n    ---@param state FlightState\n    function s.SetState(state)\n        if currentState ~= nil then\n            currentState.Leave()\n        end\n\n        if state == nil then\n            flightData.fsmState = \"No state\"\n            return\n        else\n            flightData.fsmState = state:Name()\n            state.Enter()\n        end\n\n        currentState = state\n    end\n\n    ---Sets the engine warmup time\n    ---@param time number\n    function s.SetEngineWarmupTime(time)\n        warmupTime = time * 2 -- Warmup time is to T50, so double it for full engine effect\n    end\n\n    ---Checks if we're still on the path\n    ---@param currentPos Vec3\n    ---@param nearestPointOnPath Vec3\n    ---@param previousWaypoint Waypoint\n    ---@param nextWaypoint Waypoint\n    ---@return boolean\n    function s.CheckPathAlignment(currentPos, nearestPointOnPath, previousWaypoint, nextWaypoint)\n        --[[ As waypoints can have large margins, we need to ensure that we allow for offsets as large as the margins, at each end.\n            The outer edges are a straight line between the edges of the start and end point spheres so allowed offset can be calculated linearly.\n        ]]\n        local startPos = previousWaypoint.Destination()\n        local startMargin = previousWaypoint.Margin()\n        local endPos = nextWaypoint.Destination()\n        local endMargin = nextWaypoint.Margin()\n\n        local dist = (endPos - startPos):Len()\n        local diff = endMargin - startMargin\n        local koeff = 0\n        if dist ~= 0 then\n            koeff = diff / dist\n        end\n\n        local travelDist = min(dist, (startPos - Current()):Len())\n        local allowedOffset = startMargin + koeff * travelDist\n        local toNearest = (nearestPointOnPath - currentPos):Len()\n\n        return toNearest <= max(minimumPathCheckOffset, allowedOffset)\n    end\n\n    ---Sets a temporary waypoint, or removes the current one\n    ---@param wp Waypoint|nil\n    function s.SetTemporaryWaypoint(wp)\n        temporaryWaypoint = wp\n    end\n\n    function s.Update()\n        if currentState ~= nil then\n            flightData.acceleration = Acceleration():Len()\n            flightData.absSpeed = Velocity():Len()\n            currentState.Update()\n            pub.Publish(\"FlightData\", flightData)\n            pub.Publish(\"AdjustmentData\", adjustData)\n        end\n        lastReadMass = TotalMass()\n        isFrozen = IsFrozen()\n    end\n\n    function s.AtWaypoint(isLastWaypoint, next, previous)\n        if currentState ~= nil then\n            currentState.AtWaypoint(isLastWaypoint, next, previous)\n        end\n    end\n\n    settings.Callback(\"engineWarmup\", function(value)\n        s.SetEngineWarmupTime(value)\n    end)\n\n    settings.Callback(\"speedp\", function(value)\n        speedPid = PID(value, speedPid.i, speedPid.d, speedPid.amortization)\n    end)\n\n    settings.Callback(\"speedi\", function(value)\n        speedPid = PID(speedPid.p, value, speedPid.d, speedPid.amortization)\n    end)\n\n    settings.Callback(\"speedd\", function(value)\n        speedPid = PID(speedPid.p, speedPid.i, value, speedPid.amortization)\n    end)\n\n    settings.Callback(\"speeda\", function(value)\n        speedPid = PID(speedPid.p, speedPid.i, speedPid.d, value)\n    end)\n\n    settings.Callback(\"yawAlignmentThrustLimiter\", function(value)\n        yawAlignmentThrustLimiter = value\n    end)\n\n    settings.Callback(\"pitchAlignmentThrustLimiter\", function(value)\n        pitchAlignmentThrustLimiter = value\n    end)\n\n    settings.Callback(\"rollAlignmentThrustLimiter\", function(value)\n        rollAlignmentThrustLimiter = value\n    end)\n\n    ---@return Settings\n    function s.GetSettings()\n        return settings\n    end\n\n    ---@return RouteController\n    function s.GetRouteController()\n        return routeController\n    end\n\n    local fc ---@type FlightCore\n\n    function s.SetFlightCore(core)\n        fc = core\n    end\n\n    function s.GetFlightCore()\n        return fc\n    end\n\n    function s.DisablesAllThrust()\n        return currentState and currentState.DisablesAllThrust() or false\n    end\n\n    function s.PreventNextWp()\n        return currentState and currentState.PreventNextWp() or false\n    end\n\n    s.SetState(Idle.New(s))\n\n    return setmetatable(s, FlightFSM)\nend\n\nreturn FlightFSM\n\nend)\npackage.preload['YFS:flight/FlightCore.lua']=(function()\nrequire('YFS:../e/lib/src/abstraction/Vehicle.lua')\nrequire('YFS:GlobalTypes.lua')\nlocal s                                                               = require('YFS:Singletons.lua')\nlocal log, gateControl, pub, universe, calc, constants, brakes, floor = s.log, s.gateCtrl, s.pub, s.universe, s.calc,\n    s.constants, s.brakes, s.floorDetector\nlocal VertRef                                                         = s.universe.VerticalReferenceVector\n\nlocal AxisManager, Ternary, plane, abs, delta                         = require('YFS:flight/AxisManager.lua'), calc.Ternary,\n    Plane.NewByVertialReference(), math.abs, Stopwatch.New()\n\nrequire('YFS:flight/state/Require.lua')\n\n---@module \"flight/route/RouteController\"\n\n---@class FlightCore\n---@field ReceiveEvents fun()\n---@field GetRouteController fun():RouteController\n---@field NextWP fun()\n---@field StartFlight fun()\n---@field Turn fun(degrees:number, axis:Vec3):Vec3\n---@field AlignTo fun(point:Vec3)\n---@field StopEvents fun()\n---@field CreateWPFromPoint fun(p:Point, lastInRoute:boolean, pathAlignmentDistanceLimitFromSurface:number):Waypoint\n---@field GoIdle fun()\n---@field GotoTarget fun(target:Vec3, lockdir:Vec3, margin:number, maxSpeed:number, finalSpeed:number, ignoreLastInRoute:boolean, forceVerticalUp:boolean, routeName:string|nil)\n---@field WaitForGate fun():boolean\n---@field StartParking fun(distance:number, routeName:string)\n\nlocal FlightCore = {}\nFlightCore.__index = FlightCore\nlocal singleton\n\nlocal defaultFinalSpeed = 0\nlocal defaultMargin = constants.flight.defaultMargin\n\n---Creates a waypoint from a point\n---@param point Point\n---@param lastInRoute boolean\n---@param pathAlignmentDistanceLimitFromSurface number\n---@return Waypoint\nfunction FlightCore.CreateWPFromPoint(point, lastInRoute, pathAlignmentDistanceLimitFromSurface)\n    local opt = point.Options()\n    local lockDir = Vec3.New(opt.Get(PointOptions.LOCK_DIRECTION, Vec3.zero))\n    local margin = opt.Get(PointOptions.MARGIN, defaultMargin)\n    local finalSpeed\n    if opt.Get(PointOptions.FORCE_FINAL_SPEED) then\n        finalSpeed = opt.Get(PointOptions.FINAL_SPEED, defaultFinalSpeed)\n    else\n        finalSpeed = Ternary(lastInRoute, 0, opt.Get(PointOptions.FINAL_SPEED, defaultFinalSpeed))\n    end\n    local maxSpeed = opt.Get(PointOptions.MAX_SPEED, 0) -- 0 = ignored/max speed.\n\n    local coordinate = universe.ParsePosition(point.Pos()).Coordinates()\n\n    local wp = Waypoint.New(coordinate, finalSpeed, maxSpeed, margin, pathAlignmentDistanceLimitFromSurface)\n    wp.SetLastInRoute(lastInRoute)\n\n    if lockDir ~= Vec3.zero then\n        wp.LockYawTo(lockDir, true)\n    end\n\n    if opt.Get(PointOptions.FORCE_VERT, false) then\n        wp.ForceUpAlongVerticalRef()\n    end\n\n    return wp\nend\n\n---Creates a new FlightCore\n---@param routeController RouteController\n---@param flightFSM FlightFSM\n---@return FlightCore\nfunction FlightCore.New(routeController, flightFSM)\n    local s = {}\n\n    local flushHandlerId = 0\n    local updateHandlerId = 0\n    local axes = AxisManager.Instance()\n    local settings = flightFSM.GetSettings()\n\n    local routePublishTimer = Stopwatch.New()\n\n    local function createDefaultWP()\n        return Waypoint.New(Current(), 0, 0, defaultMargin, 0)\n    end\n\n    -- Setup start waypoints to prevent nil values\n    local currentWaypoint = createDefaultWP() -- The positions we want to move to\n    local previousWaypoint = currentWaypoint  -- Previous waypoint\n    local route = nil ---@type Route|nil\n\n    ---Gets the route controller\n    ---@return RouteController\n    function s.GetRouteController()\n        return routeController\n    end\n\n    ---Selects the next waypoint\n    function s.NextWP()\n        if route == nil then\n            return\n        end\n\n        local nextPoint = route.Next()\n        if nextPoint == nil then\n            return\n        end\n\n        previousWaypoint = currentWaypoint\n        currentWaypoint = FlightCore.CreateWPFromPoint(nextPoint, route.LastPointReached(),\n            settings.Number(\"pathAlignmentDistanceLimitFromSurface\"))\n\n        -- When the next waypoint is nearly above or below us, lock yaw\n        local dir = (currentWaypoint.Destination() - previousWaypoint.Destination()):NormalizeInPlace()\n        if abs(dir:Dot(plane.Up())) > 0.9 then\n            currentWaypoint.LockYawTo(plane.Forward(), false)\n        end\n    end\n\n    function s.WaitForGate()\n        return route and gateControl.Enabled() and route.WaitForGate(Current(), settings.Number(\"gateControlDistance\"))\n    end\n\n    ---@param distance number\n    ---@param routeName string\n    function s.StartParking(distance, routeName)\n        if not floor.Present() then\n            log.Error(\"No floor detector present\")\n            return\n        end\n\n        gateControl.Enable(true)\n        local target = Current() + VertRef() * distance\n        pub.Publish(\"ResetWSAD\", true)\n        s.GotoTarget(target, plane.Forward(), 1, calc.Kph2Mps(settings.Number(\"parkMaxSpeed\")), 0, false, true, routeName)\n        routeController.CurrentRoute().AddTag(\"RegularParkingTag\")\n    end\n\n    ---Starts the flight\n    function s.StartFlight()\n        route = routeController.CurrentRoute()\n        if not route then\n            log.Error(\"Can't start a flight without a route\")\n            return\n        end\n\n        routePublishTimer.Start()\n\n        -- Setup waypoint that will be the previous waypoint\n        currentWaypoint = createDefaultWP()\n        s.NextWP()\n\n        if s.WaitForGate() then\n            flightFSM.SetState(OpenGates.New(flightFSM, Current(), plane.Forward()))\n        else\n            flightFSM.SetState(Travel.New(flightFSM))\n        end\n    end\n\n    function s.GoIdle()\n        flightFSM.SetState(Idle.New(flightFSM))\n    end\n\n    ---Rotates current waypoint with the given angle\n    ---@param degrees number The angle to turn\n    ---@param axis Vec3\n    ---@return Vec3 # The alignment direction\n    function s.Turn(degrees, axis)\n        local current = Current()\n        local forwardPointOnPlane = calc.ProjectPointOnPlane(axis, current,\n            current + Forward() * Waypoint.DirectionMargin)\n        forwardPointOnPlane = calc.RotateAroundAxis(forwardPointOnPlane, current, degrees, axis)\n        local dir = (forwardPointOnPlane - Current()):NormalizeInPlace()\n        currentWaypoint.LockYawTo(dir, true)\n        pub.Publish(\"ForwardDirectionChanged\", dir)\n        return dir\n    end\n\n    ---Aligns to the point\n    ---@param point Vec3\n    function s.AlignTo(point)\n        if currentWaypoint then\n            local current = Current()\n            local pointOnPlane = calc.ProjectPointOnPlane(-universe.VerticalReferenceVector(), current, point)\n            local dir = (pointOnPlane - current):NormalizeInPlace()\n            ---QQQ Just (point - curr):NormalizeInPlace() ???\n            currentWaypoint.LockYawTo(dir, true)\n            pub.Publish(\"ForwardDirectionChanged\", dir)\n        end\n    end\n\n    ---Hooks up the events needed for flight\n    function s.ReceiveEvents()\n        ---@diagnostic disable-next-line: undefined-field\n        flushHandlerId = system:onEvent(\"onFlush\", s.fcFlush)\n        ---@diagnostic disable-next-line: undefined-field\n        updateHandlerId = system:onEvent(\"onUpdate\", s.fcUpdate)\n        axes.ReceiveEvents()\n    end\n\n    ---Disconnects events\n    function s.StopEvents()\n        ---@diagnostic disable-next-line: undefined-field\n        system:clearEvent(\"flush\", flushHandlerId)\n        ---@diagnostic disable-next-line: undefined-field\n        system:clearEvent(\"update\", updateHandlerId)\n        axes.StopEvents()\n    end\n\n    ---Starts a movement towards the given coordinate.\n    ---@param target Vec3\n    ---@param lockDir Vec3 If not zero, direction is locked to this direction\n    ---@param margin number meter\n    ---@param maxSpeed number m/s\n    ---@param finalSpeed number m/s\n    ---@param forceFinalSpeed boolean If true, the construct will not slow down to come to a stop if the point is last in the route (used for manual control)\n    ---@param forceVerticalUp boolean If true, forces up to align to vertical up\n    ---@param routeName string|nil Name of route\n    function s.GotoTarget(target, lockDir, margin, maxSpeed, finalSpeed, forceFinalSpeed, forceVerticalUp, routeName)\n        local temp = routeController.ActivateTempRoute(routeName)\n        local targetPoint = temp.AddCoordinate(target)\n        local opt = targetPoint.Options()\n        opt.Set(PointOptions.MAX_SPEED, maxSpeed)\n        opt.Set(PointOptions.MARGIN, margin)\n        opt.Set(PointOptions.FINAL_SPEED, finalSpeed)\n        opt.Set(PointOptions.FORCE_FINAL_SPEED, forceFinalSpeed)\n        opt.Set(PointOptions.FORCE_VERT, forceVerticalUp)\n\n        if not lockDir:IsZero() then\n            opt.Set(PointOptions.LOCK_DIRECTION, { lockDir:Unpack() })\n        end\n\n        s.StartFlight()\n    end\n\n    function s.fcUpdate()\n        local status, err, _ = xpcall(\n            function()\n                flightFSM.Update()\n                brakes.BrakeUpdate()\n\n                if route and routePublishTimer.Elapsed() > 0.5 then\n                    routePublishTimer.Restart()\n                    pub.Publish(\"RouteData\", {\n                        remaining = route.GetRemaining(Current()),\n                        activeRouteName = routeController.ActiveRouteName()\n                    })\n                end\n\n                if currentWaypoint ~= nil then\n                    pub.Publish(\"WaypointData\", currentWaypoint)\n\n                    if settings.Boolean(\"setWaypointAlongRoute\", false) then\n                        system.setWaypoint(universe.CreatePos(currentWaypoint.Destination()).AsPosString(), false)\n                    end\n                end\n            end,\n            traceback\n        )\n\n        if not status then\n            system.print(err)\n            unit.exit()\n        end\n    end\n\n    function s.fcFlush()\n        local status, err, _ = xpcall(\n            function()\n                local deltaTime = 0\n                if not delta.IsRunning() then\n                    delta.Start()\n                end\n\n                deltaTime = delta.Elapsed()\n                delta.Restart()\n\n                if currentWaypoint and route then\n                    -- A state can set temporary waypoints so we switch before calling the FSM (and the states) so\n                    -- that from this point eveything works with the same WPs without having to know to switch.\n                    local prevWP = previousWaypoint\n                    local nextWP, switched = flightFSM.SelectWP(currentWaypoint)\n\n                    if switched then\n                        prevWP = Waypoint.New(Current(), 0, 0, currentWaypoint.Margin(),\n                            currentWaypoint.PathAlignmentDistanceLimitFromSurface())\n                    end\n\n                    flightFSM.FsmFlush(deltaTime, nextWP, prevWP)\n\n                    nextWP.PreCalc(prevWP)\n                    axes.SetYawTarget(nextWP.Yaw(prevWP))\n                    axes.SetPitchTarget(nextWP.Pitch(prevWP))\n                    axes.SetRollTarget(nextWP.Roll(prevWP))\n\n                    if nextWP.WithinMargin(WPReachMode.ENTRY) then\n                        flightFSM.AtWaypoint(route.LastPointReached(), nextWP, prevWP)\n\n                        -- Lock direction when WP is reached, but don't override existing locks, such as is in place when strafing.\n                        local lockDir = (nextWP.Destination() - prevWP.Destination())\n                            :NormalizeInPlace()\n                        nextWP.LockYawTo(lockDir, false)\n\n                        if not flightFSM.PreventNextWp() then\n                            -- Switch to next waypoint\n                            s.NextWP()\n                        end\n                    end\n                else\n                    --- This is a workaround for engines remembering their states from a previous session; shut down all engines.\n                    unit.setEngineCommand(\"all\", { 0, 0, 0 }, { 0, 0, 0 }, true, true, \"\", \"\", \"\", 1)\n                end\n\n                if not flightFSM.DisablesAllThrust() then\n                    axes.Flush(deltaTime)\n                end\n\n                brakes:BrakeFlush()\n            end,\n            traceback\n        )\n\n        if not status then\n            system.print(err)\n            unit.exit()\n        end\n    end\n\n    singleton = setmetatable(s, FlightCore)\n    return singleton\nend\n\n-- The module\nreturn FlightCore\n\nend)\npackage.preload['YFS:../e/lib/src/util/ValueTree.lua']=(function()\n---A ValueTree works a bit like Json; it allows you to set values in a tree structure.\n---@class ValueTree\n---@field Set fun(topicPath:string, value:string|number|boolean|table|nil)\n---@field Pick fun():table\n---@field Peek fun():table\n\nlocal ValueTree = {}\nValueTree.__index = ValueTree\n\n---Creates a new ValueTree\n---@return ValueTree\nfunction ValueTree.New()\n    local s = {}\n    local tree = {}\n\n    ---Sets the value in tree\n    ---@param topicPath string A path or just a name, such as a/b or just myValue.\n    ---@param value string|number|boolean|table|nil\n    function s.Set(topicPath, value)\n        -- Build a tree for the path\n        local parts = {}\n\n        for nodeName in string.gmatch(topicPath, \"[a-zA-Z0-9_]+\") do\n            table.insert(parts, nodeName)\n        end\n\n        if not tree then\n            tree = {}\n        end\n\n        local curr = tree\n        for i, nodeName in ipairs(parts) do\n            if i == #parts then\n                -- Save the name for the value\n                break\n            end\n            if not curr[nodeName] then\n                curr[nodeName] = {}\n            end\n            curr = curr[nodeName]\n        end\n\n        curr[parts[#parts]] = value\n    end\n\n    ---Picks the current tree, or returns nil if no data is available.\n    ---@return table|nil\n    function s.Pick()\n        local old = tree\n        tree = nil\n        return old\n    end\n\n    ---Returns the current tree or nil if no data is available\n    ---@return table\n    function s.Peek()\n        return tree\n    end\n\n    return setmetatable(s, ValueTree)\nend\n\nreturn ValueTree\n\nend)\npackage.preload['YFS:screen/layout_out.lua']=(function()\nlocal layout = {\n    fonts = {\n        p14 = {\n            font = \"Play\",\n            size = 14\n        },\n        p18 = {\n            font = \"Play\",\n            size = 18\n        },\n        p24 = {\n            font = \"Play\",\n            size = 24\n        },\n        p36 = {\n            font = \"Play\",\n            size = 36\n        },\n    },\n    styles = {\n        bkgDark = {\n            fill = \"#000000ff\"\n        },\n        bkgLight = {\n            fill = \"#111111ff\",\n        },\n        icon = {\n            fill = \"#ffffffff\",\n        },\n        headerText = {\n            fill = \"#555555ff\",\n            align = \"h0,v3\"\n        },\n        headerTextRight = {\n            fill = \"#555555ff\",\n            align = \"h2,v3\"\n        },\n        info = {\n            fill = \"#ffffffff\",\n            align = \"h2,v3\"\n        },\n        units = {\n            fill = \"#ffffffff\",\n            align = \"h2,v3\"\n        },\n        routeButton = {\n            align = \"h1,v2\",\n            fill = \"#546263ff\",\n        },\n        routeButtonHover = {\n            fill = \"#2f6fd0ff\"\n        },\n        routeCover = {\n            fill = \"#111111ff\",\n            stroke = {\n                color = \"#111111ff\",\n                distance = 1\n            }\n        },\n        routeEndpointText = {\n            fill = \"#000000ff\",\n            align = \"h1,v2\"\n        },\n        routeName = {\n            fill = \"#ffffffff\",\n            align = \"h1,v3\"\n        },\n        ---- Route editor -----\n        routeEditTableHeader = {\n            fill = \"#888888ff\",\n            align = \"h0, v3\"\n        },\n        routeEditTableData = {\n            fill = \"#ffffffff\",\n            align = \"h0,v3\"\n        },\n        routeEditTableDataCentered = {\n            fill = \"#ffffffff\",\n            align = \"h1,v3\"\n        },\n        routeEditTableDataRight = {\n            fill = \"#ffffffff\",\n            align = \"h2,v3\"\n        },\n        routeEditHover = {\n            fill = \"#2f6fd0ff\",\n            align = \"h0,v3\"\n        },\n        routeEditHoverRight = {\n            fill = \"#2f6fd0ff\",\n            align = \"h2,v3\"\n        },\n        routeEditHoverRed = {\n            fill = \"#ff0000ff\",\n            align = \"h0,v3\"\n        },\n        routeEditTableDataCenteredHover = {\n            fill = \"#2f6fd0ff\",\n            align = \"h1,v3\"\n        },\n        editRouteRouteName = {\n            fill = \"#ffffffff\",\n            align = \"h0,v3\"\n        },\n        split = {\n            stroke = {\n                distance = 2,\n                color = \"#181818FF\"\n            }\n        }\n    },\n    pages = {\n        status = {\n            components = {\n                {\n                    type = \"box\",\n                    layer = 1,\n                    style = \"bkgDark\",\n                    pos1 = \"(0,0)\",\n                    pos2 = \"(1024,240)\"\n                },\n                {\n                    type = \"box\",\n                    layer = 1,\n                    style = \"icon\",\n                    pos1 = \"(40,20)\",\n                    pos2 = \"(60,40)\",\n                    replicate = {\n                        x_count = 2,\n                        y_count = 2,\n                        x_step = 40,\n                        y_step = 40\n                    }\n                },\n                {\n                    type = \"box\",\n                    layer = 1,\n                    style = \"icon\",\n                    pos1 = \"(60,40)\",\n                    pos2 = \"(80,60)\"\n                },\n                {\n                    type = \"text\",\n                    layer = 1,\n                    style = \"headerText\",\n                    pos1 = \"(120,20)\",\n                    text = \"Total mass\",\n                    font = \"p18\"\n                },\n                {\n                    type = \"text\",\n                    layer = 1,\n                    style = \"info\",\n                    pos1 = \"(280,50)\",\n                    font = \"p36\",\n                    text = \"$num(path{mass:total}:init{0}:format{%0.2f}:interval{0.5})\"\n                },\n                {\n                    type = \"text\",\n                    layer = 1,\n                    style = \"units\",\n                    pos1 = \"(260,70)\",\n                    font = \"p14\",\n                    text = \"$str(path{mass:totalUnit}:init{kg}:interval{0.5})\"\n                },\n                {\n                    type = \"text\",\n                    layer = 1,\n                    style = \"headerText\",\n                    pos1 = \"(300,20)\",\n                    text = \"Current speed\",\n                    font = \"p18\"\n                },\n                {\n                    type = \"text\",\n                    layer = 1,\n                    style = \"info\",\n                    pos1 = \"(460,50)\",\n                    font = \"p36\",\n                    text = \"$num(path{flightData:absSpeed}:init{0}:format{%0.2f}:interval{0.5})\"\n                },\n                {\n                    type = \"text\",\n                    layer = 1,\n                    style = \"units\",\n                    pos1 = \"(440,70)\",\n                    font = \"p14\",\n                    text = \"$str(path{flightData:speedUnit}:init{km/h}:interval{0.5})\"\n                },\n                {\n                    type = \"text\",\n                    layer = 1,\n                    style = \"headerText\",\n                    pos1 = \"(480,20)\",\n                    text = \"Current route\",\n                    font = \"p18\"\n                },\n                {\n                    type = \"text\",\n                    layer = 1,\n                    style = \"info\",\n                    pos1 = \"(640,50)\",\n                    font = \"p36\",\n                    text = \"$str(path{route/current:name}:init{-}:interval{0.5})\"\n                },\n                {\n                    type = \"box\",\n                    layer = 1,\n                    style = \"icon\",\n                    pos1 = \"(60,140)\",\n                    pos2 = \"(80,160)\",\n                    replicate = {\n                        x_count = 1,\n                        y_count = 2,\n                        y_step = 40\n                    }\n                },\n                {\n                    type = \"box\",\n                    layer = 1,\n                    style = \"icon\",\n                    pos1 = \"(40,160)\",\n                    pos2 = \"(60,180)\",\n                    replicate = {\n                        x_count = 2,\n                        y_count = 1,\n                        x_step = 40\n                    }\n                },\n                {\n                    type = \"text\",\n                    layer = 1,\n                    style = \"headerText\",\n                    pos1 = \"(120,140)\",\n                    text = \"Remaining distance\",\n                    font = \"p18\"\n                },\n                {\n                    type = \"text\",\n                    layer = 1,\n                    style = \"info\",\n                    pos1 = \"(280,170)\",\n                    font = \"p36\",\n                    text = \"$num(path{finalWp:distance}:init{0}:format{%0.2f}:interval{0.5})\"\n                },\n                {\n                    type = \"text\",\n                    layer = 1,\n                    style = \"units\",\n                    pos1 = \"(260,190)\",\n                    font = \"p14\",\n                    text = \"$str(path{finalWp:distanceUnit}:init{km}:interval{0.5})\"\n                },\n                {\n                    type = \"text\",\n                    layer = 1,\n                    style = \"headerText\",\n                    pos1 = \"(300,140)\",\n                    text = \"Next WP distance\",\n                    font = \"p18\"\n                },\n                {\n                    type = \"text\",\n                    layer = 1,\n                    style = \"info\",\n                    pos1 = \"(460,170)\",\n                    font = \"p36\",\n                    text = \"$num(path{nextWp:distance}:init{0}:format{%0.2f}:interval{0.5})\"\n                },\n                {\n                    type = \"text\",\n                    layer = 1,\n                    style = \"units\",\n                    pos1 = \"(440,190)\",\n                    font = \"p14\",\n                    text = \"$str(path{nextWp:distanceUnit}:init{km}:interval{0.5})\"\n                },\n                {\n                    type = \"text\",\n                    layer = 1,\n                    style = \"headerText\",\n                    pos1 = \"(480,140)\",\n                    text = \"Deviation\",\n                    font = \"p18\"\n                },\n                {\n                    type = \"text\",\n                    layer = 1,\n                    style = \"info\",\n                    pos1 = \"(640,170)\",\n                    font = \"p36\",\n                    text = \"$str(path{deviation:distance}:init{}:interval{0.5})\"\n                },\n                {\n                    type = \"text\",\n                    layer = 1,\n                    style = \"units\",\n                    pos1 = \"(620,190)\",\n                    font = \"p14\",\n                    text = \"m\"\n                }\n            }\n        },\n        floor = {\n            components = {\n                {\n                    type = \"box\",\n                    layer = 1,\n                    style = \"bkgLight\",\n                    pos1 = \"(0,241)\",\n                    pos2 = \"(1024,613)\"\n                },\n                {\n                    type = \"box\",\n                    layer = 1,\n                    visible = true,\n                    pos1 = \"(40,280)\",\n                    pos2 = \"(160,320)\",\n                    style = \"routeButton\",\n                    mouse = {\n                        inside = {\n                            set_style = \"routeButtonHover\"\n                        },\n                        click = {\n                            command = \"$str(path{floorSelection:routeName}:init{}:format{route-activate '%s'})\"\n                        }\n                    }\n                },\n                {\n                    type = \"box\",\n                    layer = 1,\n                    visible = true,\n                    pos1 = \"(40,300)\",\n                    pos2 = \"(60,320)\",\n                    style = \"routeCover\",\n                    replicate = {\n                        x_count = 2,\n                        x_step = 160\n                    }\n                },\n                {\n                    type = \"box\",\n                    layer = 1,\n                    visible = true,\n                    pos1 = \"(140,300)\",\n                    pos2 = \"(160,320)\",\n                    style = \"routeCover\",\n                    replicate = {\n                        x_count = 2,\n                        x_step = 160\n                    }\n                },\n                {\n                    type = \"text\",\n                    layer = 1,\n                    visible = true,\n                    pos1 = \"(100,300)\",\n                    text = \"End\",\n                    style = \"routeEndpointText\",\n                    font = \"p14\",\n                    hitable = false\n                },\n                {\n                    type = \"box\",\n                    layer = 1,\n                    visible = true,\n                    pos1 = \"(40,380)\",\n                    pos2 = \"(160,420)\",\n                    style = \"routeButton\",\n                    mouse = {\n                        inside = {\n                            set_style = \"routeButtonHover\"\n                        },\n                        click = {\n                            command =\n                            \"$str(path{floorSelection:routeName}:init{}:format{route-activate '%s' -index 1})\"\n                        }\n                    }\n                },\n                {\n                    type = \"text\",\n                    layer = 1,\n                    pos1 = \"(100, 360)\",\n                    visible = true,\n                    style = \"routeName\",\n                    font = \"p24\",\n                    text = \"$str(path{floorSelection:routeName}:init{})\"\n                },\n                {\n                    type = \"box\",\n                    layer = 1,\n                    visible = true,\n                    pos1 = \"(40,380)\",\n                    pos2 = \"(60,400)\",\n                    style = \"routeCover\"\n                },\n                {\n                    type = \"box\",\n                    layer = 1,\n                    visible = true,\n                    pos1 = \"(140,380)\",\n                    pos2 = \"(160,400)\",\n                    style = \"routeCover\"\n                },\n                {\n                    type = \"text\",\n                    layer = 1,\n                    visible = true,\n                    pos1 = \"(100,400)\",\n                    text = \"Start\",\n                    style = \"routeEndpointText\",\n                    font = \"p14\",\n                    hitable = false\n                },\n                {\n                    type = \"text\",\n                    layer = 1,\n                    style = \"routeEditTableData\",\n                    font = \"p24\",\n                    pos1 = \"(180, 300)\",\n                    text = \"$num(path{floorSelection/points/[#]:index}:init{0})\",\n                    visible = \"$bool(path{floorSelection/points/[#]:visible}:init{false})\",\n                    replicate = {\n                        y_count = 8,\n                        y_step = 30,\n                        x_count = 3,\n                        x_step = 260,\n                        column_mode = true\n                    }\n                },\n                {\n                    type = \"text\",\n                    layer = 1,\n                    style = \"routeEditTableData\",\n                    font = \"p24\",\n                    pos1 = \"(220, 300)\",\n                    text = \"$str(path{floorSelection/points/[#]:name}:init{})\",\n                    visible = \"$bool(path{floorSelection/points/[#]:visible}:init{false})\",\n                    mouse = {\n                        click = {\n                            command =\n                            \"$str(path{floorSelection/points/[#]:activate}:init{}:format{%s})\"\n                        },\n                        inside = {\n                            set_style = \"routeEditHover\"\n                        }\n                    },\n                    replicate = {\n                        y_count = 8,\n                        y_step = 30,\n                        x_count = 3,\n                        x_step = 260,\n                        column_mode = true\n                    }\n                },\n                {\n                    type = \"text\",\n                    layer = 1,\n                    font = \"p24\",\n                    style = \"routeEditTableData\",\n                    pos1 = \"(20,600)\",\n                    text = \"$num(path{floorSelection:currentPage}:init{1}:format{< %0.0f})\",\n                    mouse = {\n                        click = {\n                            command = \"#fl-prev-floor-page\"\n                        },\n                        inside = {\n                            set_style = \"routeEditHover\"\n                        }\n                    }\n                },\n                {\n                    type = \"text\",\n                    layer = 1,\n                    font = \"p24\",\n                    style = \"routeEditTableDataRight\",\n                    pos1 = \"(120,600)\",\n                    text = \"$num(path{floorSelection:pageCount}:init{1}:format{ / %0.0f >})\",\n                    mouse = {\n                        click = {\n                            command = \"#fl-next-floor-page\"\n                        },\n                        inside = {\n                            set_style = \"routeEditHoverRight\"\n                        }\n                    }\n                },\n                {\n                    type = \"image\",\n                    layer = 2,\n                    pos1 = \"(935,580)\",\n                    dimensions = \"(20,20)\",\n                    sub = \"(0,480)\",\n                    subDimensions = \"(20,20)\",\n                    style = \"icon\",\n                    url = \"assets.prod.novaquark.com/94617/4158c26e-9db3-4a28-9468-b84207e44eec.png\",\n                    mouse = {\n                        click = {\n                            command = \"activatepage{status,routeSelection}\"\n                        },\n                        inside = {\n                            set_style = \"routeEditHover\"\n                        }\n                    }\n                },\n                {\n                    type = \"text\",\n                    layer = 1,\n                    font = \"p24\",\n                    style = \"routeEditTableData\",\n                    pos1 = \"(960,600)\",\n                    text = \"Exit\",\n                    mouse = {\n                        click = {\n                            command = \"activatepage{status,routeSelection}\"\n                        },\n                        inside = {\n                            set_style = \"routeEditHover\"\n                        }\n                    }\n                }\n            }\n        },\n        routeSelection = {\n            components = {\n                {\n                    type = \"box\",\n                    layer = 1,\n                    style = \"bkgLight\",\n                    pos1 = \"(0,241)\",\n                    pos2 = \"(1024,613)\"\n                },\n                {\n                    type = \"box\",\n                    layer = 1,\n                    visible = \"$bool(path{routeSelection/routes/[#]:visible}:init{false})\",\n                    pos1 = \"(40,280)\",\n                    pos2 = \"(160,320)\",\n                    style = \"routeButton\",\n                    mouse = {\n                        inside = {\n                            set_style = \"routeButtonHover\"\n                        },\n                        click = {\n                            command = \"$str(path{routeSelection/routes/[#]:name}:init{}:format{route-activate '%s'})\"\n                        }\n                    },\n                    replicate = {\n                        x_count = 6,\n                        x_step = 160\n                    }\n                },\n                {\n                    type = \"box\",\n                    layer = 1,\n                    visible = \"$bool(path{routeSelection/routes/[#]:visible}:init{false})\",\n                    pos1 = \"(40,300)\",\n                    pos2 = \"(60,320)\",\n                    style = \"routeCover\",\n                    replicate = {\n                        x_count = 6,\n                        x_step = 160\n                    }\n                },\n                {\n                    type = \"box\",\n                    layer = 1,\n                    visible = \"$bool(path{routeSelection/routes/[#]:visible}:init{false})\",\n                    pos1 = \"(140,300)\",\n                    pos2 = \"(160,320)\",\n                    style = \"routeCover\",\n                    replicate = {\n                        x_count = 6,\n                        x_step = 160\n                    }\n                },\n                {\n                    type = \"text\",\n                    layer = 1,\n                    visible = \"$bool(path{routeSelection/routes/[#]:visible}:init{false})\",\n                    pos1 = \"(100,300)\",\n                    text = \"End\",\n                    style = \"routeEndpointText\",\n                    font = \"p14\",\n                    hitable = false,\n                    replicate = {\n                        x_count = 6,\n                        x_step = 160\n                    }\n                },\n                {\n                    type = \"box\",\n                    layer = 1,\n                    visible = \"$bool(path{routeSelection/routes/[#]:visible}:init{false})\",\n                    pos1 = \"(40,380)\",\n                    pos2 = \"(160,420)\",\n                    style = \"routeButton\",\n                    mouse = {\n                        inside = {\n                            set_style = \"routeButtonHover\"\n                        },\n                        click = {\n                            command =\n                            \"$str(path{routeSelection/routes/[#]:name}:init{}:format{route-activate '%s' -index 1})\"\n                        }\n                    },\n                    replicate = {\n                        x_count = 6,\n                        x_step = 160\n                    }\n                },\n                {\n                    type = \"text\",\n                    layer = 1,\n                    pos1 = \"(100, 360)\",\n                    visible = \"$bool(path{routeSelection/routes/[#]:visible}:init{false})\",\n                    style = \"routeName\",\n                    font = \"p24\",\n                    text = \"$str(path{routeSelection/routes/[#]:name}:init{})\",\n                    replicate = {\n                        x_count = 6,\n                        x_step = 160\n                    }\n                },\n                {\n                    type = \"box\",\n                    layer = 1,\n                    visible = \"$bool(path{routeSelection/routes/[#]:visible}:init{false})\",\n                    pos1 = \"(40,380)\",\n                    pos2 = \"(60,400)\",\n                    style = \"routeCover\",\n                    replicate = {\n                        x_count = 6,\n                        x_step = 160\n                    }\n                },\n                {\n                    type = \"box\",\n                    layer = 1,\n                    visible = \"$bool(path{routeSelection/routes/[#]:visible}:init{false})\",\n                    pos1 = \"(140,380)\",\n                    pos2 = \"(160,400)\",\n                    style = \"routeCover\",\n                    replicate = {\n                        x_count = 6,\n                        x_step = 160\n                    }\n                },\n                {\n                    type = \"text\",\n                    layer = 1,\n                    visible = \"$bool(path{routeSelection/routes/[#]:visible}:init{false})\",\n                    pos1 = \"(100,400)\",\n                    text = \"Start\",\n                    style = \"routeEndpointText\",\n                    font = \"p14\",\n                    hitable = false,\n                    replicate = {\n                        x_count = 6,\n                        x_step = 160\n                    }\n                },\n                {\n                    type = \"box\",\n                    layer = 1,\n                    visible = \"$bool(path{routeSelection/routes/[#]:visible}:init{false})\",\n                    pos1 = \"(40,440)\",\n                    pos2 = \"(160,460)\",\n                    style = \"routeButton\",\n                    mouse = {\n                        inside = {\n                            set_style = \"routeButtonHover\"\n                        },\n                        click = {\n                            command =\n                            \"$str(path{routeSelection/routes/[#]:name}:init{}:format{floor '%s'})\"\n                        }\n                    },\n                    replicate = {\n                        x_count = 6,\n                        x_step = 160\n                    }\n                },\n                {\n                    type = \"text\",\n                    layer = 1,\n                    visible = \"$bool(path{routeSelection/routes/[#]:visible}:init{false})\",\n                    pos1 = \"(100,450)\",\n                    text = \"Waypoints\",\n                    style = \"routeEndpointText\",\n                    font = \"p14\",\n                    hitable = false,\n                    replicate = {\n                        x_count = 6,\n                        x_step = 160\n                    }\n                },\n                {\n                    type = \"text\",\n                    layer = 1,\n                    font = \"p24\",\n                    style = \"routeEditTableData\",\n                    pos1 = \"(20,600)\",\n                    text = \"$num(path{routeSelection:routePage}:init{1}:format{< %0.0f})\",\n                    mouse = {\n                        click = {\n                            command = \"#rsel-prev-route-page\"\n                        },\n                        inside = {\n                            set_style = \"routeEditHover\"\n                        }\n                    }\n                },\n                {\n                    type = \"text\",\n                    layer = 1,\n                    font = \"p24\",\n                    style = \"routeEditTableDataRight\",\n                    pos1 = \"(120,600)\",\n                    text = \"$num(path{routeSelection:pageCount}:init{1}:format{ / %0.0f >})\",\n                    mouse = {\n                        click = {\n                            command = \"#rsel-next-route-page\"\n                        },\n                        inside = {\n                            set_style = \"routeEditHoverRight\"\n                        }\n                    }\n                },\n                {\n                    type = \"image\",\n                    layer = 2,\n                    pos1 = \"(800,580)\",\n                    dimensions = \"(20,20)\",\n                    sub = \"(0,460)\",\n                    subDimensions = \"(20,20)\",\n                    style = \"icon\",\n                    url = \"assets.prod.novaquark.com/94617/4158c26e-9db3-4a28-9468-b84207e44eec.png\",\n                    mouse = {\n                        click = {\n                            command = \"activatepage{routeEdit}\"\n                        },\n                        inside = {\n                            set_style = \"routeEditHover\"\n                        }\n                    }\n                },\n                {\n                    type = \"text\",\n                    layer = 1,\n                    pos1 = \"(825,600)\",\n                    text = \"Edit\",\n                    style = \"routeEditTableData\",\n                    font = \"p24\",\n                    mouse = {\n                        click = {\n                            command = \"activatepage{routeEdit}\"\n                        },\n                        inside = {\n                            set_style = \"routeEditHover\"\n                        }\n                    }\n                },\n                {\n                    type = \"image\",\n                    layer = 2,\n                    pos1 = \"(880,580)\",\n                    dimensions = \"(20,20)\",\n                    sub = \"(0,0)\",\n                    subDimensions = \"(20,20)\",\n                    style = \"icon\",\n                    url = \"assets.prod.novaquark.com/94617/4158c26e-9db3-4a28-9468-b84207e44eec.png\",\n                    mouse = {\n                        click = {\n                            command = \"activatepage{details}\"\n                        },\n                        inside = {\n                            set_style = \"routeEditHover\"\n                        }\n                    }\n                },\n                {\n                    type = \"text\",\n                    layer = 1,\n                    pos1 = \"(905,600)\",\n                    text = \"Details\",\n                    style = \"routeEditTableData\",\n                    font = \"p24\",\n                    mouse = {\n                        click = {\n                            command = \"activatepage{details}\"\n                        },\n                        inside = {\n                            set_style = \"routeEditHover\"\n                        }\n                    }\n                }\n            }\n        },\n        routeEdit = {\n            components = {\n                {\n                    type = \"box\",\n                    layer = 1,\n                    style = \"bkgDark\",\n                    pos1 = \"(0,0)\",\n                    pos2 = \"(1024,613)\"\n                },\n                {\n                    type = \"text\",\n                    layer = 1,\n                    style = \"headerText\",\n                    font = \"p36\",\n                    pos1 = \"(30,50)\",\n                    text = \"Waypoints\"\n                },\n                {\n                    type = \"text\",\n                    layer = 1,\n                    style = \"routeEditTableHeader\",\n                    font = \"p14\",\n                    pos1 = \"(30,110)\",\n                    text = \"Waypoint name\"\n                },\n                {\n                    type = \"text\",\n                    layer = 1,\n                    style = \"routeEditTableHeader\",\n                    font = \"p14\",\n                    pos1 = \"(300,110)\",\n                    text = \"Delete\"\n                },\n                {\n                    type = \"text\",\n                    layer = 1,\n                    style = \"routeEditTableHeader\",\n                    font = \"p14\",\n                    pos1 = \"(370,110)\",\n                    text = \"Insert\"\n                },\n                {\n                    type = \"text\",\n                    layer = 1,\n                    style = \"routeEditTableHeader\",\n                    font = \"p14\",\n                    pos1 = \"(430,110)\",\n                    text = \"Ins + facing\"\n                },\n                {\n                    type = \"text\",\n                    layer = 1,\n                    style = \"routeEditTableData\",\n                    font = \"p24\",\n                    pos1 = \"(30, 140)\",\n                    text = \"$str(path{availableWaypoints/wayPoints/[#]:name}:init{})\",\n                    visible = \"$bool(path{availableWaypoints/wayPoints/[#]:visible}:init{false})\",\n                    mouse = {\n                        click = {\n                            command =\n                            \"$str(path{availableWaypoints/wayPoints/[#]:pos}:init{}:format{set-waypoint -notify %s})\"\n                        },\n                        inside = {\n                            set_style = \"routeEditHover\"\n                        }\n                    },\n                    replicate = {\n                        y_count = 10,\n                        y_step = 30\n                    }\n                },\n                {\n                    type = \"text\",\n                    layer = 1,\n                    style = \"routeEditTableData\",\n                    font = \"p24\",\n                    pos1 = \"(300, 140)\",\n                    text = \"X\",\n                    visible = \"$bool(path{availableWaypoints/wayPoints/[#]:visible}:init{false})\",\n                    mouse = {\n                        click = {\n                            command = \"$str(path{availableWaypoints/wayPoints/[#]:name}:init{}:format{pos-delete '%s'})\"\n                        },\n                        inside = {\n                            set_style = \"routeEditHoverRed\"\n                        }\n                    },\n                    replicate = {\n                        y_count = 10,\n                        y_step = 30\n                    }\n                },\n                {\n                    type = \"text\",\n                    layer = 1,\n                    style = \"routeEditTableData\",\n                    font = \"p24\",\n                    pos1 = \"(370, 140)\",\n                    text = \">>\",\n                    visible = \"$bool(path{availableWaypoints/wayPoints/[#]:visible}:init{false})\",\n                    mouse = {\n                        click = {\n                            command =\n                            \"$str(path{availableWaypoints/wayPoints/[#]:name}:init{}:format{route-add-named-pos '%s'})\"\n                        },\n                        inside = {\n                            set_style = \"routeEditHover\"\n                        }\n                    },\n                    replicate = {\n                        y_count = 10,\n                        y_step = 30\n                    }\n                },\n                {\n                    type = \"text\",\n                    layer = 1,\n                    style = \"routeEditTableData\",\n                    font = \"p24\",\n                    pos1 = \"(430, 140)\",\n                    text = \">>\",\n                    visible = \"$bool(path{availableWaypoints/wayPoints/[#]:visible}:init{false})\",\n                    mouse = {\n                        click = {\n                            command =\n                            \"$str(path{availableWaypoints/wayPoints/[#]:name}:init{}:format{route-add-named-pos '%s' -lockdir})\"\n                        },\n                        inside = {\n                            set_style = \"routeEditHover\"\n                        }\n                    },\n                    replicate = {\n                        y_count = 10,\n                        y_step = 30\n                    }\n                },\n                {\n                    type = \"image\",\n                    layer = 2,\n                    pos1 = \"(165,540)\",\n                    dimensions = \"(20,20)\",\n                    sub = \"(0,1040)\",\n                    subDimensions = \"(20,20)\",\n                    style = \"icon\",\n                    url = \"assets.prod.novaquark.com/94617/4158c26e-9db3-4a28-9468-b84207e44eec.png\",\n                    mouse = {\n                        click = {\n                            command = \"pos-save-current-as -auto\"\n                        },\n                        inside = {\n                            set_style = \"routeEditHover\"\n                        }\n                    }\n                },\n                {\n                    type = \"text\",\n                    layer = 1,\n                    style = \"routeEditTableDataCentered\",\n                    font = \"p24\",\n                    pos1 = \"(256, 560)\",\n                    text = \"Add Current\",\n                    visible = true,\n                    mouse = {\n                        click = {\n                            command = \"pos-save-current-as -auto\"\n                        },\n                        inside = {\n                            set_style = \"routeEditTableDataCenteredHover\"\n                        }\n                    }\n                },\n                {\n                    type = \"text\",\n                    layer = 1,\n                    font = \"p24\",\n                    style = \"routeEditTableData\",\n                    pos1 = \"(20,520)\",\n                    text = \"$num(path{availableWaypoints:currentPage}:init{1}:format{< %0.0f})\",\n                    mouse = {\n                        click = {\n                            command = \"#re-prev-wp-page\"\n                        },\n                        inside = {\n                            set_style = \"routeEditHover\"\n                        }\n                    }\n                },\n                {\n                    type = \"text\",\n                    layer = 1,\n                    font = \"p24\",\n                    style = \"routeEditTableDataRight\",\n                    pos1 = \"(120,520)\",\n                    text = \"$num(path{availableWaypoints:pageCount}:init{1}:format{/ %0.0f >})\",\n                    mouse = {\n                        click = {\n                            command = \"#re-next-wp-page\"\n                        },\n                        inside = {\n                            set_style = \"routeEditHoverRight\"\n                        }\n                    }\n                },\n\n                {\n                    type = \"line\",\n                    layer = 1,\n                    pos1 = \"(512,50)\",\n                    pos2 = \"(512,563)\",\n                    style = \"split\"\n                },\n\n                ------- Routes -------\n                {\n                    type = \"text\",\n                    layer = 1,\n                    style = \"headerTextRight\",\n                    font = \"p36\",\n                    pos1 = \"(994,50)\",\n                    text = \"Routes\"\n                },\n\n                {\n                    type = \"text\",\n                    layer = 1,\n                    font = \"p24\",\n                    style = \"editRouteRouteName\",\n                    pos1 = \"(530,50)\",\n                    text = \"$str(path{editRoute:selectRouteName}:init{})\"\n                },\n\n                {\n                    type = \"text\",\n                    layer = 1,\n                    style = \"routeEditTableData\",\n                    font = \"p24\",\n                    text = \"$num(path{editRoute:ix}:init{1}:format{< %0.0f})\",\n                    pos1 = \"(530,100)\",\n                    mouse = {\n                        click = {\n                            command = \"#re-previous-route\"\n                        },\n                        inside = {\n                            set_style = \"routeEditHover\"\n                        }\n                    }\n                },\n                {\n                    type = \"text\",\n                    layer = 1,\n                    style = \"routeEditTableDataRight\",\n                    font = \"p24\",\n                    text = \"$num(path{editRoute:count}:init{1}:format{/ %0.0f >})\",\n                    pos1 = \"(630,100)\",\n                    mouse = {\n                        click = {\n                            command = \"#re-next-route\"\n                        },\n                        inside = {\n                            set_style = \"routeEditHoverRight\"\n                        }\n                    }\n                },\n                {\n                    type = \"image\",\n                    layer = 2,\n                    pos1 = \"(815,84)\",\n                    dimensions = \"(20,20)\",\n                    sub = \"(0,20)\",\n                    subDimensions = \"(20,20)\",\n                    style = \"icon\",\n                    url = \"assets.prod.novaquark.com/94617/4158c26e-9db3-4a28-9468-b84207e44eec.png\",\n                    mouse = {\n                        click = {\n                            command = \"$str(path{editRoute:selectRouteName}:format{route-edit '%s'}:init{})\"\n                        },\n                        inside = {\n                            set_style = \"routeEditHover\"\n                        }\n                    }\n                },\n                {\n                    type = \"text\",\n                    layer = 1,\n                    font = \"p24\",\n                    style = \"routeEditTableData\",\n                    pos1 = \"(840,100)\",\n                    text = \"Edit\",\n                    mouse = {\n                        click = {\n                            command = \"$str(path{editRoute:selectRouteName}:format{route-edit '%s'}:init{})\"\n                        },\n                        inside = {\n                            set_style = \"routeEditHover\"\n                        }\n                    }\n                },\n                {\n                    type = \"image\",\n                    layer = 2,\n                    pos1 = \"(895,84)\",\n                    dimensions = \"(20,20)\",\n                    sub = \"(0,120)\",\n                    subDimensions = \"(20,20)\",\n                    style = \"icon\",\n                    url = \"assets.prod.novaquark.com/94617/4158c26e-9db3-4a28-9468-b84207e44eec.png\",\n                    mouse = {\n                        click = {\n                            command = \"$str(path{editRoute:selectRouteName}:format{route-delete '%s'}:init{})\"\n                        },\n                        inside = {\n                            set_style = \"routeEditHoverRed\"\n                        }\n                    }\n                },\n                {\n                    type = \"text\",\n                    layer = 1,\n                    font = \"p24\",\n                    style = \"routeEditTableData\",\n                    pos1 = \"(920,100)\",\n                    text = \"Delete\",\n                    mouse = {\n                        click = {\n                            command = \"$str(path{editRoute:selectRouteName}:format{route-delete '%s'}:init{})\"\n                        },\n                        inside = {\n                            set_style = \"routeEditHoverRed\"\n                        }\n                    }\n                },\n\n                ----- Waypoints in route -----\n                {\n                    type = \"text\",\n                    layer = 1,\n                    style = \"routeEditTableHeader\",\n                    font = \"p14\",\n                    pos1 = \"(530,170)\",\n                    text = \"Waypoint name\"\n                },\n                {\n                    type = \"text\",\n                    layer = 1,\n                    style = \"routeEditTableHeader\",\n                    font = \"p14\",\n                    pos1 = \"(720,170)\",\n                    text = \"Gate\"\n                },\n                {\n                    type = \"text\",\n                    layer = 1,\n                    style = \"routeEditTableHeader\",\n                    font = \"p14\",\n                    pos1 = \"(770,170)\",\n                    text = \"Skip\"\n                },\n                {\n                    type = \"text\",\n                    layer = 1,\n                    style = \"routeEditTableHeader\",\n                    font = \"p14\",\n                    pos1 = \"(820,170)\",\n                    text = \"Sel\"\n                },\n                {\n                    type = \"text\",\n                    layer = 1,\n                    style = \"routeEditTableHeader\",\n                    font = \"p14\",\n                    pos1 = \"(870,170)\",\n                    text = \"Up\"\n                },\n                {\n                    type = \"text\",\n                    layer = 1,\n                    style = \"routeEditTableHeader\",\n                    font = \"p14\",\n                    pos1 = \"(900,170)\",\n                    text = \"Down\"\n                },\n                {\n                    type = \"text\",\n                    layer = 1,\n                    style = \"routeEditTableHeader\",\n                    font = \"p14\",\n                    pos1 = \"(950,170)\",\n                    text = \"Remove\"\n                },\n                {\n                    type = \"text\",\n                    layer = 1,\n                    style = \"routeEditTableDataRight\",\n                    font = \"p24\",\n                    pos1 = \"(545, 200)\",\n                    text = \"$num(path{editRoute/points/[#]:index}:init{0}:format{%0.f})\",\n                    visible = \"$bool(path{editRoute/points/[#]:visible}:init{false})\",\n                    replicate = {\n                        y_count = 10,\n                        y_step = 30\n                    }\n                },\n                {\n                    type = \"text\",\n                    layer = 1,\n                    style = \"routeEditTableData\",\n                    font = \"p24\",\n                    pos1 = \"(570, 200)\",\n                    text = \"$str(path{editRoute/points/[#]:pointName}:init{})\",\n                    visible = \"$bool(path{editRoute/points/[#]:visible}:init{false})\",\n                    mouse = {\n                        click = {\n                            command =\n                            \"$str(path{editRoute/points/[#]:position}:init{}:format{set-waypoint -notify %s})\"\n                        },\n                        inside = {\n                            set_style = \"routeEditHover\"\n                        }\n                    },\n                    replicate = {\n                        y_count = 10,\n                        y_step = 30\n                    }\n                },\n                {\n                    type = \"image\",\n                    layer = 2,\n                    pos1 = \"(720,180)\",\n                    dimensions = \"(20,20)\",\n                    sub = \"(0,180)\",\n                    subDimensions = \"(20,20)\",\n                    style = \"icon\",\n                    url = \"assets.prod.novaquark.com/94617/4158c26e-9db3-4a28-9468-b84207e44eec.png\",\n                    visible = \"$bool(path{editRoute/points/[#]:gate}:init{false})\",\n                    mouse = {\n                        click = {\n                            command =\n                            \"$num(path{editRoute/points/[#]:index}:init{0}:format{route-set-pos-option -ix %d -toggleGate})\"\n                        },\n                        inside = {\n                            set_style = \"routeEditHover\"\n                        }\n                    },\n                    replicate = {\n                        y_count = 10,\n                        y_step = 30\n                    }\n                },\n                {\n                    type = \"image\",\n                    layer = 2,\n                    pos1 = \"(720,180)\",\n                    dimensions = \"(20,20)\",\n                    sub = \"(0,160)\",\n                    subDimensions = \"(20,20)\",\n                    style = \"icon\",\n                    url = \"assets.prod.novaquark.com/94617/4158c26e-9db3-4a28-9468-b84207e44eec.png\",\n                    visible = \"$bool(path{editRoute/points/[#]:notGate}:init{false})\",\n                    mouse = {\n                        click = {\n                            command =\n                            \"$num(path{editRoute/points/[#]:index}:init{0}:format{route-set-pos-option -ix %d -toggleGate})\"\n                        },\n                        inside = {\n                            set_style = \"routeEditHover\"\n                        }\n                    },\n                    replicate = {\n                        y_count = 10,\n                        y_step = 30\n                    }\n                },\n                {\n                    type = \"image\",\n                    layer = 2,\n                    pos1 = \"(770,180)\",\n                    dimensions = \"(20,20)\",\n                    sub = \"(0,180)\",\n                    subDimensions = \"(20,20)\",\n                    style = \"icon\",\n                    url = \"assets.prod.novaquark.com/94617/4158c26e-9db3-4a28-9468-b84207e44eec.png\",\n                    visible = \"$bool(path{editRoute/points/[#]:skippable}:init{false})\",\n                    mouse = {\n                        click = {\n                            command =\n                            \"$num(path{editRoute/points/[#]:index}:init{0}:format{route-set-pos-option -ix %d -toggleSkippable})\"\n                        },\n                        inside = {\n                            set_style = \"routeEditHover\"\n                        }\n                    },\n                    replicate = {\n                        y_count = 10,\n                        y_step = 30\n                    }\n                },\n                {\n                    type = \"image\",\n                    layer = 2,\n                    pos1 = \"(770,180)\",\n                    dimensions = \"(20,20)\",\n                    sub = \"(0,160)\",\n                    subDimensions = \"(20,20)\",\n                    style = \"icon\",\n                    url = \"assets.prod.novaquark.com/94617/4158c26e-9db3-4a28-9468-b84207e44eec.png\",\n                    visible = \"$bool(path{editRoute/points/[#]:notSkippable}:init{false})\",\n                    mouse = {\n                        click = {\n                            command =\n                            \"$num(path{editRoute/points/[#]:index}:init{0}:format{route-set-pos-option -ix %d -toggleSkippable})\"\n                        },\n                        inside = {\n                            set_style = \"routeEditHover\"\n                        }\n                    },\n                    replicate = {\n                        y_count = 10,\n                        y_step = 30\n                    }\n                },\n                {\n                    type = \"image\",\n                    layer = 2,\n                    pos1 = \"(820,180)\",\n                    dimensions = \"(20,20)\",\n                    sub = \"(0,180)\",\n                    subDimensions = \"(20,20)\",\n                    style = \"icon\",\n                    url = \"assets.prod.novaquark.com/94617/4158c26e-9db3-4a28-9468-b84207e44eec.png\",\n                    visible = \"$bool(path{editRoute/points/[#]:selectable}:init{false})\",\n                    mouse = {\n                        click = {\n                            command =\n                            \"$num(path{editRoute/points/[#]:index}:init{0}:format{route-set-pos-option -ix %d -toggleSelectable})\"\n                        },\n                        inside = {\n                            set_style = \"routeEditHover\"\n                        }\n                    },\n                    replicate = {\n                        y_count = 10,\n                        y_step = 30\n                    }\n                },\n                {\n                    type = \"image\",\n                    layer = 2,\n                    pos1 = \"(820,180)\",\n                    dimensions = \"(20,20)\",\n                    sub = \"(0,160)\",\n                    subDimensions = \"(20,20)\",\n                    style = \"icon\",\n                    url = \"assets.prod.novaquark.com/94617/4158c26e-9db3-4a28-9468-b84207e44eec.png\",\n                    visible = \"$bool(path{editRoute/points/[#]:notSelectable}:init{false})\",\n                    mouse = {\n                        click = {\n                            command =\n                            \"$num(path{editRoute/points/[#]:index}:init{0}:format{route-set-pos-option -ix %d -toggleSelectable})\"\n                        },\n                        inside = {\n                            set_style = \"routeEditHover\"\n                        }\n                    },\n                    replicate = {\n                        y_count = 10,\n                        y_step = 30\n                    }\n                },\n                {\n                    type = \"image\",\n                    layer = 2,\n                    pos1 = \"(870,180)\",\n                    dimensions = \"(20,20)\",\n                    sub = \"(0,320)\", -- Up\n                    subDimensions = \"(20,20)\",\n                    style = \"icon\",\n                    url = \"assets.prod.novaquark.com/94617/4158c26e-9db3-4a28-9468-b84207e44eec.png\",\n                    visible = \"$bool(path{editRoute/points/[#]:visible}:init{false})\",\n                    mouse = {\n                        click = {\n                            command = \"$num(path{editRoute/points/[#]:index}:init{0}:format{route-move-pos-back %0.f})\"\n                        },\n                        inside = {\n                            set_style = \"routeEditHover\"\n                        }\n                    },\n                    replicate = {\n                        y_count = 10,\n                        y_step = 30\n                    }\n                },\n                {\n                    type = \"image\",\n                    layer = 2,\n                    pos1 = \"(900,180)\",\n                    dimensions = \"(20,20)\",\n                    sub = \"(0,300)\", -- Down\n                    subDimensions = \"(20,20)\",\n                    style = \"icon\",\n                    url = \"assets.prod.novaquark.com/94617/4158c26e-9db3-4a28-9468-b84207e44eec.png\",\n                    visible = \"$bool(path{editRoute/points/[#]:visible}:init{false})\",\n                    mouse = {\n                        click = {\n                            command =\n                            \"$num(path{editRoute/points/[#]:index}:init{0}:format{route-move-pos-forward %0.f})\"\n                        },\n                        inside = {\n                            set_style = \"routeEditHover\"\n                        }\n                    },\n                    replicate = {\n                        y_count = 10,\n                        y_step = 30\n                    }\n                },\n                {\n                    type = \"text\",\n                    layer = 1,\n                    style = \"routeEditTableData\",\n                    font = \"p24\",\n                    pos1 = \"(950, 200)\",\n                    text = \"<<\",\n                    visible = \"$bool(path{editRoute/points/[#]:visible}:init{false})\",\n                    mouse = {\n                        click = {\n                            command = \"$num(path{editRoute/points/[#]:index}:init{0}:format{route-delete-pos %0.f})\"\n                        },\n                        inside = {\n                            set_style = \"routeEditHoverRed\"\n                        }\n                    },\n                    replicate = {\n                        y_count = 10,\n                        y_step = 30\n                    }\n                },\n\n                {\n                    type = \"text\",\n                    layer = 1,\n                    style = \"routeEditTableData\",\n                    font = \"p24\",\n                    text = \"$num(path{editRoute:currentPage}:init{1}:format{< %0.0f})\",\n                    pos1 = \"(530,520)\",\n                    mouse = {\n                        click = {\n                            command = \"#re-prev-point-page\"\n                        },\n                        inside = {\n                            set_style = \"routeEditHover\"\n                        }\n                    }\n                },\n                {\n                    type = \"text\",\n                    layer = 1,\n                    style = \"routeEditTableDataRight\",\n                    font = \"p24\",\n                    text = \"$num(path{editRoute:pageCount}:init{1}:format{/ %0.0f >})\",\n                    pos1 = \"(630,520)\",\n                    mouse = {\n                        click = {\n                            command = \"#re-next-point-page\"\n                        },\n                        inside = {\n                            set_style = \"routeEditHoverRight\"\n                        }\n                    }\n                },\n                {\n                    type = \"image\",\n                    layer = 2,\n                    pos1 = \"(605,540)\",\n                    dimensions = \"(20,20)\",\n                    sub = \"(0,1040)\",\n                    subDimensions = \"(20,20)\",\n                    style = \"icon\",\n                    url = \"assets.prod.novaquark.com/94617/4158c26e-9db3-4a28-9468-b84207e44eec.png\",\n                    mouse = {\n                        click = {\n                            command = \"route-add-current-pos\"\n                        },\n                        inside = {\n                            set_style = \"routeEditHover\"\n                        }\n                    }\n                },\n                {\n                    type = \"text\",\n                    layer = 1,\n                    style = \"routeEditTableData\",\n                    font = \"p24\",\n                    pos1 = \"(630, 560)\",\n                    text = \"Add current\",\n                    visible = true,\n                    mouse = {\n                        click = {\n                            command = \"route-add-current-pos\"\n                        },\n                        inside = {\n                            set_style = \"routeEditHover\"\n                        }\n                    }\n                },\n                {\n                    type = \"image\",\n                    layer = 2,\n                    pos1 = \"(765,540)\",\n                    dimensions = \"(20,20)\",\n                    sub = \"(0,1060)\",\n                    subDimensions = \"(20,20)\",\n                    style = \"icon\",\n                    url = \"assets.prod.novaquark.com/94617/4158c26e-9db3-4a28-9468-b84207e44eec.png\",\n                    mouse = {\n                        click = {\n                            command = \"route-add-current-pos -lockdir\"\n                        },\n                        inside = {\n                            set_style = \"routeEditHover\"\n                        }\n                    }\n                },\n                {\n                    type = \"text\",\n                    layer = 1,\n                    style = \"routeEditTableData\",\n                    font = \"p24\",\n                    pos1 = \"(790, 560)\",\n                    text = \"Add + facing\",\n                    visible = true,\n                    mouse = {\n                        click = {\n                            command = \"route-add-current-pos -lockdir\"\n                        },\n                        inside = {\n                            set_style = \"routeEditHover\"\n                        }\n                    }\n                },\n                {\n                    type = \"text\",\n                    layer = 1,\n                    font = \"p24\",\n                    style = \"routeEditTableData\",\n                    pos1 = \"(630,600)\",\n                    text = \"X Discard\",\n                    mouse = {\n                        click = {\n                            command = \"route-discard\"\n                        },\n                        inside = {\n                            set_style = \"routeEditHoverRed\"\n                        }\n                    }\n                },\n                {\n                    type = \"image\",\n                    layer = 2,\n                    pos1 = \"(755,580)\",\n                    dimensions = \"(20,20)\",\n                    sub = \"(0,100)\",\n                    subDimensions = \"(20,20)\",\n                    style = \"icon\",\n                    url = \"assets.prod.novaquark.com/94617/4158c26e-9db3-4a28-9468-b84207e44eec.png\",\n                    mouse = {\n                        click = {\n                            command = \"route-save\"\n                        },\n                        inside = {\n                            set_style = \"routeEditHover\"\n                        }\n                    }\n                },\n                {\n                    type = \"text\",\n                    layer = 1,\n                    font = \"p24\",\n                    style = \"routeEditTableData\",\n                    pos1 = \"(780,600)\",\n                    text = \"Save\",\n                    mouse = {\n                        click = {\n                            command = \"route-save\"\n                        },\n                        inside = {\n                            set_style = \"routeEditHover\"\n                        }\n                    }\n                },\n                {\n                    type = \"image\",\n                    layer = 2,\n                    pos1 = \"(935,580)\",\n                    dimensions = \"(20,20)\",\n                    sub = \"(0,480)\",\n                    subDimensions = \"(20,20)\",\n                    style = \"icon\",\n                    url = \"assets.prod.novaquark.com/94617/4158c26e-9db3-4a28-9468-b84207e44eec.png\",\n                    mouse = {\n                        click = {\n                            command = \"activatepage{status,routeSelection}\"\n                        },\n                        inside = {\n                            set_style = \"routeEditHover\"\n                        }\n                    }\n                },\n                {\n                    type = \"text\",\n                    layer = 1,\n                    font = \"p24\",\n                    style = \"routeEditTableData\",\n                    pos1 = \"(960,600)\",\n                    text = \"Exit\",\n                    mouse = {\n                        click = {\n                            command = \"activatepage{status,routeSelection}\"\n                        },\n                        inside = {\n                            set_style = \"routeEditHover\"\n                        }\n                    }\n                }\n            }\n        },\n        details = {\n            components = {\n                {\n                    type = \"box\",\n                    layer = 1,\n                    style = \"bkgDark\",\n                    pos1 = \"(0,0)\",\n                    pos2 = \"(1024,613)\"\n                },\n                {\n                    type = \"text\",\n                    pos1 = \"(10, 25)\",\n                    text = \"Version: 850e7fe / 20231223 22:22\",\n                    layer = 1,\n                    font = \"p24\",\n                    style = \"routeEditTableData\"\n                },\n                {\n                    type = \"text\",\n                    layer = 1,\n                    style = \"routeEditTableData\",\n                    font = \"p24\",\n                    text = \"$str(path{:floor}:format{Floor detection: %s}:init{0})\",\n                    pos1 = \"(10,50)\"\n                },\n                {\n                    type = \"image\",\n                    layer = 2,\n                    pos1 = \"(935,580)\",\n                    dimensions = \"(20,20)\",\n                    sub = \"(0,480)\",\n                    subDimensions = \"(20,20)\",\n                    style = \"icon\",\n                    url = \"assets.prod.novaquark.com/94617/4158c26e-9db3-4a28-9468-b84207e44eec.png\",\n                    mouse = {\n                        click = {\n                            command = \"activatepage{status,routeSelection}\"\n                        },\n                        inside = {\n                            set_style = \"routeEditHover\"\n                        }\n                    }\n                },\n                {\n                    type = \"text\",\n                    layer = 1,\n                    font = \"p24\",\n                    style = \"routeEditTableData\",\n                    pos1 = \"(960,600)\",\n                    text = \"Exit\",\n                    mouse = {\n                        click = {\n                            command = \"activatepage{status,routeSelection}\"\n                        },\n                        inside = {\n                            set_style = \"routeEditHover\"\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n\nreturn layout\n\nend)\npackage.preload['YFS:../e/render/e/stream/e/serializer.lua']=(function()\nlocal concat = table.concat\nlocal sFormat=string.format\n\nlocal function internalSerialize(table, tC, t)\n    t[tC] = \"{\"\n    tC = tC + 1\n    if #table == 0 then\n        local hasValue = false\n        for key, value in pairs(table) do\n            hasValue = true\n            local keyType = type(key)\n            if keyType == \"string\" then\n                t[tC] = sFormat(\"[%q]=\", key)\n            elseif keyType == \"number\" then\n                t[tC] = \"[\" .. key .. \"]=\"\n            elseif keyType == \"boolean\" then\n                t[tC] = \"[\" .. tostring(key) .. \"]=\"\n            else\n                t[tC] = \"notsupported=\"\n            end\n            tC = tC + 1\n\n            local check = type(value)\n            if check == \"table\" then\n                tC = internalSerialize(value, tC, t)\n            elseif check == \"string\" then\n                t[tC] = sFormat(\"%q\", value)\n            elseif check == \"number\" then\n                t[tC] = value\n            elseif check == \"boolean\" then\n                t[tC] = tostring(value)\n            else\n                t[tC] = '\"Not Supported\"'\n            end\n            t[tC + 1] = \",\"\n            tC = tC + 2\n        end\n        if hasValue then\n            tC = tC - 1\n        end\n    else\n        for i = 1, #table do\n            local value = table[i]\n            local check = type(value)\n            if check == \"table\" then\n                tC = internalSerialize(value, tC, t)\n            elseif check == \"string\" then\n                t[tC] = sFormat(\"%q\", value)\n            elseif check == \"number\" then\n                t[tC] = value\n            elseif check == \"boolean\" then\n                t[tC] = tostring(value)\n            else\n                t[tC] = '\"Not Supported\"'\n            end\n            t[tC + 1] = \",\"\n            tC = tC + 2\n        end\n        tC = tC - 1\n    end\n    t[tC] = \"}\"\n    return tC\nend\n\nfunction serialize(value)\n    local t = {}\n    local check = type(value)\n\n    if check == \"table\" then\n        internalSerialize(value, 1, t)\n    elseif check == \"string\" then\n        return sFormat(\"%q\", value)\n    elseif check == \"number\" then\n        return value\n    elseif check == \"boolean\" then\n        return tostring(value)\n    else\n        return '\"Not Supported\"'\n    end\n\n    return concat(t)\nend\n\nfunction deserialize(s)\n    return load(\"return \" .. s)()\nend\n\n\nend)\npackage.preload['YFS:../e/render/e/stream/src/Stream.lua']=(function()\nlocal _ = require('YFS:../e/render/e/stream/e/serializer.lua')\nlocal byte = string.byte\nlocal concat = table.concat\n\n---@module \"interface.Device\"\n\n---@alias CommQueue { queue:string[], waitingForReply:boolean, seq:integer }\n---@alias ScreenLink {setScriptInput:fun(string), clearScriptOutput:fun(), getScriptOutput:fun():string}\n---@alias Renderer {setOutput:fun(string), getInput:fun():string}\n\n---@class Stream\n---@field New fun(device:Device, parent:DataReceiver, timeout:number):Stream\n---@field Tick fun()\n---@field Write fun(data:table|string)\n---@field WaitingToSend fun():boolean\n\n--[[\n    Data format:\n    #new_message|checksum|remaining_chunks|seq|cmd|payload\n\n    Where:\n    - new_message is 0 or 1 where 0 means continuation of a message, and 1 means a new message.\n    - checksum is HEX representation of the XOR checksum of the data\n    - remaining_chunks is an integer indicating how many chunks remains to complete the message. 0 means the last chuck.\n    - seq is a single digit seqence number, used to ensure we don't read the same data twice. It wraps around at 9.\n    - cmd is a two digit integer indicating what to do with the data\n    - payload is the actual payload, if any\n]]\nlocal HEADER_SIZE = 1 -- #\n    + 1               -- new_message\n    + 1               -- |\n    + 2               -- checksum\n    + 1               -- |\n    + 3               -- remaining_chucks\n    + 1               -- |\n    + 1               -- seq\n    + 1               -- |\n    + 2               -- cmd\n    + 1               -- |\n\nlocal BLOCK_HEADER_FORMAT = \"#%0.1d|%0.2x|%0.3d|%0.1d|%0.2d|%s\"\nlocal BLOCK_HEADER_PATTERN = \"^#(%d)|(%x%x)|(%d+)|(%d)|(%d+)|(.*)$\"\n\n---@enum StreamCommand\nlocal Command = {\n    Reset = 0,\n    Poll = 1,\n    Ack = 2,\n    Data = 3,\n}\n\n---Represents a stream between two entities.\nlocal Stream = {}\nStream.__index = Stream\n\n---Create a new Stream\n---@param device Device\n---@param parent DataReceiver\n---@param timeout number The amount of time to wait for a reply before considering the connection broken.\n---@return Stream\nfunction Stream.New(device, parent, timeout)\n    local s = {}\n    local DATA_SIZE = device.BlockSize() - HEADER_SIZE -- Game allows only a certain amount of bytes in buffers\n\n    ---@diagnostic disable-next-line: undefined-global\n    local getTime = getTime or system.getUtcTime\n\n    device.Clear()\n\n    local input = { queue = {}, waitingForReply = false, seq = -1, payloadChecksum = 0 }\n    local output = { queue = {}, waitingForReply = false, seq = 0 }\n    local lastReceived = getTime()\n\n    ---@param data string\n    ---@return string # Two character HEX value\n    local function xor(data)\n        local x = 0\n        for i = 1, data:len() do\n            x = x ~ byte(data, i)\n        end\n\n        return x\n    end\n\n    ---Assembles the package\n    ---@param payload string\n    local function assemblePackage(payload)\n        input.queue[#input.queue + 1] = payload\n    end\n\n    ---Completes a transmission\n    ---@param remaining number\n    local function completeTransmission(remaining)\n        if remaining == 0 then\n            local complete = concat(input.queue)\n\n            if xor(complete) == input.payloadChecksum then\n                local deserialized = deserialize(complete)\n                parent.OnData(deserialized)\n            end\n\n            -- Last part, begin new data\n            input.queue = {}\n        end\n    end\n\n    local function sameInput(seq)\n        if seq == input.seq then\n            return true\n        end\n\n        input.seq = seq\n        return false\n    end\n\n    ---Creates a block\n    ---@param newMessage boolean\n    ---@param blockCount integer\n    ---@param commQueue CommQueue\n    ---@param cmd StreamCommand\n    ---@param payload string?\n    ---@return string\n    local function createBlock(newMessage, blockCount, commQueue, cmd, payload, checksum)\n        checksum = checksum or 0\n\n        commQueue.seq = (commQueue.seq + 1)\n        if commQueue.seq > 9 then\n            commQueue.seq = 0\n        end\n\n        payload = payload or \"\"\n        local b = string.format(BLOCK_HEADER_FORMAT, (newMessage and 1 or 0), checksum, blockCount, commQueue.seq, cmd,\n            payload)\n\n        return b\n    end\n\n    ---Reads incoming data\n    ---@return boolean #New message\n    ---@return StreamCommand|nil #Command\n    ---@return number #Packet chunks remaning\n    ---@return string #Payload\n    ---@return integer #Checksum\n    local function readData()\n        local r = device.Read()\n\n        local new, checksum, remaining, seq, cmd, payload = r:match(BLOCK_HEADER_PATTERN)\n\n        payload = payload or \"\"\n        local validPacket = remaining and cmd and new and checksum\n        if validPacket then\n            cmd = tonumber(cmd)\n            new = tonumber(new)\n            remaining = tonumber(remaining)\n            checksum = tonumber(\"0x\" .. checksum)\n            validPacket = cmd and remaining and new and checksum\n        end\n\n        if not validPacket then\n            return true, nil, 0, \"\", 0\n        end\n\n        -- Since we can't clear the input when running in RenderScript, we have to rely on the sequence number to prevent duplicate data.\n        if sameInput(seq) then\n            return true, nil, 0, \"\", 0\n        end\n\n        return new == 1, cmd, remaining, payload, checksum\n    end\n\n    local function resetQueues()\n        output.queue = {}\n        output.waitingForReply = false\n        input.queue = {}\n        input.waitingForReply = false\n    end\n\n    ---Call this function once every frame (i.e. in Update)\n    function s.Tick()\n        local new, cmd, remaining, payload, checksum = readData()\n\n        -- Did we get any input?\n        if cmd then\n            if new then\n                input.payloadChecksum = checksum\n            end\n\n            parent.OnTimeout(false, s)\n            lastReceived = getTime()\n\n            if new then\n                input.queue = {}\n            end\n\n            if device.IsController() then\n                if cmd == Command.Data then\n                    assemblePackage(payload)\n                    completeTransmission(remaining)\n                end\n                -- No need to handle ACK, it's just a trigger to move on.\n                output.waitingForReply = false\n            else\n                local sendAck = false\n\n                if cmd == Command.Poll or cmd == Command.Data then\n                    if cmd == Command.Data then\n                        assemblePackage(payload)\n                        completeTransmission(remaining)\n                    end\n\n                    -- Send either ACK or actual data as a reply\n                    if #output.queue > 0 then\n                        device.Send(table.remove(output.queue, 1))\n                    else\n                        sendAck = true\n                    end\n                elseif cmd == Command.Reset then\n                    resetQueues()\n                    sendAck = true\n                end\n\n                if sendAck then\n                    device.Send(createBlock(true, 0, output, Command.Ack))\n                end\n            end\n        end\n\n        if getTime() - lastReceived >= timeout then\n            parent.OnTimeout(true, s)\n            input.payloadChecksum = 0\n            lastReceived = getTime() -- Reset to trigger again\n            resetQueues()\n        end\n\n        if device.IsController() and not output.waitingForReply then\n            if #output.queue == 0 then\n                device.Send(createBlock(true, 0, output, Command.Poll))\n            else\n                device.Send(table.remove(output.queue, 1))\n            end\n            output.waitingForReply = true\n        end\n    end\n\n    ---Write the data to the stream\n    ---@param dataToSend table|string\n    function s.Write(dataToSend)\n        local data = serialize(dataToSend) ---@type string\n        local checksum = xor(data)\n        local blockCount = math.ceil(data:len() / DATA_SIZE)\n\n        if blockCount > 999 then\n            error(\"Too large data\")\n        end\n\n        local new = true\n\n        while data:len() > 0 do\n            blockCount = blockCount - 1\n            local part = data:sub(1, DATA_SIZE)\n            data = data:sub(DATA_SIZE + 1)\n            output.queue[#output.queue + 1] = createBlock(new, blockCount, output, Command.Data, part, checksum)\n            new = false\n            checksum = 0\n        end\n    end\n\n    ---Returns true if there is data waiting to be sent. Good for holding off additional write.\n    ---@return boolean\n    function s.WaitingToSend() return #output.queue > 0 end\n\n    setmetatable(s, Stream)\n\n    parent.RegisterStream(s)\n\n    return s\nend\n\nreturn Stream\n\nend)\npackage.preload['YFS:../e/render/e/stream/src/device/ScreenDevice.lua']=(function()\n---@module \"Device\"\n\n---@class ScreenDevice\n---@field Send fun(data:string)\n---@field Read fun():string\n---@field Clear fun()\n---@field IsController fun():boolean\n---@field BlockSize fun():integer\n---@field New fun(screenLink:table):Device\n\nlocal ScreenDevice = {}\nScreenDevice.__index = ScreenDevice\n\n---Creates a new screen interface\n---@param screenLink {getScriptOutput:stringf, clearScriptOutput:voidf, setScriptInput:fun(string)}\n---@return Device\nfunction ScreenDevice.New(screenLink)\n    local s = {}\n\n    ---@param data string\n    function s.Send(data)\n        screenLink.setScriptInput(data)\n    end\n\n    ---@return string\n    function s.Read()\n        local data = screenLink.getScriptOutput()\n        screenLink.clearScriptOutput()\n        return data\n    end\n\n    function s.Clear()\n        screenLink.clearScriptOutput()\n    end\n\n    ---@return boolean\n    function s.IsController()\n        -- We're running on the controller when we have a link to a screen\n        return true\n    end\n\n    function s.BlockSize()\n        return 1024\n    end\n\n    return setmetatable(s, ScreenDevice)\nend\n\nreturn ScreenDevice\n\nend)\npackage.preload['YFS:../e/lib/src/util/MassFormat.lua']=(function()\nlocal oneTon = 1000\nlocal kiloTon = 1000 * 1000\n\n---@param kg number\nfunction MassFormat(kg)\n    if kg >= kiloTon then\n        return { value = kg / kiloTon, unit = \"kt\" }\n    elseif kg >= oneTon then\n        return { value = kg / oneTon, unit = \"t\" }\n    else\n        return { value = kg, unit = \"kg\" }\n    end\nend\n\nreturn MassFormat\n\nend)\npackage.preload['YFS:controller/ScreenController.lua']=(function()\nrequire('YFS:../e/lib/src/abstraction/Vehicle.lua')\nrequire('YFS:GlobalTypes.lua')\nlocal s                                                                                         = require('YFS:Singletons.lua')\nlocal log, pub, su, commandLine, calc                                                           = s.log, s.pub, s\n    .strUtil, s.commandLine, s.calc\n\nlocal ValueTree, layout, Stream, ScreenDevice, pagination, distanceFormat, massFormat, max, min =\n    require('YFS:../e/lib/src/util/ValueTree.lua'), require('YFS:screen/layout_out.lua'), require('YFS:../e/render/e/stream/src/Stream.lua'), require('YFS:../e/render/e/stream/src/device/ScreenDevice.lua'),\n    require('YFS:../e/lib/src/util/Pagination.lua'), require('YFS:../e/lib/src/util/DistanceFormat.lua'), require('YFS:../e/lib/src/util/MassFormat.lua'), math.max, math.min\n\n---@class ScreenController\n---@field ActivateFloorMode fun(string):boolean\n\nlocal ScreenController                                                                          = {}\nScreenController.__index                                                                        = ScreenController\n\n---@param flightCore FlightCore\n---@param settings Settings\n---@return ScreenController\nfunction ScreenController.New(flightCore, settings)\n    local s = {}\n    local layoutSent = false\n\n    local rc = flightCore.GetRouteController()\n    local dataToScreen = ValueTree.New()\n    local routePage = 1\n    local routesPerPage = 6\n\n    local waypointPage = 1\n    local waypointsPerPage = 10\n\n    local floorPage = 1\n    local floorPointsPerPage = 24\n\n    local stream ---@type Stream -- forward declared\n\n    local routeEditorPrefix = \"#re-\"\n    local routeSelectionPrefix = \"#rsel-\"\n    local floorSelectionPrefix = \"#fl-\"\n\n    local editRouteIndex = 1\n    local editRoutePointsPerPage = 10\n\n    local editPointPage = 1\n    pub.RegisterBool(\"RouteOpenedForEdit\", function(_, _)\n        editPointPage = 1\n    end)\n\n    function s.OnData(data)\n        -- Publish data to system\n        if data == nil then return end\n        local command = data[\"mouse_click\"]\n        if command ~= nil then\n            if su.StartsWith(command, routeEditorPrefix) then\n                s.runRouteEditorCommand(su.RemovePrefix(command, routeEditorPrefix))\n            elseif su.StartsWith(command, routeSelectionPrefix) then\n                s.runRouteSelectionCommand(su.RemovePrefix(command, routeSelectionPrefix))\n            elseif su.StartsWith(command, floorSelectionPrefix) then\n                s.runFloorSelectionCommand(su.RemovePrefix(command, floorSelectionPrefix))\n            else\n                commandLine.Exec(command)\n                s.updateFloorData()\n                s.updateEditRouteData()\n                s.sendRoutes()\n            end\n        end\n    end\n\n    ---@param isTimedOut boolean\n    ---@param stream Stream\n    function s.OnTimeout(isTimedOut, stream)\n        if isTimedOut then\n            layoutSent = false\n        elseif not layoutSent then\n            stream.Write({ screen_layout = layout })\n\n            local floorRoute = settings.String(\"showFloor\")\n            local floorActivated = false\n\n            if floorRoute ~= \"-\" then\n                floorActivated = s.ActivateFloorMode(floorRoute)\n                if not floorActivated then\n                    log.Error(\"Could not activate floor mode\")\n                end\n            end\n\n            if not floorActivated then\n                stream.Write({ activate_page = \"status,routeSelection\" })\n            end\n\n            s.sendRoutes()\n            layoutSent = true\n        end\n    end\n\n    function s.RegisterStream(stream)\n\n    end\n\n    ---@param cmd string\n    function s.runRouteEditorCommand(cmd)\n        if cmd == \"previous-route\" then\n            editRouteIndex = max(1, editRouteIndex - 1)\n        elseif cmd == \"next-route\" then\n            editRouteIndex = min(#rc.GetRouteNames(), editRouteIndex + 1)\n        elseif cmd == \"prev-point-page\" then\n            local r = rc.CurrentEdit()\n            if r then\n                editPointPage = max(1, editPointPage - 1)\n            end\n        elseif cmd == \"next-point-page\" then\n            local r = rc.CurrentEdit()\n            if r then\n                editPointPage = min(editPointPage + 1, r.GetPageCount(editRoutePointsPerPage))\n            end\n        elseif cmd == \"prev-wp-page\" then\n            waypointPage = max(1, waypointPage - 1)\n        elseif cmd == \"next-wp-page\" then\n            waypointPage = min(waypointPage + 1, rc.GetWaypointPages(waypointsPerPage))\n        end\n\n        s.updateEditRouteData()\n    end\n\n    ---@param cmd string\n    function s.runRouteSelectionCommand(cmd)\n        if cmd == \"next-route-page\" then\n            routePage = min(routePage + 1, rc.GetPageCount(routesPerPage))\n        elseif cmd == \"prev-route-page\" then\n            routePage = max(1, routePage - 1)\n        end\n        s.sendRoutes()\n    end\n\n    ---@param cmd string\n    function s.runFloorSelectionCommand(cmd)\n        if cmd == \"next-floor-page\" then\n            floorPage = min(floorPage + 1, pagination.GetPageCount(rc.SelectableFloorPoints(), floorPointsPerPage))\n        elseif cmd == \"prev-floor-page\" then\n            floorPage = max(1, floorPage - 1)\n        end\n        s.updateFloorData()\n    end\n\n    function s.sendRoutes()\n        local routeSelection = {\n            routePage = routePage,\n            pageCount = rc.GetPageCount(routesPerPage),\n            routes = {}\n        }\n        for i, r in ipairs(rc.GetRoutePage(routePage, routesPerPage)) do\n            routeSelection.routes[tostring(i)] = { visible = true, name = r }\n        end\n\n        -- Ensure to hide the rest if routes have been removed.\n        for i = TableLen(routeSelection.routes) + 1, routesPerPage, 1 do\n            routeSelection.routes[tostring(i)] = { visible = false, name = \"\" }\n        end\n\n        dataToScreen.Set(\"routeSelection\", routeSelection)\n    end\n\n    function s.updateEditRouteData()\n        local routeNames = rc.GetRouteNames()\n        local editRoute = {\n            ix = editRouteIndex,\n            count = #routeNames,\n            currentPage = editPointPage,\n            pageCount = editPointPage,\n            selectRouteName = \"\",\n            routeName = \"\",\n            points = {}\n        }\n\n        if #routeNames > 0 then\n            editRoute.selectRouteName = routeNames[editRouteIndex]\n        end\n\n        local editing = rc.CurrentEdit()\n        local pointsShown = 0\n\n        if editing then\n            editRoute.name = rc.CurrentEditName()\n            editRoute.pageCount = editing.GetPageCount(editRoutePointsPerPage)\n            local points = editing.GetPointPage(editPointPage, editRoutePointsPerPage)\n            pointsShown = #points\n            local distances = rc.CalculateDistances(points)\n\n            for index, p in ipairs(points) do\n                local opt = p.Options()\n                local gate = opt.Get(PointOptions.GATE, false)\n                local skippable = opt.Get(PointOptions.SKIPPABLE, false)\n                local selectable = opt.Get(PointOptions.SELECTABLE, true)\n\n                local pointInfo = {\n                    visible = true,\n                    index = index + (editPointPage - 1) * editRoutePointsPerPage,\n                    position = p.Pos(),\n                    gate = gate,\n                    notGate = not gate,\n                    skippable = skippable,\n                    notSkippable = not skippable,\n                    selectable = selectable,\n                    notSelectable = not selectable\n                }\n\n                if p.HasWaypointRef() then\n                    pointInfo.pointName = p.WaypointRef()\n                else\n                    local d = distanceFormat(distances[index])\n                    pointInfo.pointName = string.format(\"%0.1f%s\", d.value, d.unit)\n                end\n\n                editRoute.points[tostring(index)] = pointInfo\n            end\n        else\n            editRoute.name = \"-\"\n        end\n\n        -- Clear old data\n        for i = pointsShown + 1, editRoutePointsPerPage, 1 do\n            editRoute.points[tostring(i)] = {\n                visible = false,\n                gate = false,\n                notGate = false,\n                skippable = false,\n                notSkippable = false,\n                selectable = false,\n                notSelectable = false\n            }\n        end\n\n        dataToScreen.Set(\"editRoute\", editRoute)\n\n        local availableWaypoints = {\n            currentPage = waypointPage,\n            pageCount = rc.GetWaypointPages(waypointsPerPage),\n            wayPoints = {}\n        }\n\n        local waypoints = rc.GetWaypointPage(waypointPage, waypointsPerPage)\n        for index, p in ipairs(waypoints) do\n            availableWaypoints.wayPoints[tostring(index)] = {\n                visible = true,\n                name = p.name,\n                pos = p.point.Pos()\n            }\n        end\n\n        for i = #waypoints + 1, waypointsPerPage, 1 do\n            availableWaypoints.wayPoints[tostring(i)] = { visible = false }\n        end\n\n        dataToScreen.Set(\"availableWaypoints\", availableWaypoints)\n    end\n\n    function s.updateFloorData()\n        local points = rc.SelectableFloorPoints()\n\n        local floorSelection = {\n            routeName = rc.FloorRouteName(),\n            points = {},\n            currentPage = floorPage,\n            pageCount = pagination.GetPageCount(points, floorPointsPerPage)\n        }\n\n        local selectable = pagination.Paginate(points, floorPage, floorPointsPerPage)\n\n        floorSelection.currentPage = floorPage\n        for i, p in ipairs(selectable) do\n            floorSelection.points[tostring(i)] = p\n        end\n\n        -- Clear any removed points\n        for i = #selectable + 1, floorPointsPerPage, 1 do\n            floorSelection.points[tostring(i)] = { visible = false, name = \"\", index = \"0\" }\n        end\n\n        dataToScreen.Set(\"floorSelection\", floorSelection)\n    end\n\n    ---@param routeName string\n    ---@return boolean\n    function s.ActivateFloorMode(routeName)\n        local r = rc.LoadFloorRoute(routeName)\n        if r then\n            floorPage = 1\n            s.updateFloorData()\n            stream.Write({ activate_page = \"status,floor\" })\n        end\n        return r ~= nil\n    end\n\n    local function screenTask()\n        local screen = library.getLinkByClass(\"ScreenUnit\")\n\n        if not screen then return end\n        log.Info(\"Screen found\")\n\n        local routeTimer = Stopwatch.New()\n        routeTimer.Start()\n\n        pub.RegisterTable(\"FlightData\",\n            ---@param _ string\n            ---@param data FlightData\n            function(_, data)\n                dataToScreen.Set(\"flightData/absSpeed\", calc.Mps2Kph(data.absSpeed))\n                local formatted = distanceFormat(data.waypointDist)\n                dataToScreen.Set(\"nextWp/distance\", formatted.value)\n                dataToScreen.Set(\"nextWp/distanceUnit\", formatted.unit)\n\n                formatted = massFormat(TotalMass())\n                dataToScreen.Set(\"mass/total\", formatted.value)\n                dataToScreen.Set(\"mass/totalUnit\", formatted.unit)\n            end)\n\n        pub.RegisterTable(\"RouteData\",\n            ---@param _ string\n            ---@param data {remaining:RouteRemainingInfo, activeRouteName:string|nil}\n            function(_, data)\n                local formatted = distanceFormat(data.remaining.TotalDistance)\n                dataToScreen.Set(\"finalWp/distance\", formatted.value)\n                dataToScreen.Set(\"finalWp/distanceUnit\", formatted.unit)\n                dataToScreen.Set(\"route/current/name\", data.activeRouteName)\n            end)\n\n        pub.RegisterTable(\"AdjustmentData\",\n            ---@param _ string\n            ---@param data AdjustmentData\n            function(_, data)\n                dataToScreen.Set(\"deviation/distance\",\n                    string.format(\"%0.2f\", Vec3.New(data.long, data.lat, data.ver):Len()))\n            end)\n\n        pub.RegisterTable(\"FloorMonitor\",\n            ---@param _ string\n            ---@param value TelemeterResult\n            function(_, value)\n                local floor = string.format(\"Hit: %s, distance: %0.2f, limit: %0.2f\",\n                    tostring(value.Hit), value.Distance,\n                    settings.Number(\"autoShutdownFloorDistance\"))\n                dataToScreen.Set(\"floor\", floor)\n            end)\n\n        stream = Stream.New(ScreenDevice.New(screen), s, 1)\n\n        while screen do\n            screen.activate()\n            coroutine.yield()\n            stream.Tick()\n\n            if not stream.WaitingToSend() then\n                if not routeTimer.IsRunning() or routeTimer.Elapsed() > 2 then\n                    s.sendRoutes()\n                    s.updateEditRouteData()\n                    routeTimer.Restart()\n                end\n\n                -- Get data to send to screen\n                local data = dataToScreen.Pick()\n                -- Send data to screen\n                if data then\n                    stream.Write(data)\n                else\n                    stream.Write('{\"keepalive\": \"\"}')\n                end\n            end\n        end\n    end\n\n    -- Create a Task to handle communication with the screen\n    Task.New(\"ScreenController\", screenTask)\n        .Then(function(...)\n            log.Info(\"No screen connected\")\n        end).Catch(function(t)\n        log.Error(t.Name(), t.Error())\n    end)\n\n    return setmetatable(s, ScreenController)\nend\n\nreturn ScreenController\n\nend)\npackage.preload['YFS:../e/render/e/stream/src/device/RxTx.lua']=(function()\n---@alias onReceiveFunc fun(_:table, channel:string, message:string)\n---@alias EmitterLink {send:fun(channel:string, message:string), setChannelList:fun(table)}\n---@alias ReceiverLink {setChannelList:fun(channels:channelList), onEvent:fun(_:table, event:string, f:onReceiveFunc)}\n\n---@class RxTx\n---@field Send fun(data:string)\n---@field Read fun():string\n---@field Clear fun()\n---@field SetChannel fun(string)\n---@field BlockSize integer\n---@field New fun(emitter:EmitterLink, receiver:ReceiverLink, channel:string, isController:boolean):Device\n\n---@alias channelList string[]\n\nlocal RxTx = {}\nRxTx.__index = RxTx\n\n---Create a transmit/receive interface\n---@param emitter EmitterLink The emitter link\n---@param receiver ReceiverLink The receiver link\n---@param channel string The channel to communicate on\n---@param isController boolean If true, this device is considered the controller.\n---@return Device\nfunction RxTx.New(emitter, receiver, channel, isController)\n    local s = {}\n\n    -- Setup channels for two-way communication\n    local sendChannel = channel .. (isController and \"-ctrl\" or \"-worker\")\n    local recChannel = channel .. (isController and \"-worker\" or \"-ctrl\")\n\n    local inQueue = {} ---@type string[]\n\n    receiver.setChannelList({ recChannel })\n\n    ---@diagnostic disable-next-line: undefined-field\n    receiver:onEvent(\"onReceived\", function(_, chan, message)\n        -- Restore quotation marks\n        message = message:gsub(\"&#34;\", \"\\\"\")\n        inQueue[#inQueue + 1] = message\n    end)\n\n    ---@param data string\n    function s.Send(data)\n        -- Can't send quotation marks through the emitter so replace it with HTML code for it.\n        data = data:gsub(\"\\\"\", \"&#34;\")\n        emitter.send(sendChannel, data)\n    end\n\n    ---@return string\n    function s.Read()\n        return table.remove(inQueue, 1) or \"\"\n    end\n\n    function s.Clear()\n        -- NOP\n    end\n\n    ---@return boolean\n    function s.IsController()\n        return isController\n    end\n\n    function s.BlockSize()\n        return 512\n    end\n\n    return setmetatable(s, RxTx)\nend\n\nreturn RxTx\n\nend)\npackage.preload['YFS:controller/Communication.lua']=(function()\n---@module \"Settings\"\nlocal si, RxTx, Stream = require('YFS:Singletons.lua'), require('YFS:../e/render/e/stream/src/device/RxTx.lua'), require('YFS:../e/render/e/stream/src/Stream.lua')\nlocal log, pub, rx, tx = si.log, si.pub, library.getLinkByClass(\"ReceiverUnit\"), library.getLinkByClass(\"EmitterUnit\")\n\n\n---@class Communication\n---@field OnData fun(table)\n---@field OnTimeout fun(isTimedOut:boolean, stream:Stream)\n---@field RegisterStream fun(stream:Stream)\n\nlocal Communication = {}\nCommunication.__index = Communication\n\n---@param channel string\n---@return Communication\nfunction Communication.New(channel)\n    local s = {}\n    local stream ---@type Stream\n    local timedOut = true\n    local outstanding = {} ---@type table<string, table|string>\n\n    local function getOutstanding()\n        for k, v in pairs(outstanding) do\n            return k, v\n        end\n\n        return nil, nil\n    end\n\n    pub.RegisterTable(\"SendData\", function(_, value)\n        if value.topic and value.data then\n            outstanding[value.topic] = value\n        else\n            log.Error(\"Got data to send without topic or value\")\n        end\n    end)\n\n    ---@param incomingData {topic:string, data:table|string}\n    function s.OnData(incomingData)\n        local topic = incomingData.topic\n        local data = incomingData.data\n\n        if not (topic and data) then\n            log.Error(\"Received data without topic or value\")\n            return\n        end\n\n        outstanding[topic] = nil\n\n        pub.Publish(\"RecData-\" .. topic, data)\n    end\n\n    function s.OnTimeout(isTimedOut, stream)\n        if timedOut and not isTimedOut then\n            log.Info(\"Communication established\")\n        elseif not timedOut and isTimedOut then\n            log.Info(\"Communication lost\")\n        end\n        timedOut = isTimedOut\n    end\n\n    function s.RegisterStream(stream)\n        -- NOP\n    end\n\n    setmetatable(s, Communication)\n\n    if not (rx and tx) then\n        log.Error(\"Emitter or receiver not linked\")\n    else\n        stream = Stream.New(RxTx.New(tx, rx, channel, true), s, 1)\n\n        system:onEvent(\"onUpdate\", function()\n            -- Stop sending if we're all done\n            local topic, data = getOutstanding()\n            if topic and data then\n                if not stream.WaitingToSend() then\n                    stream.Write(data)\n                end\n\n                stream.Tick()\n            end\n        end)\n        log.Info(\"Communication enabled\")\n    end\n\n    return s\nend\n\nreturn Communication\n\nend)\npackage.preload['YFS:../e/STL/src/Template.lua']=(function()\n--[[ Wolfe Labs Smart Template Library (STL)\nhttps://github.com/wolfe-labs/SmartTemplateLibrary\n(C) 2022 - Wolfe Labs ]]\n\n--- Helper function that generates a clean print statement of a certain string\n---@param str string The string we need to show\n---@return string\nlocal function mkPrint(str)\nreturn 'print(\\'' .. str:gsub('\\'', '\\\\\\''):gsub('\\n', '\\\\n') .. '\\')'\nend\n\n--- Helper function that merges tables\n---@vararg table\n---@return table\nlocal function tMerge(...)\nlocal tables = {...}\nlocal result = {}\nfor _, t in pairs(tables) do\n    for k, v in pairs(t) do\n    result[k] = v\n    end\nend\nreturn result\nend\n\n--- Retrieves a certain line from a string\n---@param str string The source string\n---@param ln number The line number\n---@return string|nil\nlocal function getLine(str, ln)\nlocal _ = 0\nfor s in str:gmatch(\"([^\\n]*)\\n?\") do\n    _ = _ + 1\n    if _ == ln then\n    return s\n    end\nend\nreturn nil\nend\n\n--- Trims a string\n---@param str string The string being trimmed\n---@return string\nlocal function trim(str)\nreturn str:gsub(\"^%s*(.-)%s*$\", \"%1\")\nend\n\n---@class Template\nlocal Template = {\n--- Globals available for every template by default\nglobals = {\n    math = math,\n    table = table,\n    string = string,\n    ipairs = ipairs,\n    pairs = pairs,\n}\n}\n\n-- Makes our template directly callable\nfunction Template.__call(self, ...)\nreturn Template.render(self, ({...})[1])\nend\n\n--- Renders our template\n---@param vars table The variables to be used when rendering the template\n---@return string\nfunction Template:render(vars)\n-- Safety check, vars MUST be a table or nil\nif type(vars or {}) ~= 'table' then\n    error('Template parameters must be a table, got ' .. type(vars))\nend\n\n--- This is our return buffer\nlocal _ = {}\n\n-- Creates our environment\nlocal env = tMerge(Template.globals, self.globals or {}, vars or {}, {\n    print = function (str) table.insert(_, tostring(str or '')) end,\n})\n\n-- Invokes our template\nself.callable(env)\n\n-- General trimming\nlocal result = table.concat(_, ''):gsub('%s+', ' ')\n\n-- Trims result\nresult = result:sub(result:find('[^%s]') or 1):gsub('%s*$', '')\n\n-- Done\nreturn result\nend\n\n--- Creates a new template\n---@param source string The code for your template\n---@param globals table|nil Global variables to be used on on the template\n---@param buildErrorHandler function|nil A function to handle build errors, if none is found throws an error\n---@return Template\nfunction Template.new(source, globals, buildErrorHandler)\n-- Creates our instance\nlocal self = {\n    source = source,\n    globals = globals,\n}\n\n-- Yield function (mostly for games who limit executions per frame)\nlocal yield = (coroutine and coroutine.isyieldable() and coroutine.yield) or function () end\n\n-- Parses direct printing of variables, we'll convert a {{var}} into {% print(var) %}\nsource = source:gsub('{{(.-)}}', '{%% print(%1) %%}')\n\n-- Ensures {% if %} ... {% else %} ... {% end %} stays on same line\nsource = source:gsub('\\n%s*{%%', '{%%')\nsource = source:gsub('%%}\\n', '%%}')\n\n--- This variable stores all our Lua \"pieces\"\nlocal tPieces = {}\n\n-- Parses actual Lua inside {% lua %} tags\nwhile #source > 0 do\n    --- The start index of Lua tag\n    local iLuaStart = source:find('{%%')\n\n    --- The end index of Lua tag\n    local iLuaEnd = source:find('%%}')\n\n    -- Checks if we have a match\n    if iLuaStart then\n    -- Errors when not closing a tag\n    if not iLuaEnd then\n        error('Template error, missing Lua closing tag near: ' .. source:sub(0, 16))\n    end\n\n    --- The current text before Lua tag\n    local currentText = source:sub(1, iLuaStart - 1)\n    if #currentText then\n        table.insert(tPieces, mkPrint(currentText))\n    end\n\n    --- Our Lua tag content\n    local luaTagContent = source:sub(iLuaStart, iLuaEnd + 1):match('{%%(.-)%%}') or ''\n    table.insert(tPieces, luaTagContent)\n\n    -- Removes parsed content\n    source = source:sub(iLuaEnd + 2)\n    else\n    -- Adds remaining Lua as a single print statement\n    table.insert(tPieces, mkPrint(source))\n\n    -- Marks content as parsed\n    source = ''\n    end\n\n    -- Yields loading\n    yield()\nend\n\n-- Builds the Lua function\nself.code = table.concat(tPieces, '\\n')\n\n-- Builds our function and caches it, this is our template now\nlocal lua = string.format('return function (_) _ENV = _; _ = _ENV[_]\\n%s\\nend', self.code)\nlocal _, err = load(lua, nil, 't', {})\nif _ and not err then\n    _ = _()\nend\n\n-- Checks for any errors\nif err then\n    local _, ln, msg = err:match('^(.-):(%d+):(.+)')\n    local nearSrc = getLine(self.source, ln - 1)\n    local nearLua = getLine(self.code, ln - 1)\n\n    local ex = {\n    raw = err,\n    line = ln - 1,\n    near = trim(nearSrc or 'N/A'),\n    nearLua = trim(nearLua or 'N/A'),\n    message = trim(msg),\n    }\n\n    if buildErrorHandler then\n    buildErrorHandler(self, ex)\n    else\n    error(('Failed compiling template!\\nError: %s\\nLine: %d\\nNear: %s\\nCode: %s'):format(ex.message, ex.line, ex.near, ex.nearLua))\n    end\n\n    -- Retuns an invalid instance\n    return nil\nelse\n    -- If everything passed, assigns our callable to our compiled function\n    self.callable = _\nend\n\n-- Initializes our instance\nreturn setmetatable(self, Template)\nend\n\n-- By default, returns the constructor of our class\nreturn Template.new\nend)\npackage.preload['YFS:hud/Hud.lua']=(function()\nrequire('YFS:GlobalTypes.lua')\nlocal si                              = require('YFS:Singletons.lua')\nlocal log, pub, input, calc, Template = si.log, si.pub, si.input, si.calc, require('YFS:../e/STL/src/Template.lua')\nlocal hudTemplate                     = '<!DOCTYPE html>\\n<html>\\n\\n<head>\\n    <style>\\n        .logo {\\n            position: fixed;\\n            top: 20px;\\n            left: 20px;\\n        }\\n\\n        .ecuColor {\\n            color: rgb(255, 0, 0);\\n        }\\n\\n        .throttleColor {\\n            color: white;\\n        }\\n\\n        .throttle {\\n            position: fixed;\\n            top: 20px;\\n            left: 60px;\\n            font: 18px Montserrat;\\n            text-shadow: 2px 2px black;\\n        }\\n\\n        .progress-container {\\n            width: 335px;\\n            text-align: center;\\n        }\\n\\n        .progress-border {\\n            position: relative;\\n            height: 26px;\\n            margin: 0px;\\n            border: 2px solid white;\\n            color: #fff;\\n            background-color: black;\\n            border-radius: 10px;\\n            overflow: hidden;\\n        }\\n\\n        .progress-bar {\\n            position: relative;\\n            height: 26px;\\n            color: #fff;\\n        }\\n\\n        .progress-label {\\n            position: absolute;\\n            top: 50%;\\n            transform: translateY(-50%);\\n            width: 100%;\\n            font: 12px Montserrat;\\n            color: white;\\n            text-shadow: inherit;\\n        }\\n    </style>\\n</head>\\n\\n<body>\\n    <div class=\"logo\">\\n        <svg width=\"24\" height=\"28\" viewBox=\"0 0 24 28\" xmlns=\"http://www.w3.org/2000/svg\">\\n            <g>\\n                <path d=\"M14 12L24 0L12 10L0 0L10 12L12 28L14 12Z\" fill=\"white\" />\\n            </g>\\n        </svg>\\n    </div>\\n    {% if isECU then %}\\n    <div class=\"throttle ecuColor\">ECU Active</div>\\n    {% else %}\\n    <div class=\"throttle throttleColor\">{{throttle}}</div>\\n    {% end %}\\n    <div class=\"progress-container\">\\n        {%\\n        for _, t in ipairs({ { t = \"atmo\", c = \"#022966ff\"}, { t = \"space\", c = \"#616102ff\"}, { t = \"rocket\", c =\\n        \"#02A9BF\"}\\n        })\\n        do\\n\\n        local color = t.c\\n        local byType = fuelByType[t.t]\\n\\n        if byType then\\n        local topMargin = 15\\n        for _, curr in ipairs(byType) do\\n        local percent = round(curr.percent, 1)\\n        %}\\n        <div class=\"progress-border\" style=\"margin-top: {{topMargin - 2}}px;\">\\n            <div class=\"progress-bar\" style=\"width: {{percent}}%; background-color: {{t.c}};\">\\n            </div>\\n            <div class=\"progress-label\">\\n                <span style=\"float: left; margin-left: 10px;\">{{curr.name}}</span>\\n                <span style=\"float: right; margin-right: 10px;\">{{percent}} %</span>\\n            </div>\\n        </div>\\n        {%\\n        topMargin = 0\\n        end\\n        end\\n        end %}\\n    </div>\\n</body>\\n\\n</html>'\n\nlocal updateInterval                  = 0.3\n\n---@alias HudData {speed:number, maxSpeed:number}\n\n---@class Hud\n---@field New fun():Hud\n\nlocal Hud                             = {}\nHud.__index                           = Hud\n\n---@return Hud\nfunction Hud.New()\n    local s = {}\n    local flightData = {} ---@type FlightData\n    local fuelByType = {} ---@type table<string,FuelTankInfo[]>\n    local unitInfo = system.getItem(unit.getItemId())\n    local isECU = unitInfo.displayNameWithSize:lower():match(\"emergency\")\n\n    system.showScreen(true)\n\n    Task.New(\"HUD\", function()\n        local tpl = Template(hudTemplate, { log = log, tostring = tostring, round = calc.Round }, function(obj, err)\n            log.Error(\"Error compiling template: \", err)\n        end)\n\n        local sw = Stopwatch.New()\n        sw.Start()\n\n        while true do\n            if sw.Elapsed() > updateInterval then\n                sw.Restart()\n\n                local html = tpl({\n                    throttle = player.isFrozen() and\n                        string.format(\"Throttle: %0.0f%% (Manual Control)\", input.Throttle() * 100) or\n                        \"Automatic Control\",\n                    fuelByType = fuelByType,\n                    isECU = isECU,\n                })\n\n                system.setScreen(html)\n            end\n            coroutine.yield()\n        end\n    end).Catch(function(t)\n        log.Error(t.Name(), \" \", t.Error())\n    end)\n\n\n    pub.RegisterTable(\"FlightData\",\n        ---@param _ string\n        ---@param data FlightData\n        function(_, data)\n            flightData = data\n        end)\n\n    pub.RegisterTable(\"FuelByType\",\n        ---@param _ string\n        ---@param data table<string,FuelTankInfo[]>\n        function(_, data)\n            fuelByType = data\n        end)\n\n    return setmetatable(s, Hud)\nend\n\nreturn Hud\n\nend)\npackage.preload['YFS:../e/lib/src/panel/ValueWidget.lua']=(function()\n---@class ValueWidget\n---@field New fun(panelId:string, title:string, unit:string):ValueWidget\n---@field Close fun()\n---@field Set fun(value:any)\n---@field Update fun()\n---@field WidgetId fun():string\n\nlocal ValueWidget = {}\nValueWidget.__index = ValueWidget\n\n---@param panelId string\n---@param title string\n---@param unit string\n---@return ValueWidget\nfunction ValueWidget.New(panelId, title, unit)\n    local s = {\n        panelId = panelId,\n        title = title,\n        unit = unit,\n        widgetId = system.createWidget(panelId, \"value\"),\n        dataId = nil,\n        newValue = nil\n    }\n\n    if s.widgetId == nil then\n        system.print(\"Could not create widget!\")\n        unit.exit()\n    end\n\n    function s.Close()\n        system.removeDataFromWidget(s.dataId, s.widgetId)\n        system.destroyData(s.dataId)\n        system.destroyWidget(s.widgetId)\n    end\n\n    function s.Set(value)\n        s.newValue = tostring(value)\n    end\n\n    function s.Update()\n        if s.newValue ~= nil then\n            local str = '{ \"label\":\"' ..\n                s.title .. '\", \"value\": \"' .. s.newValue .. '\", \"unit\": \"' .. s.unit .. '\"}'\n\n            if s.dataId == nil then\n                system.destroyData(s.dataId)\n                s.dataId = system.createData(str)\n                system.addDataToWidget(s.dataId, s.widgetId)\n            else\n                system.updateData(s.dataId, str)\n            end\n\n            s.newValue = nil\n        end\n    end\n\n    function s.WidgetId()\n        return s.widgetId\n    end\n\n    setmetatable(s, ValueWidget)\n    return s\nend\n\nreturn ValueWidget\n\nend)\npackage.preload['YFS:../e/lib/src/panel/Panel.lua']=(function()\nlocal ValueWidget = require('YFS:../e/lib/src/panel/ValueWidget.lua')\n\n---@class Panel\n---@field New fun(title:string):Panel\n---@field Close fun()\n---@field Clear fun()\n---@field Update fun()\n---@field CreateValue fun(title?:string, unit?:string)\n\nlocal Panel = {}\nPanel.__index = Panel\n\n---@param title string\n---@return Panel\nfunction Panel.New(title)\n    local s = {\n        panelId = system.createWidgetPanel(title),\n        widgets = {},\n        updateHandlerId = nil\n    }\n\n    function s.Close()\n        system:clearEvent(\"update\", s.updateHandlerId)\n\n        s.Clear()\n\n        system.destroyWidgetPanel(s.panelId)\n    end\n\n    function s.Clear()\n        for _, widget in pairs(s.widgets) do\n            widget:Close()\n        end\n        s.widgets = {}\n    end\n\n    function s.CreateValue(valueTitle, unit)\n        local w = ValueWidget.New(s.panelId, valueTitle or \"\", unit or \"\")\n        s.widgets[w.WidgetId()] = w\n        return w\n    end\n\n    function s.Update()\n        for _, widget in pairs(s.widgets) do\n            widget.Update()\n        end\n    end\n\n    s.updateHandlerId = system:onEvent(\"onUpdate\", s.Update, s)\n    return setmetatable(s, Panel)\nend\n\nreturn Panel\n\nend)\npackage.preload['YFS:../e/lib/src/panel/SharedPanel.lua']=(function()\nlocal Panel = require('YFS:../e/lib/src/panel/Panel.lua')\n\n---@class SharedPanel\n---@field Instance fun():SharedPanel\n---@field Get fun(title:string):Panel\n---@field Close fun(title:string)\n\nlocal singleton = nil\n\nlocal SharedPanel = {}\nSharedPanel.__index = SharedPanel\n\n---@return SharedPanel\nfunction SharedPanel.Instance()\n    if singleton then return singleton end\n    local s = {}\n    local panels = {}\n\n    function s.Close(title)\n        local p = panels[title]\n        if p ~= nil then\n            p:Close()\n            panels[title] = nil\n        end\n    end\n\n    function s.Get(title)\n        if panels[title] == nil then\n            panels[title] = Panel.New(title)\n        end\n\n        return panels[title]\n    end\n\n    singleton = setmetatable(s, SharedPanel)\n    return s\nend\n\nreturn SharedPanel\n\nend)\npackage.preload['YFS:info/InfoCentral.lua']=(function()\nlocal s                              = require('YFS:Singletons.lua')\nlocal pub, calc, sharedPanel, format = s.pub, s.calc, require('YFS:../e/lib/src/panel/SharedPanel.lua').Instance(), string.format\n\n---@class InfoCentral\n---@field Instance fun():InfoCentral\n---@field SetBrake fun(data:BrakeData)\n\nlocal InfoCentral                    = {}\nInfoCentral.__index                  = InfoCentral\nlocal instance\n\nfunction InfoCentral.Instance()\n    if instance then return instance end\n\n    local s = {}\n\n    local brakeInfo = {\n        visible       = false,\n        panel         = nil,\n        wDeceleration = nil,\n        wCurrentDec   = nil,\n        wPid          = nil,\n    }\n\n    local flightInfo = {\n        visible = false,\n        targetSpeed = 0,\n        wStateName = nil,\n        wPointDistance = nil,\n        wAcceleration = nil,\n        wCtrlAcceleration = nil,\n        wTargetSpeed = nil,\n        wFinalSpeed = nil,\n        wSpeedDiff = nil,\n        wBrakeMaxSpeed = nil,\n        wPid = nil,\n        wDistToAtmo = nil,\n        wSpeed = nil,\n        wAdjTowards = nil,\n        wAdjDist = nil,\n        wAdjAcc = nil,\n        wAdjBrakeDistance = nil,\n        wAdjSpeed = nil\n    }\n\n    local adjustInfo = {\n        visible = false,\n        panel = nil,\n        wAdjTowards = nil,\n        wAdjDist = nil,\n        wAdjAcc = nil,\n        wAdjBrakeDistance = nil,\n        wAdjSpeed = nil\n    }\n\n    local axisInfo = {\n        visible = false,\n        pitchPanels = nil,\n        rollPanels = nil,\n        yawPanels = nil,\n    }\n\n    local waypointInfo = {\n        visible = false,\n        wDistance = nil,\n        wMargin = nil,\n        wFinalSpeed = nil,\n        wMaxSpeed = nil,\n    }\n\n    pub.RegisterBool(\"ShowInfoWidgets\", function(_, value)\n        brakeInfo.visible = value\n        flightInfo.visible = value\n        adjustInfo.visible = value\n        axisInfo.visible = value\n        waypointInfo.visible = value\n\n        if value then\n            unit.showWidget()\n        else\n            unit.hideWidget()\n        end\n\n        system.showHelper(value)\n    end)\n\n    unit.hideWidget()\n    system.showHelper(false)\n\n    ---@param value BrakeData\n    pub.RegisterTable(\"BrakeData\", function(topic, value)\n        if not brakeInfo.panel and brakeInfo.visible then\n            local p = sharedPanel.Get(\"Brake\")\n            brakeInfo.panel = p\n            brakeInfo.wMaxDeceleration = p.CreateValue(\"Max deceleration\", \"m/s2\")\n            brakeInfo.wCurrentDec = p.CreateValue(\"Brake dec.\", \"m/s2\")\n            brakeInfo.wPid = p.CreateValue(\"Pid\")\n            brakeInfo.wAutoBrakeAngle = p.CreateValue(\"Auto brake angle\")\n        elseif brakeInfo.panel and not brakeInfo.visible then\n            sharedPanel.Close(\"Brake\")\n            brakeInfo.panel = nil\n        end\n\n        if brakeInfo.panel then\n            brakeInfo.wMaxDeceleration.Set(calc.Round(value.maxDeceleration, 2))\n            brakeInfo.wCurrentDec.Set(calc.Round(value.currentDeceleration, 2))\n            brakeInfo.wPid.Set(calc.Round(value.pid, 4))\n            brakeInfo.wAutoBrakeAngle.Set(format(\"%.1f/%.1f\", value.autoBrakeAngle, value.setAutoBrakeAngle))\n        end\n    end)\n\n    ---@param topic string\n    ---@param value FlightData\n    pub.RegisterTable(\"FlightData\", function(topic, value)\n        if not flightInfo.panel and flightInfo.visible then\n            local p = sharedPanel.Get(\"Movement\")\n            flightInfo.panel = p\n            flightInfo.wStateName = p.CreateValue(\"State\", \"\")\n            flightInfo.wPointDistance = p.CreateValue(\"Point dist.\", \"m\")\n            flightInfo.wAcceleration = p.CreateValue(\"Acceleration\", \"m/s2\")\n            flightInfo.wCtrlAcceleration = p.CreateValue(\"Ctrl. acc.\", \"m/s2\")\n            flightInfo.wTargetSpeed = p.CreateValue(\"Target speed\")\n            flightInfo.wFinalSpeed = p.CreateValue(\"Final speed\")\n            flightInfo.wSpeedDiff = p.CreateValue(\"Speed diff\", \"km/h\")\n            flightInfo.wBrakeMaxSpeed = p.CreateValue(\"Brake Max Speed\", \"km/h\")\n            flightInfo.wPid = p.CreateValue(\"Pid\")\n            flightInfo.wDistToAtmo = p.CreateValue(\"Atmo dist.\", \"m\")\n            flightInfo.wSpeed = p.CreateValue(\"Abs. speed\", \"km/h\")\n        elseif brakeInfo.panel and not brakeInfo.visible then\n            sharedPanel.Close(\"Movement\")\n            flightInfo.panel = nil\n        end\n\n        if flightInfo.panel then\n            flightInfo.wStateName.Set(value.fsmState)\n            flightInfo.wPointDistance.Set(calc.Round(value.waypointDist, 2))\n            flightInfo.wAcceleration.Set(format(\"%.1f\", value.acceleration))\n            flightInfo.wCtrlAcceleration.Set(format(\"%.1f\", value.controlAcc))\n            flightInfo.wTargetSpeed.Set(format(\"%.1f (%s)\", calc.Mps2Kph(value.targetSpeed), value.targetSpeedReason))\n            flightInfo.wFinalSpeed.Set(format(\"%.1f km/h in %.1f m\", calc.Mps2Kph(value.finalSpeed),\n                value.finalSpeedDistance))\n            flightInfo.wSpeedDiff.Set(calc.Round(calc.Mps2Kph(value.speedDiff), 1))\n            flightInfo.wBrakeMaxSpeed.Set(calc.Round(calc.Mps2Kph(value.brakeMaxSpeed)))\n            flightInfo.wPid.Set(calc.Round(value.pid, 4))\n            flightInfo.wDistToAtmo.Set(calc.Round(value.distanceToAtmo, 1))\n            flightInfo.wSpeed.Set(calc.Round(calc.Mps2Kph(value.absSpeed), 1))\n        end\n    end)\n\n    ---@param topic string\n    ---@param value AdjustmentData\n    pub.RegisterTable(\"AdjustmentData\", function(topic, value)\n        if not adjustInfo.panel and adjustInfo.visible then\n            local p = sharedPanel.Get(\"Adjustment\")\n            adjustInfo.panel = p\n            adjustInfo.wLong = p.CreateValue(\"Long\", \"m\")\n            adjustInfo.wLat = p.CreateValue(\"Lat\", \"m\")\n            adjustInfo.wVert = p.CreateValue(\"Vert\", \"m\")\n        elseif adjustInfo.panel and not adjustInfo.visible then\n            sharedPanel.Close(\"Adjustment\")\n            adjustInfo.panel = nil\n        end\n\n        if adjustInfo.panel then\n            adjustInfo.wLong.Set(calc.Round(value.long, 2))\n            adjustInfo.wLat.Set(calc.Round(value.lat, 2))\n            adjustInfo.wVert.Set(calc.Round(value.ver, 2))\n        end\n    end)\n\n    ---@param p Panel\n    ---@param axisName string\n    local function createAxisValues(p, axis, axisName)\n        axis.wTitle = p.CreateValue(\"Axis\")\n        axis.wTitle.Set(axisName)\n        axis.wSpeed = p.CreateValue(\"Speed\", \"°/s\")\n        axis.wAcceleration = p.CreateValue(\"Acc.\", \"°/s2\")\n        axis.wOffset = p.CreateValue(\"Offset\", \"°\")\n    end\n\n    local function setupAxisPanels()\n        if not axisInfo.pitchPanels and axisInfo.visible then\n            local p = sharedPanel.Get(\"Rotation\")\n            axisInfo.panel = p\n            axisInfo.pitchPanels = {}\n            createAxisValues(p, axisInfo.pitchPanels, \"--- Pitch ---\")\n            axisInfo.rollPanels = {}\n            createAxisValues(p, axisInfo.rollPanels, \"--- Roll ---\")\n            axisInfo.yawPanels = {}\n            createAxisValues(p, axisInfo.yawPanels, \"--- Yaw ---\")\n        elseif axisInfo.pitchPanels and not axisInfo.visible then\n            sharedPanel.Close(\"Rotation\")\n            adjustInfo.pitchPanels = nil\n            adjustInfo.rollPanels = nil\n            adjustInfo.yawPanels = nil\n        end\n    end\n\n    ---@param p table\n    ---@param value AxisControlData\n    local function setAxisValues(p, value)\n        p.wSpeed.Set(calc.Round(value.speed, 2))\n        p.wAcceleration.Set(calc.Round(value.acceleration, 2))\n        p.wOffset.Set(calc.Round(value.offset, 2))\n    end\n\n    ---@param topic string\n    ---@param value AxisControlData\n    pub.RegisterTable(\"PitchData\", function(topic, value)\n        axisInfo.pitch = value\n\n        setupAxisPanels()\n\n        if axisInfo.panel then\n            local p = axisInfo.pitchPanels\n            if p ~= nil then\n                setAxisValues(p, value)\n            end\n        end\n    end)\n\n    ---@param topic string\n    ---@param value AxisControlData\n    pub.RegisterTable(\"RollData\", function(topic, value)\n        axisInfo.roll = value\n\n        setupAxisPanels()\n\n        if axisInfo.panel then\n            local p = axisInfo.rollPanels\n            if p ~= nil then\n                setAxisValues(p, value)\n            end\n        end\n    end)\n\n    ---@param topic string\n    ---@param value AxisControlData\n    pub.RegisterTable(\"YawData\", function(topic, value)\n        axisInfo.pitch = value\n\n        setupAxisPanels()\n\n        if axisInfo.panel then\n            local p = axisInfo.yawPanels\n            if p ~= nil then\n                setAxisValues(p, value)\n            end\n        end\n    end)\n\n    pub.RegisterTable(\"WaypointData\",\n        ---@param topic string\n        ---@param waypoint Waypoint\n        function(topic, waypoint)\n            if not waypointInfo.panel and waypointInfo.visible then\n                local p = sharedPanel.Get(\"Waypoint\")\n                waypointInfo.panel = p\n                waypointInfo.wDistance = p.CreateValue(\"Distance\", \"m\")\n                waypointInfo.wMargin = p.CreateValue(\"Margin\", \"m\")\n                waypointInfo.wFinalSpeed = p.CreateValue(\"Final speed\", \"km/h\")\n                waypointInfo.wMaxSpeed = p.CreateValue(\"Max speed\", \"km/h\")\n            elseif waypointInfo.panel and not waypointInfo.visible then\n                sharedPanel.Close(\"Waypoint\")\n                waypointInfo.panel = nil\n            end\n\n            if waypointInfo.panel then\n                waypointInfo.wDistance.Set(calc.Round(waypoint.DistanceTo(), 3))\n                waypointInfo.wMargin.Set(calc.Round(waypoint.Margin(), 3))\n                waypointInfo.wFinalSpeed.Set(calc.Round(calc.Kph2Mps(waypoint.FinalSpeed()), 1))\n                waypointInfo.wMaxSpeed.Set(calc.Round(calc.Kph2Mps(waypoint.MaxSpeed()), 1))\n            end\n        end)\n\n    instance = setmetatable(s, InfoCentral)\n    return instance\nend\n\nreturn InfoCentral\n\nend)\npackage.preload['YFS:controller/Wsad.lua']=(function()\nrequire('YFS:GlobalTypes.lua')\nlocal s                                = require('YFS:Singletons.lua')\nlocal log, universe, input, pub, gateControl,\nconstants, calc, keys, floor, gateCtrl =\n    s.log, s.universe, s.input, s.pub, s.gateCtrl, s.constants, s.calc, s.keys, s.floorDetector, s.gateCtrl\nlocal VerticalReferenceVector          = universe.VerticalReferenceVector\nlocal Sign                             = calc.Sign\nlocal NF                               = function() return not IsFrozen() end\nlocal Clamp                            = calc.Clamp\n\nlocal defaultMargin                    = constants.flight.defaultMargin\n\n---@class Wsad\n---@field New fun(flightcore:FlightCore):Wsad\n\nlocal Wsad                             = {}\nWsad.__index                           = Wsad\n\n---@param fsm FlightFSM\n---@param flightCore FlightCore\n---@param settings Settings\n---@param access Access\n---@return Wsad\nfunction Wsad.New(fsm, flightCore, settings, access)\n    local s = {}\n    local turnAngle = settings.Number(\"turnAngle\")\n    local desiredAltitude = 0\n    local vertical = 0\n    local longitudal = 0\n    local lateral = 0\n    local pointDir = Vec3.zero\n    local newMovement = false\n    local stopVerticalMovement = false\n    local yawSmoothStop = false\n    local yawStopSign = 0\n    local plane = Plane.NewByVertialReference()\n    local stopPos = Vec3.zero\n    local forwardToggle = false\n    local allowForwardToggle = settings.Boolean(\"allowForwardToggle\")\n\n    settings.Callback(\"allowForwardToggle\", function(v)\n        allowForwardToggle = v\n    end)\n\n    local function getForwardToggle()\n        return forwardToggle and allowForwardToggle\n    end\n\n\n    input.SetThrottle(1) -- Start at max speed\n    local throttleStep = settings.Get(\"throttleStep\", constants.flight.throttleStep) / 100\n    ---@cast throttleStep number\n    input.SetThrottleStep(throttleStep)\n\n    settings.Callback(\"throttleStep\", function(step)\n        input.SetThrottleStep(step / 100)\n    end)\n\n    local function checkControlMode()\n        if unit.isMouseControlActivated() or unit.isMouseDirectControlActivated() or unit.isMouseVirtualJoystickActivated() then\n            log.Error(\"Must use control scheme 'Keyboard'\")\n            unit.exit()\n        end\n    end\n\n    checkControlMode()\n\n    local function lockUser()\n        if not access.AllowsManualControl() then\n            log.Error(\"Manual control not authorized\")\n            return\n        end\n\n        player.freeze(true)\n        log.Info(\"Manual control enabled, auto shutdown disabled.\")\n    end\n\n    local function toggleUserLock()\n        if IsFrozen() then\n            player.freeze(false)\n            log.Info(\"Manual control disabled, auto shutdown enabled.\")\n        else\n            lockUser()\n        end\n    end\n\n    local function getThrottleSpeed()\n        return MaxSpeed() * input.Throttle()\n    end\n\n    ---@return number\n    local function altitude()\n        local curr = Current()\n        local body = universe.ClosestBody(curr)\n        return (curr - body.Geography.Center):Len()\n    end\n\n    local function monitorHeight()\n        desiredAltitude = altitude()\n        stopVerticalMovement = true\n    end\n\n    ---@param body Body\n    ---@return Vec3\n    local function movement(body)\n        local curr = Current()\n        -- Put the point 50 m ahead\n        local dist = 50\n\n        local dir = (plane.Forward() * (getForwardToggle() and 1 or longitudal)\n                + plane.Right() * lateral\n                + plane.Up() * vertical)\n            :Normalize()\n\n        if body:IsInAtmo(curr) and vertical == 0 then\n            -- As we meassure only periodically, we can't make the threshold too small. 0.2m/s was too small, we can miss that when moving fast.\n            if stopVerticalMovement and Velocity():ProjectOn(-VerticalReferenceVector()):Len() < 0.5 then\n                desiredAltitude = altitude()\n                stopVerticalMovement = false\n            end\n\n\n            -- Find the direction from body center to forward point and calculate a new point with same\n            -- height as the movement started at so that we move along the curvature of the body.\n            local pointInDir = curr + dir * dist\n            local center = body.Geography.Center\n            return center + (pointInDir - center):NormalizeInPlace() * desiredAltitude\n        end\n\n        return Current() + dir * dist\n    end\n\n    Task.New(\"WASD\", function()\n        local t = 0.1\n        local sw = Stopwatch.New()\n        sw.Start()\n        local wantsToMove = false\n\n        pub.RegisterBool(\"ResetWSAD\", function(_, _)\n            stopPos = Vec3.zero\n            wantsToMove = false\n            pointDir = Vec3.zero\n            forwardToggle = false\n        end)\n\n        pub.RegisterTable(\"ForwardDirectionChanged\",\n            ---@param _ string\n            ---@param value Vec3\n            function(_, value)\n                pointDir = value\n            end)\n\n        pub.RegisterTable(\"YawData\",\n            ---@param value {speed:number}\n            function(_, value)\n                if yawSmoothStop then\n                    if Sign(value.speed) ~= yawStopSign then\n                        flightCore.AlignTo(Current() + plane.Forward() * 1000)\n                        yawSmoothStop = false\n                    end\n                end\n                yawStopSign = Sign(value.speed)\n            end)\n\n        monitorHeight()\n\n        while true do\n            local curr = Current()\n            local body = universe.ClosestBody(curr)\n\n            local hadNewMovement = newMovement\n\n            wantsToMove = getForwardToggle() or longitudal ~= 0 or vertical ~= 0 or lateral ~= 0\n            if not wantsToMove and newMovement then\n                stopPos = Current()\n            end\n\n            if IsFrozen() then\n                if wantsToMove then\n                    gateControl.Enable(false)\n                    if pointDir:IsZero() then\n                        -- Recovery after running a route\n                        pointDir = plane.Forward()\n                    end\n\n                    if sw.Elapsed() > t or newMovement then\n                        sw.Restart()\n\n                        local throttleSpeed = getThrottleSpeed()\n                        local target = movement(body)\n                        flightCore.GotoTarget(target, pointDir, defaultMargin, throttleSpeed, throttleSpeed, true, true)\n                    end\n                else\n                    if newMovement then\n                        flightCore.GotoTarget(stopPos, pointDir, defaultMargin, 0, construct.getMaxSpeed(), true, true)\n                    elseif not stopPos:IsZero() and Velocity():Normalize():Dot(stopPos - curr) >= 0 then\n                        local holdMargin = defaultMargin\n                        flightCore.GotoTarget(Current(), pointDir, holdMargin, calc.Kph2Mps(2), 0, false, true)\n                        stopPos = Vec3.zero\n                    end\n                end\n            else\n                -- Ensure we keep throttle at max when not in manual control.\n                input.SetThrottle(1)\n            end\n\n            -- Reset this only if it was active at the start of the loop.\n            if hadNewMovement then\n                newMovement = false\n            end\n\n            coroutine.yield()\n        end\n    end)\n\n    local function change(value, delta)\n        forwardToggle = false\n\n        local prev = value\n        value = Clamp(value + delta, -1, 1)\n\n        if value == 0 then\n            monitorHeight()\n        end\n\n        newMovement = value ~= prev\n        gateControl.Enable(false)\n\n        return value\n    end\n\n    ---@param delta integer\n    local function changeVertical(delta)\n        vertical = change(vertical, delta)\n    end\n\n    ---@param delta integer\n    local function changeLongitudal(delta)\n        longitudal = change(longitudal, delta)\n    end\n\n    ---@param delta integer\n    local function changeLateral(delta)\n        lateral = change(lateral, delta)\n    end\n\n    local function NewIgnoreBoth()\n        return Criteria.New().IgnoreLCtrl().IgnoreLShift()\n    end\n\n    local function fwd() changeLongitudal(1) end\n    local function back() changeLongitudal(-1) end\n\n    input.Register(keys.forward, NewIgnoreBoth().OnRepeat(), fwd)\n    input.Register(keys.forward, NewIgnoreBoth().OnRelease(), back)\n    input.Register(keys.backward, NewIgnoreBoth().OnRepeat(), back)\n    input.Register(keys.backward, NewIgnoreBoth().OnRelease(), fwd)\n\n    local function left() changeLateral(-1) end\n    local function right() changeLateral(1) end\n\n    input.RegisterMany({ keys.strafeleft, keys.left }, NewIgnoreBoth().OnRepeat(), left)\n    input.RegisterMany({ keys.strafeleft, keys.left }, NewIgnoreBoth().OnRelease(), right)\n    input.RegisterMany({ keys.straferight, keys.right }, NewIgnoreBoth().OnRepeat(), right)\n    input.RegisterMany({ keys.straferight, keys.right }, NewIgnoreBoth().OnRelease(), left)\n\n    local function up() changeVertical(1) end\n    local function down() changeVertical(-1) end\n\n    input.Register(keys.up, NewIgnoreBoth().OnRepeat(), up)\n    input.Register(keys.up, NewIgnoreBoth().OnRelease(), down)\n    input.Register(keys.down, NewIgnoreBoth().OnRepeat(), down)\n    input.Register(keys.down, NewIgnoreBoth().OnRelease(), up)\n\n    local function turn(positive)\n        if NF() then return end\n        pointDir = flightCore.Turn(positive and turnAngle or -turnAngle, plane.Up())\n    end\n\n    input.Register(keys.yawleft, NewIgnoreBoth().OnRepeat(), function()\n        turn(true)\n    end)\n\n    input.Register(keys.yawright, NewIgnoreBoth().OnRepeat(), function()\n        turn(false)\n    end)\n\n    input.RegisterMany({ keys.yawleft, keys.yawright }, NewIgnoreBoth().OnRelease(),\n        function()\n            if NF() then return end\n            yawSmoothStop = true\n        end)\n\n    local function booster(on)\n        if NF() then return end\n        fsm.SetBooster(on)\n    end\n\n    input.Register(keys.brake, Criteria.New().LCtrl().OnPress(), function()\n        forwardToggle = false\n        newMovement = true\n        pointDir = plane.Forward()\n        stopPos = Current()\n    end)\n\n    input.Register(keys.booster, NewIgnoreBoth().OnPress(), function() booster(true) end)\n    input.Register(keys.booster, NewIgnoreBoth().OnRelease(), function() booster(false) end)\n\n    -- shift + alt + Option9 to switch modes\n    input.Register(keys.option9, Criteria.New().LShift().OnPress(), toggleUserLock)\n\n    input.Register(keys.stopengines, NewIgnoreBoth().OnPress(), function()\n        if NF() then return end\n        forwardToggle = not forwardToggle\n        newMovement = true\n    end)\n\n    if settings.Get(\"manualControlOnStartup\", false) then\n        log.Info(\"Manual control on startup active.\")\n        lockUser()\n    end\n\n    settings.Callback(\"turnAngle\",\n        ---@param angle number\n        function(angle)\n            turnAngle = angle\n        end)\n\n    return setmetatable(s, Wsad)\nend\n\nreturn Wsad\n\nend)\npackage.preload['YFS:Access.lua']=(function()\nlocal s = require('YFS:Singletons.lua')\nlocal log, su = s.log, s.strUtil\n\n---@alias AdminData table<string, boolean>\n---@alias ConstructOwner {id:integer, isOrganization:boolean}\n\n---@class Access\n---@field CanExecute fun(command:string):boolean\n---@field AllowsManualControl fun():boolean\n---@field AllowedRoute fun(routeName:string)\n---@field DisallowRoute fun(routeName:string)\n---@field MayStartRoute fun(routeName:string):boolean\n---@field New fun(db:BufferedDB):Access\n\nlocal Access = {}\nAccess.__index = Access\nlocal instance\n\n---@param db BufferedDB\n---@param cmdLine CommandLine\n---@return Access\nfunction Access.New(db, cmdLine)\n    if instance then return instance end\n\n    local s = {}\n    local ROUTES, MANUAL, ORG_ADMIN, ADMIN = \"allowedRoutes\", \"allowManualControl\", \"orgAdmin\", \"adminList\"\n\n    ---@return ConstructOwner\n    local function getOwner()\n        ---@type {id:integer, isOrganization:boolean}\n        return construct.getOwner()\n    end\n\n    local function isOwnedByAnOrg()\n        return getOwner().isOrganization\n    end\n\n    local function isOrgAnAdmin()\n        -- By default owning org is an admin\n        return isOwnedByAnOrg() and db.Boolean(ORG_ADMIN, true)\n    end\n\n    local function isMemberOfOwningOrg()\n        local owner = getOwner()\n        if owner.isOrganization then\n            for _, v in ipairs(player.getOrgIds()) do\n                if v == owner.id then\n                    return true\n                end\n            end\n        end\n        return false\n    end\n\n    local function isSingleOwner()\n        local owner = getOwner()\n        return (not owner.isOrganization) and owner.id == player.getId()\n    end\n\n    local function isInAdminList()\n        local name, admins = player.getName(), db.Get(ADMIN, {})\n        ---@cast admins AdminData\n        for k, _ in pairs(admins) do\n            if k == name then\n                return true\n            end\n        end\n\n        return false\n    end\n\n    local function isAdmin()\n        return isSingleOwner() or\n            (isOwnedByAnOrg() and isMemberOfOwningOrg() and isOrgAnAdmin()) or\n            isInAdminList()\n    end\n\n    if isAdmin() then\n        log.Info(player.getName(), \" is an admin\")\n    end\n\n    ---@param command string\n    ---@return boolean\n    function s.CanExecute(command)\n        -- Disallow everything but route-activate\n        return isAdmin() or su.StartsWith(command, \"route-activate\")\n    end\n\n    ---@return boolean\n    function s.AllowsManualControl()\n        return isAdmin() or db.Boolean(MANUAL, false)\n    end\n\n    ---@param routeName string\n    function s.AllowRoute(routeName)\n        local routes = db.Get(ROUTES, {})\n        routes[routeName] = true\n        db.Put(ROUTES, routes or {})\n    end\n\n    ---@param routeName string\n    function s.DisallowRoute(routeName)\n        local routes = db.Get(ROUTES, {})\n        routes[routeName] = nil\n        db.Put(ROUTES, routes or {})\n    end\n\n    ---@param routeName string\n    function s.MayStartRoute(routeName)\n        local routes = db.Get(ROUTES, {})\n        local mayStart = (routes and routes[routeName] ~= nil) or isAdmin()\n\n        if not mayStart then\n            log.Error(\"Not authorized to start route '\", routeName, \"'\")\n        end\n\n        return mayStart\n    end\n\n    instance = setmetatable(s, Access)\n\n    cmdLine.Accept(\"allow-route\",\n        ---@param data {commandValue:string}\n        function(data)\n            s.AllowRoute(data.commandValue)\n        end).AsString().Must()\n\n    cmdLine.Accept(\"disallow-route\",\n        ---@param data {commandValue:string}\n        function(data)\n            s.DisallowRoute(data.commandValue)\n        end).AsString().Must()\n\n    cmdLine.Accept(\"print-allowed-routes\",\n        ---@param _ {commandValue:string}\n        function(_)\n            local allowed = db.Get(ROUTES, {})\n            ---@cast allowed table\n            if TableLen(allowed) > 0 then\n                log.Info(\"Allowed routes:\")\n                for k, v in pairs(allowed) do\n                    log.Info(k)\n                end\n            else\n                log.Info(\"No allowed routes\")\n            end\n        end).AsEmpty()\n\n    cmdLine.Accept(\"allow-manual-control\", function(data)\n        db.Put(MANUAL, true)\n    end)\n\n    cmdLine.Accept(\"disallow-manual-control\", function(data)\n        db.Put(MANUAL, false)\n    end)\n\n    local function checkOrgOwner()\n        local owner = getOwner()\n        if not owner.isOrganization then\n            log.Error(\"Owner is not an organization\")\n            return false\n        end\n        return true\n    end\n\n    cmdLine.Accept(\"allow-org-admin\", function(data)\n        if checkOrgOwner() then\n            db.Put(ORG_ADMIN, true)\n            log.Info(\"Owning organization is now considered an admin\")\n        end\n    end)\n\n    cmdLine.Accept(\"disallow-org-admin\", function(data)\n        if not checkOrgOwner() then\n            return\n        end\n\n        if not isInAdminList() then\n            log.Error(\n                \"Removing the orginaization as an admin would lock yourself out since you're not in the admin list, aborting!\")\n            return\n        end\n\n        db.Put(ORG_ADMIN, false)\n        log.Info(\"Owning organization is no longer considered an admin\")\n    end)\n\n    ---@param name string\n    ---@param value? boolean\n    local function setAdmin(name, value)\n        local admins = db.Get(ADMIN, {})\n        ---@cast admins AdminData\n\n        local existed = admins[name] ~= nil\n\n        admins[name] = value or nil\n        db.Put(ADMIN, admins)\n\n        if value then\n            log.Info(name, \" added to admin list\")\n        elseif existed then\n            log.Info(name, \" removed from admin list\")\n        else\n            log.Error(name, \" is not in the admin list\")\n        end\n    end\n\n    cmdLine.Accept(\"add-admin\",\n        ---@param data {commandValue:string}\n        function(data)\n            setAdmin(data.commandValue, true)\n        end).AsString().Must()\n\n    cmdLine.Accept(\"remove-admin\",\n        ---@param data {commandValue:string}\n        function(data)\n            -- Can't remove yourself if org owned and org is not an admin, that would lock you out\n            local isAdminViaOrg = isMemberOfOwningOrg() and isOrgAnAdmin()\n            local isAssignedAdmin = isInAdminList()\n\n            if data.commandValue == player.getName() then\n                if not (isAdminViaOrg and isAssignedAdmin) then\n                    log.Error(\n                        \"Removing yourself as an admin would lock yourself out, aborting!\")\n                    return\n                end\n            end\n\n            setAdmin(data.commandValue)\n        end).AsString().Must()\n\n    cmdLine.Accept(\"print-admins\", function(_)\n        local admins = db.Get(ADMIN, {})\n        ---@cast admins AdminData\n        if TableLen(admins) > 0 then\n            log.Info(\"Admins:\")\n            for k, v in pairs(admins) do\n                log.Info(k)\n            end\n        else\n            log.Info(\"No named admins\")\n        end\n        if isOrgAnAdmin() then\n            log.Info(\"Members of owning orgs are all admins\")\n        end\n    end)\n\n    return instance\nend\n\nreturn Access\n\nend)\npackage.preload['YFS:flight/GeoFence.lua']=(function()\nrequire('YFS:../e/lib/src/abstraction/Vehicle.lua')\nlocal s                   = require('YFS:Singletons.lua')\nlocal log, universe, Vec3 = s.log, s.universe, require('YFS:../e/lib/src/math/Vec3.lua')\n\n---@alias GeoFenceData {centerPos:string, boundary:number, enabled:boolean}\n\n---@class GeoFence\n---@field Limited fun(travelDir:Vec3):boolean\n\nlocal GeoFence            = {}\nGeoFence.__index          = GeoFence\n\n---@param db BufferedDB\n---@param cmdLine CommandLine\n---@return GeoFence\nfunction GeoFence.New(db, cmdLine)\n    local s = {}\n\n    local center = Vec3.zero\n\n    ---@type GeoFenceData\n    local cfg = {\n        enabled = false,\n        centerPos = \"\",\n        boundary = 0, ---@type number\n    }\n\n    local KEY = \"geofence\"\n\n    local function load()\n        local c = db.Get(KEY)\n        ---@cast c GeoFenceData\n        if c then\n            cfg.boundary = c.boundary\n            cfg.centerPos = c.centerPos\n            cfg.enabled = c.enabled\n\n            if cfg.centerPos ~= nil and cfg.centerPos ~= \"\" then\n                center = universe.ParsePosition(cfg.centerPos).Coordinates()\n            end\n\n            cfg.boundary = cfg.boundary or 150\n        end\n    end\n\n    local function save()\n        db.Put(KEY, cfg)\n        local c = universe.ParsePosition(cfg.centerPos)\n        if c then\n            center = c.Coordinates()\n        end\n    end\n\n    local geo = cmdLine.Accept(\"geofence\",\n        ---@param data {commandValue:string, boundary:number}\n        function(data)\n            if data.boundary <= 0 then\n                log.Error(\"Boundary must be > 0\")\n                return\n            end\n\n            local c = universe.ParsePosition(data.commandValue)\n            if c then\n                cfg.centerPos = c.AsPosString()\n                cfg.boundary = data.boundary\n                cfg.enabled = true\n                save()\n\n                center = c.Coordinates()\n            end\n        end).AsString().Must()\n    geo.Option(\"boundary\").AsNumber().Must()\n\n    cmdLine.Accept(\"disable-geofence\", function()\n        cfg.enabled = false\n        save()\n    end)\n\n    cmdLine.Accept(\"print-geofence\", function(data)\n        log.Info(cfg)\n    end)\n\n    ---@param travelDir Vec3\n    ---@return boolean #True if limited\n    function s.Limited(travelDir)\n        if cfg.enabled and cfg.centerPos ~= nil and cfg.centerPos ~= \"\" then\n            local pos = Current()\n            local dir, dist = (center - pos):NormalizeLen()\n\n            -- Outside boundary or moving >90 degrees away from center\n            return dist > cfg.boundary and dir:Dot(travelDir) < 0\n        end\n\n        return false\n    end\n\n    function s.Center()\n        return center\n    end\n\n    load()\n\n    return setmetatable(s, GeoFence)\nend\n\nreturn GeoFence\n\nend)\npackage.preload['YFS:Start.lua']=(function()\nrequire('YFS:GlobalTypes.lua')\nlocal s = require('YFS:Singletons.lua')\n\nlocal pub, input, commandLine, log, radar, floorDetector = s.pub, s.input, s.commandLine, s.log, s.radar,\n    s.floorDetector\nlocal ControlCommands, RouteController, BufferedDB, Fuel, FlightFSM, FlightCore, ScreenController, Communcation, Settings, Hud, InfoCentral, Wsad, Access, GeoFence =\n    require('YFS:controller/ControlCommands.lua'),\n    require('YFS:flight/route/RouteController.lua'), require('YFS:../e/lib/src/storage/BufferedDB.lua'), require('YFS:info/Fuel.lua'),\n    require('YFS:flight/FlightFSM.lua'), require('YFS:flight/FlightCore.lua'), require('YFS:controller/ScreenController.lua'),\n    require('YFS:controller/Communication.lua'), require('YFS:Settings.lua'), require('YFS:hud/Hud.lua'), require('YFS:info/InfoCentral.lua'),\n    require('YFS:controller/Wsad.lua'), require('YFS:Access.lua'), require('YFS:flight/GeoFence.lua')\n\n---Main routine that starts the system\n---@param isECU boolean\nlocal function Start(isECU)\n    log.SetLevel(LVL.WARNING)\n\n    local routeDbName = \"Routes\"\n    local routeLink   = library.getLinkByName(routeDbName)\n\n    if not routeLink then\n        log.Error(\"Must link a databank named '\", routeDbName, \"'\")\n        unit.exit()\n        return\n    end\n\n    local settingsDbName = \"Settings\"\n    local settingLink = library.getLinkByName(settingsDbName)\n    if not settingLink then\n        log.Info(\"No DB named '\", settingsDbName, \"' linked falling back to route DB.\")\n        settingLink = routeLink\n    end\n\n    if isECU then\n        log.Info(\"Running as ECU\")\n    end\n\n    local settingsDb = BufferedDB.New(settingLink)\n    local routeDb = BufferedDB.New(routeLink)\n    local settings = Settings.Create(settingsDb)\n    local hud ---@type Hud\n    local wsad ---@type Wsad\n    local commands ---@type ControlCommands\n    local screen ---@type ScreenController\n    local fuel ---@type Fuel\n    local info ---@type InfoCentral\n\n    local followRemote = library.getLinkByName(\"FollowRemote\") ---@type any\n\n    if followRemote and (type(followRemote.activate) ~= \"function\" or type(followRemote.deactivate) ~= \"function\") then\n        followRemote = nil\n    end\n\n    if followRemote then\n        log.Info(\"Found FollowRemote switch\")\n        followRemote.activate()\n\n        unit:onEvent(\"onStop\", function()\n            followRemote.deactivate()\n        end)\n    end\n\n    Task.New(\"Main\", function()\n        settingsDb.BeginLoad()\n        routeDb.BeginLoad()\n\n        while not settingsDb.IsLoaded() or not routeDb.IsLoaded() do\n            coroutine.yield()\n        end\n\n        local access = Access.New(settingsDb, commandLine)\n        commandLine.SetAccess(access.CanExecute)\n\n        local rc = RouteController.Instance(routeDb)\n        local fsm = FlightFSM.New(settings, rc, GeoFence.New(settingsDb, commandLine))\n        local fc = FlightCore.New(rc, fsm)\n        fsm.SetFlightCore(fc)\n\n        if not isECU then\n            screen = ScreenController.New(fc, settings)\n            wsad = Wsad.New(fsm, fc, settings, access)\n        end\n\n        commands = ControlCommands.New(input, commandLine, fc, settings, screen, access, routeDb)\n\n        settings.Reload()\n        -- After this point settings are loaded so any registered callback will not be called.\n        fc.ReceiveEvents()\n\n        local floor = floorDetector.Measure()\n        if not floor.Hit or floor.Distance > settings.Get(\"autoShutdownFloorDistance\") then\n            log.Info(\"No floor detected within set limit during startup, holding postition.\")\n            rc.ActivateHoldRoute()\n            fc.StartFlight()\n        elseif isECU then\n            log.Info(\"Floor detected, shutting down\")\n            unit.exit()\n        else\n            fsm.SetState(Idle.New(fsm))\n        end\n\n        fuel = Fuel.New(settings)\n\n        info = InfoCentral.Instance()\n        hud = Hud.New()\n\n        commands.RegisterMoveCommands()\n        commands.RegisterCommonCommands(isECU)\n        if not isECU then\n            commands.RegisterRouteCommands()\n            radar.Show(settings.Boolean(\"showRadarOnStart\"))\n            radar.Sort(settings.Number(\"defaultRadarMode\"))\n\n            settings.Callback(\"defaultRadarMode\", function(value)\n                radar.Sort(value)\n            end)\n        end\n\n        pub.Publish(\"ShowInfoWidgets\", settings.Boolean(\"showWidgetsOnStart\", false))\n\n        local channel = settings.String(\"commChannel\")\n        local comm\n        if not isECU and channel ~= \"\" then\n            comm = Communcation.New(channel)\n        end\n    end).Catch(function(t)\n        log.Error(t.Name(), t.Error())\n    end)\n\n    Task.New(\"FloorMonitor\", function()\n        if floorDetector.Present() then\n            log.Info(\"FloorMonitor started\")\n            local sw = Stopwatch.New()\n            sw.Start()\n\n            while true do\n                coroutine.yield()\n                if sw.Elapsed() > 0.3 then\n                    sw.Restart()\n                    pub.Publish(\"FloorMonitor\", floorDetector.Measure())\n                end\n            end\n        end\n    end).Then(function(...)\n        log.Info(\"Auto shutdown disabled\")\n    end).Catch(function(t)\n        log.Error(t.Name(), t.Error())\n    end)\nend\n\nreturn Start\n\nend)\npackage.preload['YFS:variants/Limited.lua']=(function()\nrequire('YFS:GlobalTypes.lua')\nlocal log = require('YFS:../e/lib/src/debug/Log.lua').Instance()\nlocal Lock = require('YFS:../e/lib/src/element/Lock.lua')\nlocal v = require('YFS:version_out.lua')\nlocal linked, isECU = require('YFS:variants/CoreLinkCheck.lua')()\n\n---@class Limited\n---@field New fun():Limited\n---@field AddLimit fun(count:number, size:EngineSize, engineType:EngineType)\n\nlocal Limited = {}\nLimited.__index = Limited\n\nfunction Limited.New()\n    local s = {}\n    local lock = Lock.New()\n\n    function s.Start()\n        log.Info(v.APP_NAME)\n        log.Info(v.APP_VERSION)\n\n        if linked then\n            local start = require('YFS:Start.lua')\n            start(isECU)\n\n            Task.New(\"Lock\", function()\n                if lock.ValidateCo() then\n                    log.Info(\"Engine check passed\")\n                else\n                    error(\"Engine check failed\")\n                end\n            end).Catch(function(t)\n                unit.exit()\n            end)\n        else\n            unit.exit()\n        end\n    end\n\n    ---@param engineType EngineType\n    ---@param size EngineSize\n    ---@param count integer\n    function s.AddLimit(engineType, size, count)\n        lock.AddLimit(engineType, size, count)\n    end\n\n    return setmetatable(s, Limited)\nend\n\nreturn Limited\n\nend)"},{"key":4,"filter":{"slotKey":-5,"signature":"onStart()","args":[]},"code":"library.addEventHandlers(library)\nlibrary.addEventHandlers(system)\nlibrary.addEventHandlers(player)\nlibrary.addEventHandlers(construct)\nlibrary.addEventHandlers(unit)\nlibrary.addEventHandlers(receiver)\nlibrary.addEventHandlers(spaceRadar)\nlibrary.addEventHandlers(atmoRadar)"},{"key":5,"filter":{"slotKey":-4,"signature":"onActionStart(action)","args":[{"variable":"*"}]},"code":"system:triggerEvent('onActionStart',action)"},{"key":6,"filter":{"slotKey":-4,"signature":"onActionLoop(action)","args":[{"variable":"*"}]},"code":"system:triggerEvent('onActionLoop',action)"},{"key":7,"filter":{"slotKey":-4,"signature":"onActionStop(action)","args":[{"variable":"*"}]},"code":"system:triggerEvent('onActionStop',action)"},{"key":8,"filter":{"slotKey":-4,"signature":"onUpdate()","args":[]},"code":"system:triggerEvent('onUpdate')"},{"key":9,"filter":{"slotKey":-4,"signature":"onFlush()","args":[]},"code":"system:triggerEvent('onFlush')"},{"key":10,"filter":{"slotKey":-4,"signature":"onInputText(text)","args":[{"variable":"*"}]},"code":"system:triggerEvent('onInputText',text)"},{"key":11,"filter":{"slotKey":-4,"signature":"onCameraChanged(mode)","args":[{"variable":"*"}]},"code":"system:triggerEvent('onCameraChanged',mode)"},{"key":12,"filter":{"slotKey":-3,"signature":"onParentChanged(oldId,newId)","args":[{"variable":"*"},{"variable":"*"}]},"code":"player:triggerEvent('onParentChanged',oldId,newId)"},{"key":13,"filter":{"slotKey":-2,"signature":"onDocked(id)","args":[{"variable":"*"}]},"code":"construct:triggerEvent('onDocked',id)"},{"key":14,"filter":{"slotKey":-2,"signature":"onUndocked(id)","args":[{"variable":"*"}]},"code":"construct:triggerEvent('onUndocked',id)"},{"key":15,"filter":{"slotKey":-2,"signature":"onPlayerBoarded(id)","args":[{"variable":"*"}]},"code":"construct:triggerEvent('onPlayerBoarded',id)"},{"key":16,"filter":{"slotKey":-2,"signature":"onVRStationEntered(id)","args":[{"variable":"*"}]},"code":"construct:triggerEvent('onVRStationEntered',id)"},{"key":17,"filter":{"slotKey":-2,"signature":"onConstructDocked(id)","args":[{"variable":"*"}]},"code":"construct:triggerEvent('onConstructDocked',id)"},{"key":18,"filter":{"slotKey":-2,"signature":"onPvPTimer(active)","args":[{"variable":"*"}]},"code":"construct:triggerEvent('onPvPTimer',active)"},{"key":19,"filter":{"slotKey":-1,"signature":"onStop()","args":[]},"code":"unit:triggerEvent('onStop')"},{"key":20,"filter":{"slotKey":-1,"signature":"onTimer(timerId)","args":[{"variable":"*"}]},"code":"unit:triggerEvent('onTimer',timerId)"},{"key":21,"filter":{"slotKey":0,"signature":"onReceived(channel,message)","args":[{"variable":"*"},{"variable":"*"}]},"code":"receiver:triggerEvent('onReceived',channel,message)"},{"key":22,"filter":{"slotKey":1,"signature":"onEnter(id)","args":[{"variable":"*"}]},"code":"spaceRadar:triggerEvent('onEnter',id)"},{"key":23,"filter":{"slotKey":1,"signature":"onLeave(id)","args":[{"variable":"*"}]},"code":"spaceRadar:triggerEvent('onLeave',id)"},{"key":24,"filter":{"slotKey":1,"signature":"onIdentified(id)","args":[{"variable":"*"}]},"code":"spaceRadar:triggerEvent('onIdentified',id)"},{"key":25,"filter":{"slotKey":2,"signature":"onEnter(id)","args":[{"variable":"*"}]},"code":"atmoRadar:triggerEvent('onEnter',id)"},{"key":26,"filter":{"slotKey":2,"signature":"onLeave(id)","args":[{"variable":"*"}]},"code":"atmoRadar:triggerEvent('onLeave',id)"},{"key":27,"filter":{"slotKey":2,"signature":"onIdentified(id)","args":[{"variable":"*"}]},"code":"atmoRadar:triggerEvent('onIdentified',id)"},{"key":28,"filter":{"slotKey":-1,"signature":"onStart()","args":[]},"code":"\n\nlocal limited = require('YFS:variants/Limited.lua').New()\nlimited.AddLimit(EngineType.ATMO, EngineSize.XS, 10)\nlimited.Start()\n"}],"events":[],"methods":[]}